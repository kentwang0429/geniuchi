<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>基紐棋 (Geniuchi)</title>
    <style>
        :root {
          --bg: #0b0f19;
          --panel: rgba(255, 255, 255, 0.08);
          --panel2: rgba(255, 255, 255, 0.12);
          --stroke: rgba(255, 255, 255, 0.18);
          --text: rgba(255, 255, 255, 0.92);
          --muted: rgba(255, 255, 255, 0.65);
          --shadow: 0 16px 50px rgba(0, 0, 0, 0.45);
          --r: 18px;

          /* ✅ 棋盤背景（15x15，2040版） */
          --board-bg: url('/img/stone_2040_nogrid.png');

          /* ✅ 草地背景（放你的草地圖在 public/img/grass.png） */
          --grass-bg: url('/img/grass.png');

          /* ✅ visualViewport vars (mobile keyboard / zoom safe) */
          --vvh: 100dvh;
          --vv-top: 0px;
          --vv-bottom: 0px;
        }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial,
          Helvetica, sans-serif;
        margin: 0;
        padding: 0;
        background: radial-gradient(
            1200px 600px at 20% 0%,
            #19223b 0%,
            rgba(11, 15, 25, 0) 55%
          ),
          radial-gradient(
            900px 700px at 100% 0%,
            #173c32 0%,
            rgba(11, 15, 25, 0) 55%
          ),
          var(--bg);
        color: var(--text);
        overscroll-behavior: none;
      }

      button {
        border: 0;
        border-radius: 14px;
        padding: 10px 12px;
        font-weight: 800;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.14);
        color: var(--text);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.25);
        -webkit-tap-highlight-color: transparent;
      }
      button:active {
        transform: translateY(1px);
      }
      button[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      input {
        width: 100%;
        border-radius: 14px;
        padding: 12px 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        outline: none;

        /* ✅ iOS Safari/Chrome auto-zoom prevention */
        font-size: 16px;
        line-height: 1.2;
      }

      /* ✅ 下拉選單（給 AI 角色用） */
      select {
        border-radius: 14px;
        padding: 10px 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        outline: none;
        font-size: 14px;
      }
      .aiControls select {
        width: auto;
        min-width: 140px;
      }


      .appRoot {
        min-height: 100vh;
        min-height: 100dvh;
        display: flex;
        flex-direction: column;
      }

      .topBar {
        padding: 14px 14px 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .brand {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .brand .title {
        font-size: 16px;
        font-weight: 1000;
        letter-spacing: 0.4px;
      }
      .brand .sub {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .pill {
        padding: 8px 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.14);
        font-size: 12px;
        color: var(--muted);
      }

      .tinyBtn {
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.16);
        box-shadow: none;
      }
      .tinyBtn.copied {
        background: rgba(76, 175, 80, 0.22);
        border: 1px solid rgba(76, 175, 80, 0.35);
        color: rgba(255, 255, 255, 0.92);
      }

      .screen {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 14px;
        gap: 12px;
      }

      .card {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.13),
          rgba(255, 255, 255, 0.06)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: var(--r);
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      .grid {
        display: grid;
        gap: 12px;
      }

      .twoCols {
        display: grid;
        gap: 12px;
        grid-template-columns: 1fr;
      }
      @media (min-width: 920px) {
        .twoCols {
          grid-template-columns: 360px 1fr;
          align-items: start;
        }
      }

      .panelPad {
        padding: 12px;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .rowWrap {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .label {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .choice {
        width: 34px;
        height: 34px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      /* ===== 棋子形狀（吃 --piece） ===== */
      .circle {
        width: var(--piece);
        height: var(--piece);
        border-radius: 50%;
        background: currentColor;
      }

      .jeice {
        position: relative;
        width: var(--piece);
        height: var(--piece);
      }
      .jeice::before,
      .jeice::after {
        content: '';
        position: absolute;
        top: calc(var(--piece) * 0.08);
        left: 50%;
        width: calc(var(--piece) * 0.26);
        height: calc(var(--piece) * 0.92);
        background: currentColor;
        border-radius: 999px;
        transform-origin: 50% 0%;
      }
      .jeice::before {
        transform: translateX(-50%) rotate(38deg);
      }
      .jeice::after {
        transform: translateX(-50%) rotate(-38deg);
      }

      .star::before {
        content: '★';
        font-size: calc(var(--piece) * 1.18);
        line-height: 1;
        color: currentColor;
      }

      .square {
        width: var(--piece);
        height: var(--piece);
        background: currentColor;
      }

      .triangle {
        width: 0;
        height: 0;
        border-left: calc(var(--piece) * 0.5) solid transparent;
        border-right: calc(var(--piece) * 0.5) solid transparent;
        border-bottom: calc(var(--piece) * 0.9) solid currentColor;
      }

      .logan {
        position: relative;
        width: calc(var(--piece) * 0.72);
        height: calc(var(--piece) * 0.72);
        border-radius: 50%;
        border: calc(var(--piece) * 0.11) solid currentColor;
      }
      .logan::before,
      .logan::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: calc(var(--piece) * 1.25);
        height: calc(var(--piece) * 0.14);
        background: currentColor;
        transform-origin: center;
      }
      .logan::before {
        transform: translate(-50%, -50%) rotate(45deg);
      }
      .logan::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }

      /* ✅ 回合顯示：顏色點 + 角色icon */
      .turnPill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
      }
      .turnDot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.24);
        background: rgba(255, 255, 255, 0.35);
      }
      .turnIcon {
        width: 22px;
        height: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: scale(0.85);
        transform-origin: center;
      }
      .turnText {
        color: rgba(255, 255, 255, 0.82);
        font-weight: 900;
      }
      .turnSub {
        color: rgba(255, 255, 255, 0.65);
        font-weight: 700;
      }

      /* ===== 房間玩家列 ===== */
      .playerLine {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 10px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
      }
      .playerLeft {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
      }
      .dot {
        width: 14px;
        height: 14px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.25);
      }
      .playerName {
        font-weight: 1000;
        max-width: 180px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .playerMeta {
        font-size: 12px;
        color: var(--muted);
      }
      .badge {
        font-size: 12px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
      }

      /* ✅ AI controls */
      .aiBadge {
        border-color: rgba(255, 193, 7, 0.35);
        background: rgba(255, 193, 7, 0.12);
      }
      .aiControls {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      .aiControls .tinyBtn {
        padding: 6px 10px;
      }
      

      /* ===== Board（吃 --cell / --piece） ===== */
      .boardWrap {
        padding: 12px;

        /* ✅ 讓裡面的內容置中 */
        display: flex;
        align-items: flex-start;      /* ✅ 取消垂直置中 → 往上貼 */
        justify-content: center;      /* ✅ 水平維持置中 */
      }

      /* ================== Arena（草地 + 薄石階 + 棋盤抬高一格） ================== */
      .arena {
        /* 由 inline style 注入：--cell、--boardW */
        --step: clamp(4px, calc(var(--cell) / 4), 8px);
        --grass: clamp(14px, calc(var(--cell) * 0.9), 28px);

        position: relative;
        padding: var(--grass);

        /* ✅ 上方少一格：建築+棋盤整體往上，蓋掉建築上方草地 */
        padding-top: max(0px, calc(var(--grass) - var(--cell)));
        /* ✅ 關鍵：底部多留「一格」草地高度，讓石牆不會突出草地區 */
        padding-bottom: calc(var(--grass) + var(--cell));
        border-radius: 0;
        overflow: visible;

        background:
          var(--grass-bg),
          radial-gradient(circle at 20% 30%, rgba(255,255,255,0.07), transparent 42%),
          radial-gradient(circle at 70% 60%, rgba(0,0,0,0.12), transparent 48%),
          repeating-linear-gradient(45deg, rgba(255,255,255,0.035) 0 8px, rgba(0,0,0,0.03) 8px 16px),
          linear-gradient(180deg, #2f7a42, #1f4f2c);

        background-size: auto, auto, auto, auto, auto;
        background-position: top center, center, center, center, center;
        background-repeat: repeat-x, no-repeat, no-repeat, repeat, no-repeat;

        box-shadow:
          0 18px 46px rgba(0,0,0,0.42),
          inset 0 0 0 1px rgba(255,255,255,0.08);
      }


      /* ✅ 整體往上移一格：建築 + 平台 + 棋盤一起上去 */
      .arenaContent{
        transform: translateY(calc(var(--cell) * -1));
      }

      /* 上方建築置中，左右延伸到草地邊 */
      .arenaTop{
        display:flex;
        justify-content:center;
        margin-bottom: 10px;
        pointer-events:none;

        /* ✅ 關鍵：把草地 padding 吃回來，讓建築能填滿草地左右 */
        margin-left: calc(var(--grass) * -1);
        margin-right: calc(var(--grass) * -1);
      }

      .arenaTop img{
        width: 100%;        /* ✅ 撐滿剛剛被拉寬的 .arenaTop */
        max-width: none;    /* ✅ 避免被 max-width:100% 限制回去 */
        height: auto;
        display:block;
        border-radius: 0;          /* ✅ 直角 */
        box-shadow: 0 14px 34px rgba(0,0,0,0.32);
        user-select:none;
        -webkit-user-drag:none;
      }


      /* ✅ 石階平台（薄邊框包住棋盤） */
      .arenaStage{
        position: relative;
        width: calc(var(--boardW) + var(--step) * 2);
        box-sizing: border-box;
        padding: var(--step);
        margin: 0 auto;

        border-radius: 0;          /* ✅ 直角 */
        overflow: visible;

        /* 台階材質：跟棋盤同一張石頭圖 */
        background: var(--board-bg);
        background-size: cover;
        background-position: center;

        /* ✅ 立體感：平台本體陰影（像放在草地上） */
        box-shadow:
          0 18px 0 rgba(0,0,0,0.20),         /* 壓出“高度感” */
          0 30px 40px rgba(0,0,0,0.40),      /* 投影 */
          inset 0 0 0 1px rgba(255,255,255,0.12),
          inset 0 10px 18px rgba(0,0,0,0.22);
      }

      /* ✅ “高一格”的側面石牆（高度=1格） */
      .arenaStage::after{
        content:"";
        position:absolute;
        left:0;
        right:0;
        top:100%;
        height: var(--cell);                 /* ✅ 比草地高一格 */
        background: var(--board-bg);
        background-size: cover;
        background-position: center;
        filter: brightness(0.72) saturate(0.9); /* 側面暗一點像立體 */
        box-shadow:
          inset 0 1px 0 rgba(255,255,255,0.10),
          inset 0 -10px 16px rgba(0,0,0,0.22);
        transform: translateY(calc(var(--step) * -0.2));
      }

      /* ✅ 讓棋盤“坐在平台上”更像貼合 */
      .arenaStage::before{
        content:"";
        position:absolute;
        left:0;
        right:0;
        top:0;
        height: var(--step);
        background: linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.00));
        pointer-events:none;
      }

      /* ✅ 保證棋盤本體不被圓角/overflow裁切到格線 */
      .arenaStage .board{
        border-radius: 0 !important;
        overflow: visible !important;
      }

      .winnerLineOverlay {
        mix-blend-mode: screen;
      }

      /* ✅ 棋盤上方橫圖（置中對齊棋盤中線，寬度跟棋盤一致） */
      .boardStack{
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:10px;
      }
      .boardBanner{
        display:flex;
        justify-content:center;
        align-items:center;
        max-width:100%;
        pointer-events:none; /* 不擋棋盤點擊 */
      }
      .boardBanner img{
        width:100%;
        height:auto;
        display:block;
        border-radius: 14px;
        box-shadow:
          0 14px 34px rgba(0, 0, 0, 0.32),
          inset 0 0 0 1px rgba(255, 255, 255, 0.10);
        user-select:none;
        -webkit-user-drag:none;
      }


      .board {
        position: relative;
        display: inline-block;
        border-radius: 0 !important;
        overflow: visible !important;
        border-radius: 14px;

        /* 邊緣更「銳利」：改成較清楚的框 */
        border: none;
        box-shadow:
          0 14px 34px rgba(0, 0, 0, 0.38),
          inset 0 0 0 2px rgba(255, 255, 255, 0.16);

        --n: 15;
        --cell: 28px;
        --piece: 22px;

        width: calc(var(--n) * var(--cell));
        height: calc(var(--n) * var(--cell));

        /* ✅ 全 2D：只留你的棋盤材質，不做景深光影疊加 */
        background-image: var(--board-bg);
        background-size: 100% 100%;
        background-position: center center;

        background-repeat: no-repeat;

        cursor: pointer;
      }



      /* ✅ 石磚縫：凹槽 + 高光（吃進材質） */
      .board::before{
        content:"";
        position:absolute;
        inset:0;
        pointer-events:none;

        background-image:
          linear-gradient(to right, rgba(0,0,0,.55) 0 2px, transparent 2px 100%),
          linear-gradient(to bottom, rgba(0,0,0,.55) 0 2px, transparent 2px 100%);

        background-size: var(--cell) var(--cell);

        /* ✅ 關鍵：2px 線寬 → 位移 -1px，讓線落在格線中心，不吃格子內容 */
        background-position: -1px -1px;

        opacity: .82;
        mix-blend-mode: multiply;
        filter: none;
      }

      /* ✅ 內陰影/邊緣暗角（非常像石板棋盤框的關鍵） */
      .board::after {
        content: '';
        position: absolute;
        inset: 0;
        pointer-events: none;
        border-radius: 14px;

        /* ✅ 只留「清楚的內框」+ 很淡的內陰影，避免霧感 */
        box-shadow:
          inset 0 0 0 1px rgba(255, 255, 255, 0.10),
          inset 0 10px 18px rgba(0, 0, 0, 0.22);

        opacity: 1;
      }



      .boardGrid {
        display: grid;
      }
      .cell {
        width: var(--cell);
        height: var(--cell);

        border: 0;
        background: transparent;

        display:flex;
        align-items:center;
        justify-content:center;
        cursor: inherit;
        position: relative;
        -webkit-tap-highlight-color: transparent;
      }



      .highlight-source {
        outline: 2px solid #b84bff;
      }
      .highlight-target {
        outline: 2px dashed #b84bff;
      }
      .highlight-gudo {
        outline: 2px solid #55ffb0;
      }
      .highlight-gudo-target {
        outline: 2px dashed #55ffb0;
      }
      .highlight-gudo-self {
        outline: 2px solid #35c66a;
      }
      .highlight-jeice-source {
        outline: 2px solid rgba(255, 77, 77, 0.95);
      }
      .highlight-jeice-target {
        outline: 2px dashed rgba(255, 77, 77, 0.95);
      }

      .grayX {
        position: relative;
        width: var(--piece);
        height: var(--piece);
      }
      .grayX::before,
      .grayX::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: var(--piece);
        height: calc(var(--piece) * 0.18);
        background: currentColor;
        transform-origin: center;
      }
      .grayX::before {
        transform: translate(-50%, -50%) rotate(45deg);
      }
      .grayX::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }

      /* ===== Jeice FX layer ===== */
      .fxLayer {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .jeiceOrb {
        position: absolute;
        width: var(--piece);
        height: var(--piece);
        border-radius: 50%;
        background: rgba(255, 40, 40, 0.92);
        filter: drop-shadow(0 0 10px rgba(255, 40, 40, 0.75));
        transform: translate3d(0, 0, 0) scale(1);
        animation: jeiceMove 320ms cubic-bezier(0.15, 0.9, 0.25, 1) forwards;
      }
      .jeiceOrb::after {
        content: '';
        position: absolute;
        inset: calc(var(--piece) * -0.45);
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(255, 40, 40, 0.55),
          rgba(255, 40, 40, 0)
        );
        animation: jeicePulse 320ms ease-out forwards;
      }
      .jeiceOrb.secondary {
        animation-delay: 200ms;
      }
      .jeiceOrb.secondary::after {
        animation-delay: 200ms;
      }

      @keyframes jeiceMove {
        to {
          transform: translate3d(
              calc(var(--dx) * 1px),
              calc(var(--dy) * 1px),
              0
            )
            scale(0.92);
        }
      }
      @keyframes jeicePulse {
        0% {
          opacity: 0.9;
          transform: scale(0.85);
        }
        100% {
          opacity: 0;
          transform: scale(1.25);
        }
      }

      .fx-shake {
        animation: fxShake 260ms ease-out;
      }
      @keyframes fxShake {
        0% {
          transform: translate3d(0, 0, 0);
        }
        25% {
          transform: translate3d(1px, 0, 0);
        }
        50% {
          transform: translate3d(-1px, 0, 0);
        }
        75% {
          transform: translate3d(1px, 0, 0);
        }
        100% {
          transform: translate3d(0, 0, 0);
        }
      }

      .fx-pop::after {
        content: '';
        position: absolute;
        inset: 4px;
        border-radius: 10px;
        background: rgba(255, 40, 40, 0.12);
        border: 1px solid rgba(255, 40, 40, 0.28);
        animation: fxPop 520ms ease-out forwards;
        pointer-events: none;
      }
      @keyframes fxPop {
        0% {
          opacity: 0;
          transform: scale(0.75);
        }
        25% {
          opacity: 1;
          transform: scale(1);
        }
        100% {
          opacity: 0;
          transform: scale(1.1);
        }
      }

      /* ✅ Mobile 音效面板（一顆按鈕開關） */
      .audioPanel {
        position: fixed;
        right: 12px;
        top: calc(58px + env(safe-area-inset-top));
        z-index: 90;
        width: min(220px, 78vw);
        padding: 10px 12px;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 22px 70px rgba(0, 0, 0, 0.55);
      }
      .audioPanel.game {
        top: auto;
        bottom: calc(140px + var(--vv-bottom) + env(safe-area-inset-bottom));
      }
      .audioRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 6px 0;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.78);
      }

      /* ===== 選角：全螢幕（mobile viewport safe）===== */
      .roleScreen {
        position: fixed;
        left: 0;
        right: 0;
        top: var(--vv-top);
        height: var(--vvh);
        z-index: 50;
        background: radial-gradient(
            900px 700px at 30% 0%,
            rgba(76, 175, 80, 0.18) 0%,
            rgba(0, 0, 0, 0) 55%
          ),
          radial-gradient(
            800px 800px at 90% 10%,
            rgba(156, 39, 176, 0.18) 0%,
            rgba(0, 0, 0, 0) 55%
          ),
          var(--bg);
        display: flex;
        flex-direction: column;
        overscroll-behavior: none;
      }

      .roleTop {
        padding: calc(14px + env(safe-area-inset-top)) 14px 12px;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
      }

      .roleTopLeft {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-width: 70vw;
      }

      .miniList {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
            /* ✅ 手機：隱藏玩家 miniList，避免擠壓卡片導致上方被切到 */
      @media (hover: none) and (pointer: coarse) and (max-width: 919px) {
        .miniList { display: none; }
      }
      .miniChip {
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
        color: var(--muted);
        white-space: nowrap;
      }

      /* ✅ 讓 roleMain 變成「上卡片區 + 下說明區」兩段式佈局，
      上方 carousel 會自動吃剩餘高度（等於扣掉下方說明的高度）。 */
      .roleMain {
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        gap: 12px;

        padding: 0 12px;

        /* ✅ NEW：卡片往下，避開頂部資訊區 */
        padding-top: 8px;

        /* ✅ 保留：避免底部 dock 蓋到內容 */
        padding-bottom: calc(150px + env(safe-area-inset-bottom) + var(--vv-bottom));

        overflow: hidden;
      }


      /* ✅ 新增：卡片下方資訊區塊（名字+技能說明放這裡） */
      .roleInfoBelow {
        border-radius: 18px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(0,0,0,0.35);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        padding: 12px;
        box-shadow: 0 18px 55px rgba(0,0,0,0.45);
      }

      .roleInfoBelow .titleRow{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }

      .roleInfoBelow .bigName{
        font-size: 20px;
        font-weight: 1000;
        letter-spacing: 0.5px;
      }

      .roleInfoBelow .desc{
        margin-top: 8px;
        color: rgba(255,255,255,0.78);
        font-size: 13px;
        line-height: 1.45;
      }

      /* 你原本的 roleStats 會 margin-top:auto；放到下面就不需要 */
      .roleInfoBelow .roleStats{
        margin-top: 10px;
      }


      /* ✅ 底部 Dock：更「一體」＋鍵盤彈出也不擋按鈕 */
      .roleBottom {
        position: fixed;
        left: 12px;
        right: 12px;
        bottom: calc(12px + var(--vv-bottom));
        z-index: 70;

        display: flex;
        gap: 10px;
        align-items: center;

        /* ✅ NEW：只留一顆按鈕，置中 */
        justify-content: center;

        padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
        border-radius: 22px;

        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.22),
          rgba(0, 0, 0, 0.35)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: 0 28px 70px rgba(0, 0, 0, 0.62);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      .roleBottom::before {
        content: '';
        position: absolute;
        left: 10px;
        right: 10px;
        top: -18px;
        height: 22px;
        border-radius: 20px 20px 0 0;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0),
          rgba(0, 0, 0, 0.25)
        );
        pointer-events: none;
      }

      .confirm {
        /* ✅ NEW：不要撐滿，改成置中按鈕 */
        flex: 0 0 auto;
        width: min(420px, 86vw);

        padding: 14px 16px;
        border-radius: 16px;

        /* ✅ NEW：透明感 */
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.22);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);

        box-shadow: 0 18px 55px rgba(0,0,0,0.45);

        color: rgba(255,255,255,0.92);
        font-weight: 1000;
      }
      .confirm:disabled{
        opacity: 0.45;
        cursor: not-allowed;
      }

      .ghost {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }
      
      /* ===== 手機：滑動選卡（只顯示當前一張）===== */
      .carousel {
        position: relative;
        flex: 1;
        min-height: 0;
        height: auto;

        /* ✅ 讓卡片可以在中間置中 */
        display: flex;
        align-items: center;
        justify-content: center;

        /* ✅ 左右留黑：用遮罩漸層，比純黑更好看 */
        background:
          linear-gradient(90deg,
            rgba(0,0,0,0.78) 0%,
            rgba(0,0,0,0.40) 10%,
            rgba(0,0,0,0.00) 30%,
            rgba(0,0,0,0.00) 70%,
            rgba(0,0,0,0.40) 90%,
            rgba(0,0,0,0.78) 100%
          );

        overflow: hidden;
        touch-action: pan-y; /* 上下允許、左右交給 JS */
        -webkit-user-select: none;
        user-select: none;
      }

      /* ✅ 額外再疊一層更「聚焦」的左右暗角（可拿掉，但推薦留） */
      .carousel::before {
        content: '';
        position: absolute;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(circle at 20% 50%, rgba(0,0,0,0.55), transparent 55%),
          radial-gradient(circle at 80% 50%, rgba(0,0,0,0.55), transparent 55%);
        opacity: 0.9;
      }

      /* ✅ 正在拖曳時：取消回彈 transition（更跟手） */
      .carousel.dragging .roleCard {
        transition: none !important;
      }

      /* ✅ 單張卡：縮小約一半（scale 0.5~0.55），仍吃 drag 變數 */
      .roleCard {
        position: relative;

        /* 原本你是 92vw/420px，現在保留「內部尺寸」，
          真正縮放交給 scale，避免圖片/比例被壓扁 */
        width: min(92vw, 420px);
        aspect-ratio: 1024 / 1792;
        height: auto;
        max-height: 100%;

        border-radius: 22px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.16),
          rgba(255, 255, 255, 0.06)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: 0 28px 80px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);

        /* ✅ 縮小後 padding 也要跟著縮（避免字太擠） */
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;

        transform-origin: center;
        will-change: transform, opacity, filter;
        backface-visibility: hidden;

        /* ✅ 這裡是重點：卡縮小約一半
          - 一般手機：0.55
          - 很小手機：0.50 */
        --cardScale: 1;

        transform:
          translate3d(var(--dragx, 0px), 0, 0)
          rotate(var(--dragdeg, 0deg))
          scale(var(--cardScale));

        transition: transform 160ms cubic-bezier(0.2, 0.9, 0.2, 1);

        opacity: 1;
        filter: none;

        /* ✅ 仍然讓滑動手勢在 carousel 上吃到 */
        pointer-events: auto;
      }

      /* 更小螢幕：再縮一點 */
      @media (max-width: 420px) {
        .roleCard {
          --cardScale: 1;
          padding: 12px;
        }
      }
      /* =========================
        ✅ 選角卡：左下角技能按鈕/說明面板（Mobile）
        ========================= */

      /* 手機 carousel 裡，不要再顯示原本大段 roleDesc（避免重複） */
      .carousel .roleCard .roleDesc{
        display: none;
      }

      /* 如果你也不想下面那塊 roleInfoBelow 顯示技能文字（只留名字/Stats） */
      @media (hover: none) and (pointer: coarse) and (max-width: 919px) {
        .roleInfoBelow .desc{ display:none; }
      }
      /* ✅ 只在手機隱藏：卡片下方資訊欄（吉斯/定位/回合那塊） */
      @media (hover: none) and (pointer: coarse) and (max-width: 919px) {
        .roleInfoBelow { display: none; }
      }

      /* ✅ 桌機一定要顯示（保險） */
      @media (hover: hover) and (pointer: fine) {
        .roleInfoBelow { display: block; }
      }


      /* 左下角技能按鈕 */
      /* 左下角技能按鈕（手機卡片用） */
      .cardSkillBtn{
        position: absolute;
        left: 14px;

        /* ✅ 往上抬：避開底部 dock（你原本 bottom:12px 會被壓住） */
        bottom: 78px;

        z-index: 8;

        padding: 8px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 1000;

        /* ✅ 更亮、更明顯 */
        background: rgba(255,255,255,0.12);
        border: 1px solid rgba(255,255,255,0.26);
        box-shadow: 0 16px 40px rgba(0,0,0,0.45);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);

        color: rgba(255,255,255,0.92);
        text-shadow: 0 8px 16px rgba(0,0,0,0.55);

        pointer-events: auto;
      }


      /* 左下角技能面板（預設收起） */
      .cardSkillPop{
        position: absolute;
        left: 14px;

        /* ✅ 跟著技能按鈕上移（按鈕在 78px，所以面板再往上） */
        bottom: 126px;

        z-index: 8;

        width: min(280px, 78%);
        max-height: min(48%, 260px);
        overflow: auto;

        padding: 10px 10px;
        border-radius: 16px;

        background: rgba(0,0,0,0.62);
        border: 1px solid rgba(255,255,255,0.20);
        box-shadow: 0 18px 60px rgba(0,0,0,0.55);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);

        opacity: 0;
        transform: translateY(6px) scale(0.98);
        transition: opacity 140ms ease, transform 140ms ease;
        pointer-events: none;
      }
      .cardSkillPop.open{
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }


      .cardSkillPop.open{
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto; /* 展開狀態可滑可點 */
      }

      .cardSkillTitle{
        font-size: 12px;
        font-weight: 1000;
        color: rgba(255,255,255,0.92);
        margin-bottom: 6px;
      }

      .cardSkillText{
        font-size: 12px;
        line-height: 1.35;
        color: rgba(255,255,255,0.78);
        white-space: pre-wrap;
      }

      /* 正在拖曳時，避免你手指滑到面板造成卡頓：拖曳期間面板先不吃事件 */
      .carousel.dragging .cardSkillBtn,
      .carousel.dragging .cardSkillPop{
        pointer-events: none !important;
      }


      .roleCardHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      /* ✅ 手機：把右上 icon 釘死在卡片右上角 */
      @media (hover: none) and (pointer: coarse) and (max-width: 919px) {
        .carousel .roleCardHeader{
          position: absolute;
          top: 12px;
          right: 12px;
          z-index: 7;
          width: auto;
          pointer-events: none; /* 只是裝飾，不吃手勢 */
        }
      }

      .roleName {
        font-size: 22px;
        font-weight: 1000;
        letter-spacing: 0.6px;
      }
      .roleIcon {
        width: 46px;
        height: 46px;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(0, 0, 0, 0.15);

        /* ✅ 關鍵：讓選角卡右上角的形狀都有尺寸（除了★以外其他都需要 --piece） */
        --piece: 26px;
      }

      .roleDesc {
        color: var(--muted);
        font-size: 14px;
        line-height: 1.45;
      }
      .roleStats {
        margin-top: auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .stat {
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
        padding: 10px;
        font-size: 12px;
        color: var(--muted);
      }
      .stat b {
        color: var(--text);
      }

      .desktopDeck {
        display: none;
        height: min(520px, 70vh);
        gap: 14px;
        padding: 6px;
      }
      .desktopCard {
        flex: 1;
        border-radius: 22px;
        padding: 18px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.15),
          rgba(255, 255, 255, 0.06)
        );
        box-shadow: 0 28px 80px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 10px;
        transition: transform 220ms ease, filter 220ms ease, opacity 220ms ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .desktopCard::after {
        content: '';
        position: absolute;
        inset: -2px;
        border-radius: 24px;
        border: 2px solid rgba(255, 255, 255, 0);
        transition: border-color 220ms ease;
        pointer-events: none;
      }
      .desktopCard.active {
        transform: scale(1.06);
        filter: saturate(1.15) contrast(1.05);
      }
      .desktopCard.active::after {
        border-color: rgba(255, 255, 255, 0.4);
      }
      .desktopCard.dim {
        opacity: 0.55;
        filter: grayscale(0.2) saturate(0.8);
      }
      /* ===== 角色卡：支援整張 PNG 當卡面 ===== */
      .roleCard,
      .desktopCard {
        position: relative;
        overflow: hidden;
      }

      /* 卡面 PNG */
      .roleCard .cardArt,
      .desktopCard .cardArt {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scale(1.02);
        z-index: 0;
        pointer-events: none;
      }

      /* 薄暗角：讓字更清楚 */
      .roleCard .cardShade,
      .desktopCard .cardShade {
        position: absolute;
        inset: 0;
        background:
          radial-gradient(circle at 40% 20%, rgba(255,255,255,0.06), transparent 45%),
          linear-gradient(180deg, rgba(0,0,0,0.10), rgba(0,0,0,0.34));
        z-index: 1;
        pointer-events: none;
      }

      /* 讓原本內容在圖上層 */
      .roleCard > *,
      .desktopCard > * {
        position: relative;
        z-index: 2;
      }

      /* 右下直排名字 */
      .roleCard .cardTitleVertical,
      .desktopCard .cardTitleVertical {
        position: absolute;
        right: 14px;
        bottom: 14px;
        z-index: 3;

        writing-mode: vertical-rl;
        text-orientation: upright;
        letter-spacing: 2px;

        font-weight: 1000;
        font-size: 26px;
        color: rgba(255,255,255,0.92);
        text-shadow: 0 10px 18px rgba(0,0,0,0.55);
        pointer-events: none;
      }
      /* ✅ 手機：直排名字往上抬，避開底部 dock 視覺壓迫 */
      @media (hover: none) and (pointer: coarse) and (max-width: 919px) {
        .roleCard .cardTitleVertical{
          bottom: 84px; /* 你覺得太高/太低再微調：70~100 都合理 */
        }
      }

      @media (hover: hover) and (pointer: fine) {
        .carousel {
          display: none;
        }
        .desktopDeck {
          display: flex;
        }
      }

      @media (max-width: 420px) {
        .roleName {
          font-size: 20px;
        }
        .roleCard {
          padding: 16px;
        }
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
      }

      /* ===== 結算畫面 ResultScreen（15秒 + 可提前回房） ===== */
      .resultScreen{
        position: fixed;
        inset: 0;
        z-index: 80;

        /* ✅ 大一點的外邊距，且可滾動（小螢幕不會被裁切） */
        padding: clamp(14px, 2.2vw, 28px);
        overflow: auto;

        display:flex;
        align-items:center;
        justify-content:center;

        background: rgba(0,0,0,0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      /* ✅ 總框加寬 + 限制最大高度避免超出視窗 */
      .resultCard{
        width: min(1540px, 100%);
        max-height: calc(var(--vvh) - 2 * clamp(14px, 2.2vw, 28px));
        border-radius: 22px;
        border: 1px solid rgba(255,255,255,0.16);
        box-shadow: 0 28px 80px rgba(0,0,0,0.62);
        background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(0,0,0,0.35));
        overflow: hidden;

        display: grid;
        grid-template-columns: 1fr; /* 小尺寸先上下排 */
      }

      /* ✅ 中尺寸：仍上下排，但左區置中顯示卡 */
      @media (min-width: 980px){
        .resultCard{
          grid-template-columns: 1fr; /* 先保守：避免板子被擠爆 */
        }
      }

      /* ✅ 大尺寸：改成左右兩欄，左邊夠寬放 2 張 420×460 */
      @media (min-width: 1280px){
        .resultCard{
          grid-template-columns: 940px 1fr; /* ✅ 左邊固定寬度給兩張卡（420*2 + gap + padding） */
        }
      }
      /* =========================================================
        ✅ 只改「手機對局」的結算畫面（不影響桌機）
        依賴：App root 會在手機對局時加上 .isGameMobile
        ========================================================= */

      /* 手機結算：整體改成上棋盤、下卡片 */
      .appRoot.isGameMobile .resultCard{
        display: flex !important;
        flex-direction: column !important;
      }

      /* ✅ 上方：棋盤區 */
      .appRoot.isGameMobile .resultRight{
        order: 0;
        flex: 1 1 auto;
        min-height: 0;

        /* 讓棋盤靠上，不要把空間吃掉 */
        align-items: flex-start;
        justify-content: center;

        padding: 10px 10px 6px;
        overflow: hidden; /* 先避免整塊亂捲 */
        border-bottom: 0 !important;
      }

      /* ✅ 下方：角色卡區（可縮小） */
      .appRoot.isGameMobile .resultLeft{
        order: 1;
        flex: 0 0 auto;

        padding: 10px 12px 14px;
        border-top: 1px solid rgba(255,255,255,0.10);

        border-right: none !important;
        border-bottom: none !important;
      }

      /* ✅ 手機結算：縮小棋盤（不動桌機棋盤） */
      .appRoot.isGameMobile .resultRight .board{
        transform: scale(0.88);
        transform-origin: top center;
      }

      /* 如果你的 result 裡面也包了 arena/platform，手機結算順便把立體拆掉（只影響結算區） */
      .appRoot.isGameMobile .resultRight .arena{
        padding: 0 !important;
        background: none !important;
        box-shadow: none !important;
      }
      .appRoot.isGameMobile .resultRight .arenaContent{
        transform: none !important;
      }
      .appRoot.isGameMobile .resultRight .arenaStage{
        --step: 0px;
        width: var(--boardW) !important;
        padding: 0 !important;
        background: none !important;
        box-shadow: none !important;
      }
      .appRoot.isGameMobile .resultRight .arenaStage::before,
      .appRoot.isGameMobile .resultRight .arenaStage::after{
        content: none !important;
      }

      /* ✅ 手機結算：卡片縮小（SINGLE） */
      .appRoot.isGameMobile .resultCards{
        --rcw: min(340px, 86vw);
      }

      /* ✅ 手機結算：DUAL 兩張維持並排、且縮小（不要被你 940px 那條改成上下排） */
      .appRoot.isGameMobile .resultCards.dual{
        --rcw: min(210px, 44vw);
        grid-template-columns: repeat(2, minmax(0, var(--rcw))) !important;
        justify-content: center;
      }

      /* 可選：手機結算卡片圓角與陰影稍微收斂（更省空間） */
      .appRoot.isGameMobile .resultRoleCard{
        border-radius: 18px;
        box-shadow: 0 12px 36px rgba(0,0,0,0.38);
      }


      .resultLeft{
        padding: 16px;
        display:flex;
        flex-direction:column;
        gap: 12px;

        /* ✅ 讓卡片區在左欄置中 */
        align-items: center;

        border-right: none;
        border-bottom: 1px solid rgba(255,255,255,0.10);
      }

      @media (min-width: 1280px){
        .resultLeft{
          border-bottom: none;
          border-right: 1px solid rgba(255,255,255,0.10);
          align-items: center;
        }
      }

      .resultTitle{
        font-size: 18px;
        font-weight: 1000;
        letter-spacing: .4px;
        width: 100%;
      }
      .resultSub{
        font-size: 12px;
        color: rgba(255,255,255,0.72);
        line-height: 1.5;
        width: 100%;
      }

      /* ✅ 卡片容器：維持選角卡比例，但讓寬度可隨螢幕縮放 */
      .resultCards{
        display: grid;
        gap: 14px;
        width: 100%;
        justify-content: center;

        /* SINGLE：一張卡置中（手機最大約 86vw，桌機上限 420px） */
        --rcw: min(420px, 86vw);
        grid-template-columns: minmax(0, var(--rcw));
      }

      /* ✅ DUAL：兩張卡左右併排（手機也保持併排，單張約 44vw，上限 420px） */
      .resultCards.dual{
        --rcw: min(420px, 44vw);
        grid-template-columns: repeat(2, minmax(0, var(--rcw)));
        justify-content: center;
      }

      /* ✅ 很小螢幕：DUAL 改上下排，避免左右被擠扁 */
      @media (max-width: 940px){
        .resultCards.dual{
          grid-template-columns: minmax(0, 420px);
        }
      }

      .resultRoleCard{
        width: 100%;
        /* ✅ 420×460 的選角比例 */
        aspect-ratio: 420 / 460;

        border-radius: 22px;
        border: 1px solid rgba(255,255,255,0.14);
        background: rgba(255,255,255,0.06);
        overflow: hidden;
        position: relative;
        box-shadow: 0 18px 55px rgba(0,0,0,0.45);
      }

      .resultRoleCard img{
        width:100%;
        height:100%;
        object-fit: cover;
        display:block;
        transform: scale(1.02);
      }

      .resultRight{
        padding: 12px;
        display:flex;
        align-items:center;
        justify-content:center;

        /* ✅ 右側棋盤若太大，至少不會撐爆 */
        overflow: auto;
      }




      .resultRoleCard img{
        width:100%;
        height:100%;
        object-fit: cover;
        display:block;
        transform: scale(1.02);
      }

      .resultRight{
        padding: 12px;
        display:flex;
        align-items:center;
        justify-content:center;
      }

      .resultBottom{
        margin-top:auto;
        display:flex;
        flex-direction:column;
        gap:10px;
      }

      .resultBtn{
        width: 100%;
        padding: 14px 12px;
        border-radius: 16px;
        background: rgba(255,255,255,0.14);
        border: 1px solid rgba(255,255,255,0.18);
      }

      .resultHint{
        font-size: 12px;
        color: rgba(255,255,255,0.65);
      }


      /* ===== 勝利連線：整條直線閃電（覆蓋棋盤上層） ===== */
      .winLineLayer{
        position:absolute;
        inset:0;
        pointer-events:none;
        z-index: 6; /* 在棋子上方 */
        mix-blend-mode: screen;
        filter: drop-shadow(0 0 10px rgba(255,255,255,0.85));
      }

      .winLineSvg{
        width:100%;
        height:100%;
        display:block;
        opacity: .92;
        animation: winLineFlicker 220ms infinite alternate;
      }

      @keyframes winLineFlicker{
        from{ opacity: .70; transform: translateY(0); }
        to  { opacity: 1.00; transform: translateY(-0.5px); }
      }

      /* 可選：仍保留 winCell class（你若要同時把贏的棋子外框加亮） */
      .cell.winCell{
        outline: 2px solid rgba(255,255,255,0.55);
        outline-offset: -2px;
      }



      /* =========================================================
         ✅ 手機棋局固定版面：棋盤上方 / 資訊下方 Dock
         ========================================================= */
      .gameShell {
        position: fixed;
        left: 0;
        right: 0;
        top: var(--vv-top);
        height: var(--vvh);
        z-index: 20;
        display: flex;
        flex-direction: column;
        padding: 12px;
        padding-top: calc(10px + env(safe-area-inset-top));
        padding-bottom: calc(
          12px + env(safe-area-inset-bottom) + var(--vv-bottom)
        );
        gap: 10px;
      }

      .gameBoardArea {
        flex: 1;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .gameBoardCard {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px;
        border-radius: 0;          /* ✅ 保險：不要圓角 */
        background: transparent;   /* ✅ 保險：不要背景 */
        border: none;              /* ✅ 保險：不要邊框 */
        box-shadow: none;          /* ✅ 保險：不要陰影 */
      }


      .gameDock {
        width: 100%;
        border-radius: 22px;
        padding: 12px;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.22),
          rgba(0, 0, 0, 0.35)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: 0 28px 70px rgba(0, 0, 0, 0.62);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      .dockRow {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
      }

      .dockLeft {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .dockRight {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .dockBtns {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }

      .dockHint {
        margin-top: 8px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.65);
        line-height: 1.35;
      }

      /* ✅ 手機棋局時：把 topBar 隱藏，空間留給棋盤 */
      .appRoot.isGameMobile .topBar {
        display: none;
      }

      /* =========================================================
         ✅ (4) 技能說明：桌機右側 / 手機抽屜
         ========================================================= */
      .skillList {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .skillItem {
        display: flex;
        gap: 10px;
        align-items: flex-start;
        padding: 10px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
      }
      .skillIcon {
        width: 34px;
        height: 34px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 0 0 auto;
      }
      .skillText {
        min-width: 0;
      }
      .skillName {
        font-weight: 1000;
        font-size: 13px;
        margin-bottom: 4px;
      }
      .skillDesc {
        color: rgba(255, 255, 255, 0.72);
        font-size: 12px;
        line-height: 1.35;
      }

      .helpDrawer {
        margin-top: 10px;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.35);
        padding: 10px;
        max-height: 240px;
        overflow: auto;

        /* ✅ 只允許抽屜內上下滑，避免把整頁一起帶動 */
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        touch-action: pan-y;
      }


      /* =========================================================
         ✅ (5) 回合順序條：形狀+顏色 & 箭頭指示
         ========================================================= */
      .turnOrderBar {
        margin-top: 10px;
        padding: 10px;
        border-radius: 18px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }
      .turnOrderRow {
        display: inline-flex;
        gap: 10px;
        align-items: flex-end;
        white-space: nowrap;
      }
      .turnChip {
        position: relative;
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
        padding: 8px 10px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.18);
      }
      .turnChip .miniName {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.72);
        max-width: 88px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .turnChip .miniRole {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.55);
        max-width: 88px;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .turnArrow {
        position: absolute;
        top: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 7px solid transparent;
        border-right: 7px solid transparent;
        border-bottom: 10px solid rgba(255, 255, 255, 0.88);
        filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.35));
      }
      .turnChip.current {
        border-color: rgba(255, 255, 255, 0.35);
        background: rgba(255, 255, 255, 0.08);
      }
      .turnMiniIcon {
        --piece: 16px;
        width: 18px;
        height: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* =========================================================
         ✅ (6) 輪到你了 Toast
         ========================================================= */
      .myTurnToast {
        position: fixed;
        left: 50%;
        top: calc(14px + env(safe-area-inset-top));
        transform: translateX(-50%);
        z-index: 80;
        padding: 10px 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
        display: inline-flex;
        align-items: center;
        gap: 10px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 160ms ease, transform 160ms ease;
      }
      .myTurnToast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      .myTurnToast .txt {
        font-weight: 1000;
        color: rgba(255, 255, 255, 0.92);
        font-size: 13px;
      }
      .myTurnToast .subtxt {
        font-weight: 800;
        color: rgba(255, 255, 255, 0.72);
        font-size: 12px;
      }

      /* =========================================================
         ✅ 桌機三欄：左控制 / 中棋盤 / 右技能說明
         ========================================================= */
      .gameDesktop3 {
        display: grid;
        gap: 12px;
        grid-template-columns: 1fr;
      }
      /* ✅ 桌機三欄時：只把中間棋盤欄位往上抬 */
      @media (min-width: 1100px) {
        .gameDesktop3 .boardWrap {
          transform: translateY(-90px); /* 想更上就加大數字，例如 -60px */
        }
      }

      @media (min-width: 1100px) {
        .gameDesktop3 {
          grid-template-columns: 360px 1fr 320px;
          align-items: start;
        }
      }
      /* =========================================================
        ✅ Mobile：移除草地/平台立體/上移效果（不影響桌機）
        條件：coarse pointer + 小螢幕（對應你 isGameMobile 的邏輯）
        ========================================================= */
      @media (hover: none) and (pointer: coarse) and (max-width: 919px) {
        .arena {
          padding: 0 !important;
          padding-top: 0 !important;
          padding-bottom: 0 !important;
          background: none !important;
          box-shadow: none !important;
        }

        .arenaContent {
          transform: none !important;
        }

        .arenaStage {
          --step: 0px;
          width: var(--boardW) !important;
          padding: 0 !important;
          background: none !important;
          box-shadow: none !important;
        }
        .arenaStage::before,
        .arenaStage::after {
          content: none !important;
        }

        /* ✅ Mobile：改回「與桌機相同材質 + 邊框」，但不要立體陰影 */
        .board {
          /* 只留清楚邊框，不要外投影 */
          box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.16) !important;

          /* ✅ 跟桌機一樣的石磚材質 */
          background-image: var(--board-bg) !important;
          background-size: 100% 100% !important;
          background-position: center center !important;
          background-repeat: no-repeat !important;
          background-color: transparent !important; /* 避免底色把材質洗掉 */
        }

        /* ✅ 拿掉桌機那種內暗角立體感（只留細內框） */
        .board::after {
          box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.10) !important;
        }
      }

    </style>
  </head>
  <body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/socket.io/client-dist/socket.io.min.js"></script>

    <script>
      const e = React.createElement;

      const COLORS = ['#e53935', '#8e24aa', '#3949ab', '#1e88e5', '#00897b', '#fdd835'];

      const ROLES = [
        {
          name: '基紐',
          shape: 'circle',
          cardArt: '/img/cards/ginyu.png',
          useCardArt: true,
          desc: '回合開始可交換：選自己的基紐棋，與同行/同列的任一「非自己此角色」的正常棋交換（包含對手與自己另一角色）。使用後仍可正常落子。',
        },
        {
          name: '巴特',
          shape: 'star',
          cardArt: '/img/cards/burter.png',
          useCardArt: true,
          desc: '每回合可下兩子；但勝利需要 6 連線（同一玩家同一角色）。可在第二步前悔棋（回到本回合第一步之前）。',
        },
        {
          name: '力庫姆',
          shape: 'square',
          cardArt: '/img/cards/recoome.png',
          useCardArt: true,
          desc: '可覆蓋一般棋（不能覆蓋叉叉）。可覆蓋任何「非叉叉」棋（包含對手與自己另一角色）。',
        },
        {
          name: '羅根',
          shape: 'logan',
          cardArt: '/img/cards/logan.png',
          useCardArt: true,
          desc: '每回合兩步：第 1 步下正常棋，第 2 步下灰叉。可在第二步前悔棋（回到本回合第一步之前）。',
        },
        {
          name: '古杜',
          shape: 'triangle',
          cardArt: '/img/cards/guldo.png',
          useCardArt: true,
          desc: '回合開始可移動：選自己的古杜棋，選周圍一格的「非自己此角色」正常棋（包含對手與自己另一角色），將其移到該棋周圍空格。使用後仍可正常落子。',
        },
        {
          name: '吉斯',
          shape: 'jeice',
          cardArt: '/img/cards/jeice.png',
          useCardArt: true,
          desc: '粉碎球・擊退：發動後落子，若新落子相鄰(8方向)有「非自己此角色」正常棋，可選 1 顆將其往遠離方向擊退（最多 2 格；需後方是空格；不能擊退灰叉）。落子後可放棄擊退。',
        },
      ];

      function CardArtLayer(role) {
        if (!role?.useCardArt || !role?.cardArt) return null;

        return e(
          React.Fragment,
          null,
          e('img', {
            className: 'cardArt',
            src: role.cardArt,
            alt: role.name,
            onError: (ev) => {
              // 避免檔案不存在出現破圖 icon
              try { ev.target.style.display = 'none'; } catch (e) {}
            },
          }),
          e('div', { className: 'cardShade' }),
          e('div', { className: 'cardTitleVertical' }, role.name)
        );
      }

      function connectSocket() {
        const params = new URLSearchParams(location.search);
        const serverUrl = params.get('server');
        if (serverUrl) return io(serverUrl, { transports: ['websocket', 'polling'] });
        return io();
      }
      
      function deepCopyBoard(b) {
        return Array.isArray(b) ? b.map((row) => row.slice()) : [];
      }

      function copyText(text) {
        if (!text) return Promise.resolve(false);
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard
            .writeText(String(text))
            .then(() => true)
            .catch(() => false);
        }
        return new Promise((resolve) => {
          try {
            const ta = document.createElement('textarea');
            ta.value = String(text);
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            const ok = document.execCommand('copy');
            document.body.removeChild(ta);
            resolve(!!ok);
          } catch (e) {
            resolve(false);
          }
        });
      }

      // token 解析：token = ownerIndex*2 + slot（slot=1/2），token 從 1 開始
      function decodeToken(v) {
        const ownerIndex = Math.floor((v - 1) / 2);
        const slot = ((v - 1) % 2) + 1;
        return { ownerIndex, slot };
      }

      function getPlayerRoleIndex(room, player, slot) {
        if (!room || !player) return null;
        if (room.mode === 'DUAL') return slot === 2 ? player.roleIndex2 : player.roleIndex1;
        return player.roleIndex;
      }
      // ✅ 同名回歸：先用 socket.id 找，找不到就用 name 找
      function findMePlayer(r, socketId, myName) {
        const list = r?.players || [];
        const nm = String(myName || '').trim();
        return (
          list.find((p) => p?.id === socketId) ||
          (nm ? list.find((p) => String(p?.name || '').trim() === nm) : null)
        );
      }

      function isMyTurnByIdOrName(r, me) {
        const tp = r?.players?.[r?.turnIndex];
        if (!r || !me || !tp) return false;
        return tp.id === me.id || (me.name && tp.name === me.name);
      }

      /* ✅ visualViewport -> CSS vars */
      function setupVisualViewportVars() {
        const root = document.documentElement;
        const vv = window.visualViewport;

        if (!vv) {
          root.style.setProperty('--vvh', window.innerHeight + 'px');
          root.style.setProperty('--vv-top', '0px');
          root.style.setProperty('--vv-bottom', '0px');
          return;
        }

        const h = Math.max(100, Math.round(vv.height));
        const top = Math.max(0, Math.round(vv.offsetTop || 0));
        const bottom = Math.max(0, Math.round(window.innerHeight - (vv.height + vv.offsetTop)));

        root.style.setProperty('--vvh', h + 'px');
        root.style.setProperty('--vv-top', top + 'px');
        root.style.setProperty('--vv-bottom', bottom + 'px');
      }

      function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
      }

      /* =========================================================
         ✅ (7) 桌機游標：回合棋子 / 灰叉 / 魔法棒 cursor（data-uri svg）
         ========================================================= */
      function svgCursorData(svg) {
        const enc = encodeURIComponent(svg)
          .replace(/'/g, '%27')
          .replace(/"/g, '%22');
        return `url("data:image/svg+xml,${enc}") 16 16, pointer`;
      }

      function cursorPiece(shape, color) {
        const c = String(color || '#fff');
        const svgHead =
          `<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'>` +
          `<rect x='1' y='1' width='30' height='30' rx='8' ry='8' fill='rgba(0,0,0,0.25)' stroke='rgba(255,255,255,0.25)'/>`;
        const svgTail = `</svg>`;

        let body = '';
        if (shape === 'circle') body = `<circle cx='16' cy='16' r='7.2' fill='${c}' />`;
        else if (shape === 'square') body = `<rect x='9' y='9' width='14' height='14' fill='${c}' />`;
        else if (shape === 'triangle') body = `<path d='M16 8 L24 22 H8 Z' fill='${c}' />`;
        else if (shape === 'star')
          body =
            `<path d='M16 7.5 L18.7 13.1 L24.8 13.3 L19.9 17.0 L21.9 22.9 L16 19.8 L10.1 22.9 L12.1 17.0 L7.2 13.3 L13.3 13.1 Z' fill='${c}'/>`;
        else if (shape === 'logan')
          body =
            // 圈圈縮小一點
            `<circle cx='16' cy='16' r='5.6' fill='none' stroke='${c}' stroke-width='3'/>` +
            // 叉叉放大：畫到更接近外側
            `<path d='M7.8 7.8 L24.2 24.2' stroke='${c}' stroke-width='2.9' stroke-linecap='round'/>` +
            `<path d='M24.2 7.8 L7.8 24.2' stroke='${c}' stroke-width='2.9' stroke-linecap='round'/>`;

        else if (shape === 'jeice')
          body =
            `<path d='M16 7 L4.4 25' fill='none' stroke='${c}' stroke-width='6.2' stroke-linecap='round'/>` +
            `<path d='M16 7 L27.6 25' fill='none' stroke='${c}' stroke-width='6.2' stroke-linecap='round'/>`;

        else body = `<circle cx='16' cy='16' r='7.2' fill='${c}' />`;

        const svg = svgHead + body + svgTail;
        return svgCursorData(svg);
      }

      function cursorGrayX(color) {
        const c = String(color || '#cfcfcf');
        const svg =
          `<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'>` +
          `<rect x='1' y='1' width='30' height='30' rx='8' ry='8' fill='rgba(0,0,0,0.25)' stroke='rgba(255,255,255,0.25)'/>` +
          `<path d='M9 9 L23 23' stroke='${c}' stroke-width='4' stroke-linecap='round'/>` +
          `<path d='M23 9 L9 23' stroke='${c}' stroke-width='4' stroke-linecap='round'/>` +
          `</svg>`;
        return svgCursorData(svg);
      }

      function cursorWand() {
        const svg =
          `<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'>` +
          `<rect x='1' y='1' width='30' height='30' rx='8' ry='8' fill='rgba(0,0,0,0.25)' stroke='rgba(255,255,255,0.25)'/>` +
          `<path d='M9 23 L22.5 9.5' stroke='rgba(255,255,255,0.9)' stroke-width='3.2' stroke-linecap='round'/>` +
          `<path d='M20 8 L24 8 L24 12' stroke='rgba(255,255,255,0.9)' stroke-width='2.2' fill='none'/>` +
          `<path d='M8 20 L12 24' stroke='rgba(120,220,255,0.9)' stroke-width='3.4' stroke-linecap='round'/>` +
          `<circle cx='24' cy='12' r='2' fill='rgba(255,240,120,0.95)'/>` +
          `</svg>`;
        return svgCursorData(svg);
      }

      function darkenHex(hex, k = 0.6) {
        try {
          const h = String(hex || '').trim();
          if (!h.startsWith('#') || h.length !== 7) return 'rgba(210,210,210,0.92)';
          const r = Math.round(parseInt(h.slice(1, 3), 16) * k);
          const g = Math.round(parseInt(h.slice(3, 5), 16) * k);
          const b = Math.round(parseInt(h.slice(5, 7), 16) * k);
          return `rgb(${r}, ${g}, ${b})`;
        } catch (e) {
          return 'rgba(210,210,210,0.92)';
        }
      }

      /* =========================================================
         ✅ Audio（分離 BGM / SFX）
         ========================================================= */
      const AUDIO_ASSETS = {
        bgm_lobby: '/audio/chala_head_chala.mp3',
        bgm_battle_intro: '/audio/fighting_music.mp3',
        bgm_battle_loop: '/audio/fighting_music_all.mp3',
        sfx_victory: '/audio/sfx_victory_placeholder.mp3',
        sfx_ui_click: '/audio/sfx_ui_click_placeholder.mp3',
        voice_role: {
          0: '/audio/sfx_role_ginyu_name.mp3',
          1: '/audio/sfx_role_burter_name.mp3',
          2: '/audio/sfx_role_recoome_name.mp3',
          3: '/audio/sfx_role_logan_name.mp3',
          4: '/audio/sfx_role_guldo_name.mp3',
          5: '/audio/sfx_role_jeice_name.mp3',
        },
        sfx_map: {
          ginyu_place: '/audio/sfx_ginyu_place_placeholder.mp3',
          ginyu_swap: '/audio/sfx_ginyu_swap_placeholder.mp3',
          burter_place1: '/audio/sfx_burter_place1_placeholder.mp3',
          burter_place2: '/audio/sfx_burter_place2_placeholder.mp3',
          recoome_place: '/audio/sfx_recoome_place_placeholder.mp3',
          logan_place: '/audio/sfx_logan_place_placeholder.mp3',
          logan_cross: '/audio/sfx_logan_cross_placeholder.mp3',
          gudo_place: '/audio/sfx_gudo_place_placeholder.mp3',
          gudo_skill: '/audio/sfx_gudo_skill_placeholder.mp3',
          jeice_place: '/audio/sfx_jeice_place_placeholder.mp3',
          jeice_skill: '/audio/sfx_jeice_skill_placeholder.mp3',
          undo: '/audio/sfx_ui_click_placeholder.mp3',
        },
      };

      class AudioMgr {
        constructor({ onNeedGesture, onUnlocked } = {}) {
          this.onNeedGesture = typeof onNeedGesture === 'function' ? onNeedGesture : () => {};
          this.onUnlocked = typeof onUnlocked === 'function' ? onUnlocked : () => {};

          this.unlocked = false;
          this.bgmMuted = false;
          this.sfxMuted = false;
          this._wantBgm = 'lobby';

          this.bgm = null;
          this.bgmKind = null;
          this.battleLoop = null;
          this.voice = null;

          this.vol = { bgm: 0.35, sfx: 0.8, voice: 0.95 };
          this._lastVoiceAt = 0;
        }

        _makeAudio(src, { loop = false, volume = 1 } = {}) {
          const a = new Audio(src);
          a.preload = 'auto';
          a.loop = !!loop;
          a.volume = clamp(volume, 0, 1);
          return a;
        }

        _isAutoplayBlocked(err) {
          const name = err?.name || '';
          const msg = String(err?.message || '').toLowerCase();
          return (
            name === 'NotAllowedError' ||
            msg.includes('not allowed') ||
            msg.includes('user gesture') ||
            msg.includes('interact')
          );
        }

        _maybeNeedGesture(err) {
          if (this.unlocked) return;
          if (this._isAutoplayBlocked(err)) this.onNeedGesture();
        }

        async unlock() {
          if (this.unlocked) return true;

          const src =
            AUDIO_ASSETS.bgm_lobby || AUDIO_ASSETS.bgm_battle_loop || AUDIO_ASSETS.bgm_battle_intro;

          if (!src) {
            this.unlocked = false;
            this.onNeedGesture();
            return false;
          }

          const url = src.startsWith('/') ? src : `/${src}`;

          const a = new Audio(url);
          a.preload = 'auto';
          a.volume = 0;

          try {
            await a.play();
            a.pause();
            a.currentTime = 0;

            this.unlocked = true;
            this.onUnlocked();
            return true;
          } catch (e) {
            this.unlocked = false;
            this.onNeedGesture();
            return false;
          }
        }

        async _safePlay(a) {
          if (!a) return false;
          if (this.bgmMuted) return false;
          try {
            await a.play();
            if (!this.unlocked) {
              this.unlocked = true;
              this.onUnlocked();
            }
            return true;
          } catch (err) {
            this._maybeNeedGesture(err);
            return false;
          }
        }

        stopAllBgm() {
          try {
            if (this.bgm) {
              this.bgm.pause();
              this.bgm.currentTime = 0;
            }
          } catch (e) {}
          try {
            if (this.battleLoop) {
              this.battleLoop.pause();
              this.battleLoop.currentTime = 0;
            }
          } catch (e) {}
          this.bgm = null;
          this.battleLoop = null;
          this.bgmKind = null;
        }

        setBgmMuted(m) {
          this.bgmMuted = !!m;
          if (this.bgmMuted) {
            this.stopAllBgm();
            return;
          }
          this.resumeWantedBgm();
        }

        setSfxMuted(m) {
          this.sfxMuted = !!m;
          if (this.sfxMuted) {
            try {
              if (this.voice) {
                this.voice.pause();
                this.voice.currentTime = 0;
              }
            } catch (e) {}
          }
        }

        async resumeWantedBgm() {
          if (this.bgmMuted) return;
          if (!this.unlocked) {
            const ok = await this.unlock();
            if (!ok) return;
          }
          if (this._wantBgm === 'victory') return this.startVictory();
          if (this._wantBgm === 'battle') return this.startBattle();
          return this.startLobby();
        }

        async startLobby() {
          this._wantBgm = 'lobby';
          if (this.bgmMuted) return;

          if (this.bgmKind === 'lobby' && this.bgm) {
            if (this.bgm.paused) await this._safePlay(this.bgm);
            return;
          }

          this.stopAllBgm();

          const a = this._makeAudio(AUDIO_ASSETS.bgm_lobby, { loop: true, volume: this.vol.bgm });

          this.bgmKind = 'lobby';
          this.bgm = a;

          const ok = await this._safePlay(a);
          if (!ok) this.bgmKind = null;
        }

        async startBattle() {
          this._wantBgm = 'battle';
          if (this.bgmMuted) return;

          if (this.bgmKind === 'battle' && this.bgm) {
            if (this.bgm.paused) await this._safePlay(this.bgm);
            return;
          }

          this.stopAllBgm();
          this.bgmKind = 'battle';

          const introSrc = AUDIO_ASSETS.bgm_battle_intro;
          const loopSrc = AUDIO_ASSETS.bgm_battle_loop;

          if (!introSrc) {
            const loop = this._makeAudio(loopSrc, { loop: true, volume: this.vol.bgm });
            this.bgm = loop;
            const ok = await this._safePlay(loop);
            if (!ok) this.bgmKind = null;
            return;
          }

          const intro = this._makeAudio(introSrc, { loop: false, volume: 0.6 });
          const loop = this._makeAudio(loopSrc, { loop: true, volume: this.vol.bgm });

          this.bgm = intro;
          this.battleLoop = loop;

          intro.addEventListener('ended', async () => {
            if (this.bgmKind !== 'battle' || this.bgmMuted) return;
            this.bgm = loop;
            await this._safePlay(loop);
          });

          const ok = await this._safePlay(intro);
          if (!ok) this.bgmKind = null;
        }

        async startVictory() {
          this._wantBgm = 'victory';
          if (this.bgmMuted) return;

          if (this.bgmKind === 'victory' && this.bgm) {
            if (this.bgm.paused) await this._safePlay(this.bgm);
            return;
          }

          this.stopAllBgm();
          this.bgmKind = 'victory';
          this.bgm = this._makeAudio(AUDIO_ASSETS.sfx_victory, {
            loop: false,
            volume: 0.9,
          });

          const ok = await this._safePlay(this.bgm);
          if (!ok) this.bgmKind = null;
        }

        stopVictory() {
          if (this.bgmKind !== 'victory') return;
          this.stopAllBgm();
        }

        uiClick() {
          this.playOnce(AUDIO_ASSETS.sfx_ui_click, this.vol.sfx);
        }

        playOnce(src, volume = 0.8) {
          if (this.sfxMuted) return;
          if (!src) return;
          try {
            const a = this._makeAudio(src, { loop: false, volume });
            a.play().catch((err) => this._maybeNeedGesture(err));
          } catch (e) {}
        }

        playSfxKey(key) {
          const src = AUDIO_ASSETS.sfx_map?.[key];
          if (!src) return;
          this.playOnce(src, this.vol.sfx);
        }

        playRoleVoice(roleIndex) {
          if (this.sfxMuted) return;
          const src = AUDIO_ASSETS.voice_role?.[roleIndex];
          if (!src) return;

          const now = Date.now();
          if (now - this._lastVoiceAt < 550) return;
          this._lastVoiceAt = now;

          try {
            if (this.voice) {
              this.voice.pause();
              this.voice.currentTime = 0;
            }
          } catch (e) {}

          this.voice = this._makeAudio(src, { loop: false, volume: this.vol.voice });
          this.voice.play().catch((err) => this._maybeNeedGesture(err));
        }
      }

      function SkillPanel({ room }) {
        return e(
          'div',
          { className: 'skillList' },
          ROLES.map((r, idx) =>
            e(
              'div',
              { key: idx, className: 'skillItem' },
              e(
                'div',
                { className: 'skillIcon' },
                e('div', { className: r.shape, style: { '--piece': '18px', color: '#fff' } })
              ),
              e(
                'div',
                { className: 'skillText' },
                e('div', { className: 'skillName' }, r.name),
                e('div', { className: 'skillDesc' }, r.desc)
              )
            )
          )
        );
      }

      function TurnOrderBar({ room }) {
        if (!room || room.status !== 'PLAYING') return null;
        const players = room.players || [];
        if (!players.length) return null;

        const items = [];
        let currentKey = null;

        if (room.mode === 'DUAL') {
          for (let slot = 1; slot <= 2; slot++) {
            for (let i = 0; i < players.length; i++) {
              const p = players[i];
              const roleIdx = getPlayerRoleIndex(room, p, slot);
              const roleName = typeof roleIdx === 'number' ? ROLES[roleIdx]?.name : '未選角';
              const shape = typeof roleIdx === 'number' ? ROLES[roleIdx]?.shape : 'circle';
              const color =
                typeof p?.colorIndex === 'number' ? COLORS[p.colorIndex] : 'rgba(255,255,255,0.45)';
              const key = `p${i}s${slot}`;
              items.push({
                key,
                playerName: p?.name || 'Player',
                roleName,
                shape,
                color,
                slot,
              });
            }
          }
          const curIdx =
            (Number(room.turnSlot || 1) - 1) * players.length + Number(room.turnIndex || 0);
          currentKey = items[curIdx]?.key || null;
        } else {
          for (let i = 0; i < players.length; i++) {
            const p = players[i];
            const roleIdx = getPlayerRoleIndex(room, p, 1);
            const roleName = typeof roleIdx === 'number' ? ROLES[roleIdx]?.name : '未選角';
            const shape = typeof roleIdx === 'number' ? ROLES[roleIdx]?.shape : 'circle';
            const color =
              typeof p?.colorIndex === 'number' ? COLORS[p.colorIndex] : 'rgba(255,255,255,0.45)';
            const key = `p${i}`;
            items.push({ key, playerName: p?.name || 'Player', roleName, shape, color, slot: 1 });
          }
          currentKey = items[Number(room.turnIndex || 0)]?.key || null;
        }

        return e(
          'div',
          { className: 'turnOrderBar' },
          e(
            'div',
            { className: 'turnOrderRow' },
            items.map((it) =>
              e(
                'div',
                { key: it.key, className: 'turnChip ' + (it.key === currentKey ? 'current' : '') },
                it.key === currentKey ? e('div', { className: 'turnArrow' }) : null,
                e(
                  'div',
                  { className: 'turnMiniIcon' },
                  e('div', { className: it.shape, style: { color: it.color, '--piece': '16px' } })
                ),
                e('div', { className: 'miniName' }, it.playerName),
                e(
                  'div',
                  { className: 'miniRole' },
                  room.mode === 'DUAL' ? `角色${it.slot}：${it.roleName}` : it.roleName
                )
              )
            )
          )
        );
      }
      // ================= WinnerLineOverlay =================
      // Draws a winning line over the board when a winner is detected.
      // Put this BEFORE App() so it's defined before render.

      function WinnerLineOverlay({
        board,
        room,
        cellSize = 36, // if you have a real cell size, pass it in
        padding = 0,   // extra offset if your board has inner padding
      }) {
        try {
          // 1) Prefer backend-provided line if exists
          const line =
            room?.winnerLine ||
            room?.winLine ||
            room?.winner?.line ||
            room?.result?.line ||
            null;

          const b = board || room?.board;
          if (!b || !Array.isArray(b) || !b.length) return null;

          const H = b.length;
          const W = Array.isArray(b[0]) ? b[0].length : 0;
          if (!W) return null;

          // helper to normalize "who owns this cell"
          const ownerOf = (cell) => {
            if (cell == null) return null;
            if (cell === 0) return null;
            if (typeof cell === 'number' || typeof cell === 'string') return cell;
            if (typeof cell === 'object') {
              return (
                cell.ownerToken ??
                cell.owner ??
                cell.t ??
                cell.player ??
                cell.colorIndex ??
                cell.p ??
                null
              );
            }
            return null;
          };

          // 2) Compute a line if not provided
          let winCells = null;

          const targetN =
            room?.targetN ||
            room?.n ||
            (room?.mode === 'DUAL' ? 5 : 5) ||
            5;

          const dirs = [
            [1, 0],
            [0, 1],
            [1, 1],
            [1, -1],
          ];

          const inRange = (x, y) => x >= 0 && x < W && y >= 0 && y < H;

          const scan = () => {
            for (let y = 0; y < H; y++) {
              for (let x = 0; x < W; x++) {
                const o = ownerOf(b[y][x]);
                remember: if (o == null) continue;

                for (const [dx, dy] of dirs) {
                  // Only start from minimal point to avoid duplicates
                  const px = x - dx, py = y - dy;
                  if (inRange(px, py) && ownerOf(b[py][px]) === o) continue;

                  let cells = [[x, y]];
                  let nx = x + dx, ny = y + dy;

                  while (inRange(nx, ny) && ownerOf(b[ny][nx]) === o) {
                    cells.push([nx, ny]);
                    nx += dx;
                    ny += dy;
                  }

                  if (cells.length >= targetN) {
                    // take exactly targetN contiguous cells (first segment)
                    return cells.slice(0, targetN);
                  }
                }
              }
            }
            return null;
          };

          if (Array.isArray(line) && line.length >= 2) {
            // line might be [[x,y],[x,y],...] or {cells:[[x,y],...]}
            winCells = Array.isArray(line[0]) ? line : null;
          } else if (line?.cells && Array.isArray(line.cells)) {
            winCells = line.cells;
          } else {
            winCells = scan();
          }

          if (!winCells || winCells.length < 2) return null;

          const [x1, y1] = winCells[0];
          const [x2, y2] = winCells[winCells.length - 1];

          // Convert cell coord -> pixel center
          const cx = (x) => padding + x * cellSize + cellSize / 2;
          const cy = (y) => padding + y * cellSize + cellSize / 2;

          const widthPx = padding * 2 + W * cellSize;
          const heightPx = padding * 2 + H * cellSize;

          return React.createElement(
            'svg',
            {
              className: 'winnerLineOverlay',
              width: widthPx,
              height: heightPx,
              style: {
                position: 'absolute',
                left: 0,
                top: 0,
                pointerEvents: 'none',
                zIndex: 5,
              },
            },
            React.createElement('line', {
              x1: cx(x1),
              y1: cy(y1),
              x2: cx(x2),
              y2: cy(y2),
              stroke: 'rgba(255,255,255,0.92)',
              strokeWidth: 6,
              strokeLinecap: 'round',
              filter: 'drop-shadow(0 6px 10px rgba(0,0,0,0.45))',
            })
          );
        } catch (e) {
          // never crash the app because of overlay
          console.error('[WinnerLineOverlay error]', e);
          return null;
        }
      }

      function App() {
        const [socket, setSocket] = React.useState(null);
        const OPTIMISTIC_PLACE = true; // ✅ 想關就改 false
        const optimisticRef = React.useRef(null);

        // ✅ ENTRY｜ROOM｜ROLE｜GAME
        const [view, setView] = React.useState('ENTRY');
        const viewRef = React.useRef('ENTRY');
        React.useEffect(() => {
          viewRef.current = view;
        }, [view]);

        const [room, setRoom] = React.useState(null);
        const [board, setBoard] = React.useState([]);
        const [name, setName] = React.useState('');

        // ✅ 讓 socket callback 永遠拿到最新 name（同名回歸很重要）
        const nameRef = React.useRef('');
        React.useEffect(() => {
          nameRef.current = name;
        }, [name]);

        const [selectedColor, setSelectedColor] = React.useState(null);

        // ✅ DUAL：角色1/角色2
        // ✅ DUAL：角色1/角色2
        const [selectedRole1, setSelectedRole1] = React.useState(null);
        const [selectedRole2, setSelectedRole2] = React.useState(null);
        const [pickingSlot, setPickingSlot] = React.useState(1);
        // ===== ROLE 單卡跟手 =====
        const [roleCursor, setRoleCursor] = React.useState(0);
        const [dragPx, setDragPx] = React.useState(0);
        const [dragging, setDragging] = React.useState(false);
        const dragStartXRef = React.useRef(0);

        /* ✅ NEW：手機選角卡左下角技能說明開關 */
        const [roleSkillOpen, setRoleSkillOpen] = React.useState(false);

        /* ✅ 換卡時自動收起（避免切到下一張還開著） */
        React.useEffect(() => {
          setRoleSkillOpen(false);
        }, [roleCursor]);

        // ✅ NEW：房主幫 AI 選角也走全螢幕 ROLE 介面
        // pickingFor: 'self' | 'ai'
        const [pickingFor, setPickingFor] = React.useState('self');
        const [aiPickingTarget, setAiPickingTarget] = React.useState(null); // AI 的 id 或 name（後端 target 用）
        window.addEventListener('error', (ev) => {
          try {
            console.error('[window.error]', ev?.error || ev?.message || ev);
          } catch (e) {}
        });
        window.addEventListener('unhandledrejection', (ev) => {
          try {
            console.error('[unhandledrejection]', ev?.reason || ev);
          } catch (e) {}
        });

        function getPlayerByTarget(r, target) {
          const list = r?.players || [];
          if (!target) return null;
          return (
            list.find((p) => p?.id === target) ||
            list.find((p) => String(p?.name || '').trim() === String(target).trim()) ||
            null
          );
        }


        const [highlightSources, setHighlightSources] = React.useState([]);
        const [highlightTargets, setHighlightTargets] = React.useState([]);
        const [highlightGudo, setHighlightGudo] = React.useState([]);
        const [highlightGudoTargets, setHighlightGudoTargets] = React.useState([]);
        const [highlightGudoSelf, setHighlightGudoSelf] = React.useState([]);

        const [highlightJeiceTargets, setHighlightJeiceTargets] = React.useState([]);
        const [highlightJeiceSource, setHighlightJeiceSource] = React.useState(null);

        const [ginyuMode, setGinyuMode] = React.useState(false);
        const [gudoMode, setGudoMode] = React.useState(false);
        const [jeiceMode, setJeiceMode] = React.useState(false);
        const [jeiceStep, setJeiceStep] = React.useState('idle'); // idle | place | selectTarget

        // ✅ 回合 UI 資訊
        const [turnMeta, setTurnMeta] = React.useState(null);

        const [copied, setCopied] = React.useState(false);

        // ✅ Jeice FX
        const [fx, setFx] = React.useState(null);
        const fxTimerRef = React.useRef(null);

        // ✅ 結算畫面（15 秒）：凍結終局棋盤 + 閃電標線 + 顯示勝利者角色卡
        // result: { winnerIndex, winnerName, secondsLeft, finalBoard, winLine, winnerSlots, winnerRoleIdxs }
        const [result, setResult] = React.useState(null);
        const resultTimerRef = React.useRef(null);
        const resultRef = React.useRef(null);

        // ✅ 結算期間收到 roomUpdated（因為我們會立刻 restartGame），先暫存，離開結算再套用
        const pendingRoomAfterResultRef = React.useRef(null);

        const roomRef = React.useRef(null);

        // ✅ Jeice auto-start guard
        const jeiceAutoKeyRef = React.useRef(null);

        // ✅ viewport state：給手機棋盤計算格子大小用
        const [vp, setVp] = React.useState(() => {
          const vv = window.visualViewport;
          return {
            w: Math.round(vv?.width || window.innerWidth || 360),
            h: Math.round(vv?.height || window.innerHeight || 640),
          };
        });

        // ✅ Audio
        const audioRef = React.useRef(null);
        const [audioBlocked, setAudioBlocked] = React.useState(false);
        const [audioUnlocked, setAudioUnlocked] = React.useState(false);
        const [bgmMuted, setBgmMuted] = React.useState(false);
        const [sfxMuted, setSfxMuted] = React.useState(false);
        const [audioPanelOpen, setAudioPanelOpen] = React.useState(false);

        // ✅ (4) 技能說明：手機抽屜
        const [helpOpen, setHelpOpen] = React.useState(false);

        // ✅ (6) 我的回合 toast
        const [myTurnToast, setMyTurnToast] = React.useState(null); // { show, color, shape, roleName }
        const toastTimerRef = React.useRef(null);
        const prevMyTurnRef = React.useRef(false);

        React.useEffect(() => {
          resultRef.current = result;
        }, [result]);

        const isCoarse = React.useMemo(() => {
          try {
            return !!window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
          } catch (e) {
            return false;
          }
        }, [vp.w, vp.h]);

        const isGameMobile = isCoarse && view === 'GAME' && vp.w < 920;

        /* ✅ Mobile 對局：鎖住整頁上下滑
          - 只有在 helpOpen 且手指在 .helpDrawer 內時，允許正常滑動
        */
        React.useEffect(() => {
          const shouldLock = isGameMobile && view === 'GAME';

          const html = document.documentElement;
          const body = document.body;

          const prevHtmlOverflow = html.style.overflow;
          const prevBodyOverflow = body.style.overflow;

          function onTouchMove(e) {
            // 允許技能說明抽屜內滑動
            if (helpOpen) {
              const t = e.target;
              const drawer = t && t.closest ? t.closest('.helpDrawer') : null;
              if (drawer) return;
            }
            e.preventDefault();
          }

          if (shouldLock) {
            html.style.overflow = 'hidden';
            body.style.overflow = 'hidden';

            // iOS/Android：阻止整頁被 touchmove 帶著滑
            document.addEventListener('touchmove', onTouchMove, { passive: false });
          }

          return () => {
            document.removeEventListener('touchmove', onTouchMove, { passive: false });
            html.style.overflow = prevHtmlOverflow;
            body.style.overflow = prevBodyOverflow;
          };
        }, [isGameMobile, view, helpOpen]);

        async function ensureUnlocked() {
          const am = audioRef.current;
          if (!am) return false;
          if (am.unlocked) return true;
          const ok = await am.unlock();
          if (ok) {
            setAudioUnlocked(true);
            setAudioBlocked(false);
            // 解鎖後，若 BGM 未靜音，依當前狀態啟動
            if (!bgmMuted) {
              if (resultRef.current) am.startVictory();
              else if (viewRef.current === 'GAME' && roomRef.current?.status === 'PLAYING') am.startBattle();
              else am.startLobby();
            }
            return true;
          }
          setAudioBlocked(true);
          return false;
        }

        async function toggleBgm() {
          const am = audioRef.current;
          if (!am) return;
          const ok = await ensureUnlocked();
          if (!ok) return;
          const next = !bgmMuted;
          setBgmMuted(next);
          am.setBgmMuted(next);
          if (!next) {
            if (resultRef.current) am.startVictory();
            else if (viewRef.current === 'GAME' && roomRef.current?.status === 'PLAYING') am.startBattle();
            else am.startLobby();
          }
        }

        async function toggleSfx() {
          const am = audioRef.current;
          if (!am) return;
          const ok = await ensureUnlocked();
          if (!ok) return;
          const next = !sfxMuted;
          setSfxMuted(next);
          am.setSfxMuted(next);
        }

        function bgmLabel() {
          if (!audioUnlocked) return audioBlocked ? '🎵BGM（點一下解鎖）' : '🎵BGM';
          return bgmMuted ? '🎵BGM：關' : '🎵BGM：開';
        }
        function sfxLabel() {
          if (!audioUnlocked) return audioBlocked ? '🔈SFX（點一下解鎖）' : '🔈SFX';
          return sfxMuted ? '🔈SFX：關' : '🔈SFX：開';
        }

        // ✅ socket 只連一次（避免玩家不存在）
        React.useEffect(() => {
          setupVisualViewportVars();

          // init audio mgr
          audioRef.current = new AudioMgr({
            onNeedGesture: () => setAudioBlocked(true),
            onUnlocked: () => {
              setAudioUnlocked(true);
              setAudioBlocked(false);
            },
          });

          // 先嘗試 lobby（若被阻擋會顯示需要 gesture）
          audioRef.current.startLobby();

          const tryUnlock = async () => {
            const am = audioRef.current;
            if (!am || am.unlocked) return;
            const ok = await am.unlock();
            if (ok) {
              if (bgmMuted) return;
              const r = roomRef.current;
              const v = viewRef.current;
              const pg = resultRef.current;
              if (pg) am.startVictory();
              else if (v === 'GAME' && r?.status === 'PLAYING') am.startBattle();
              else am.startLobby();
            }
          };
          window.addEventListener('pointerdown', tryUnlock, { passive: true });

          const onResize = () => {
            setupVisualViewportVars();
            const vv = window.visualViewport;
            setVp({
              w: Math.round(vv?.width || window.innerWidth || 360),
              h: Math.round(vv?.height || window.innerHeight || 640),
            });
          };

          window.addEventListener('resize', onResize);
          if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', onResize);
            window.visualViewport.addEventListener('scroll', onResize);
          }

          const s = connectSocket();
          setSocket(s);

          // ✅ 由 server 發送的音效 key
          s.on('playSfx', (payload) => {
            try {
              const key = payload?.key;
              if (!key) return;
              audioRef.current?.playSfxKey(key);
            } catch (e) {}
          });

          s.on('roomUpdated', (r) => {
            // 永遠先更新 ref（避免其他 callback 用到舊 room）
            roomRef.current = r;

            // ✅ 結算期間：只暫存，不動 UI（避免狀態半套導致 render 掛掉）
            if (resultRef.current) {
              pendingRoomAfterResultRef.current = r;
              return;
            }

            setRoom(r);

            // 同步自己選到的顏色/角色
            try {
              const me2 = findMePlayer(r, s.id, nameRef.current);
              if (me2) {
                if (typeof me2.colorIndex === 'number') setSelectedColor(me2.colorIndex);
                else setSelectedColor(null);

                if (r?.mode === 'DUAL') {
                  setSelectedRole1(typeof me2.roleIndex1 === 'number' ? me2.roleIndex1 : null);
                  setSelectedRole2(typeof me2.roleIndex2 === 'number' ? me2.roleIndex2 : null);
                } else {
                  setSelectedRole1(typeof me2.roleIndex === 'number' ? me2.roleIndex : null);
                  setSelectedRole2(null);
                }
              }
            } catch (e) {}

            setBoard(r.board || []);

            const curView = viewRef.current;

            // ✅ STARTGAME 之後一定要能進 GAME
            //   就算你剛好還停在 ROLE（例如房主/別人啟動遊戲時你在選角畫面）
            if (r?.status === 'PLAYING') {
              setView('GAME');
            } else if (r?.status === 'LOBBY') {
              if (curView !== 'ROLE') setView('ROOM');
            } else if (r?.status === 'ENDED') {
              setView('GAME');
            }

            updateTurnInfo(r);
          });


          s.on('placed', (payload) => {
            if (!resultRef.current && payload.board) setBoard(payload.board);

            if (roomRef.current) {
              roomRef.current = {
                ...roomRef.current,
                board: payload.board || roomRef.current.board,
                turnIndex: typeof payload.turnIndex === 'number' ? payload.turnIndex : roomRef.current.turnIndex,
                turnSlot: typeof payload.turnSlot === 'number' ? payload.turnSlot : roomRef.current.turnSlot,
                roundCount: typeof payload.roundCount === 'number' ? payload.roundCount : roomRef.current.roundCount,
                status: payload.status || roomRef.current.status,
              };
            }

            setRoom((prev) => {
              const base = prev || roomRef.current;
              if (!base) return base;
              return {
                ...base,
                board: payload.board || base.board,
                turnIndex: typeof payload.turnIndex === 'number' ? payload.turnIndex : base.turnIndex,
                turnSlot: typeof payload.turnSlot === 'number' ? payload.turnSlot : base.turnSlot,
                roundCount: typeof payload.roundCount === 'number' ? payload.roundCount : base.roundCount,
                status: payload.status || base.status,
              };
            });
            // ✅ turnMeta 同步：只存到 room；畫面一律用 updateTurnInfo(r) 組 turnMeta
            //    （避免後端 turnMeta 欄位不齊導致 UI 顯示 undefined）
            if (payload.turnMeta) {
              if (roomRef.current) roomRef.current.turnMeta = payload.turnMeta;
              setRoom((prev) => (prev ? { ...prev, turnMeta: payload.turnMeta } : prev));
            }


            // ✅ Jeice FX（由 server 傳 effect）
            if (payload?.effect?.type === 'jeice') {
              if (fxTimerRef.current) clearTimeout(fxTimerRef.current);
              setFx(payload.effect);
              fxTimerRef.current = setTimeout(() => {
                setFx(null);
                fxTimerRef.current = null;
              }, 900);
            }

            if (payload.win) {
              const r = roomRef.current;

              const winnerIndex =
                typeof payload?.win?.winnerIndex === 'number'
                  ? payload.win.winnerIndex
                  : 0;

              const winner = r?.players?.[winnerIndex];
              const winnerName = winner ? winner.name : (payload?.win?.winnerId || 'Winner');

              const finalBoard = deepCopyBoard(payload.board || board);

              startResult({ winnerIndex, winnerName, finalBoard, roomSnap: r });
            }


            // 清 UI 狀態
            setHighlightSources([]);
            setHighlightTargets([]);
            setHighlightGudo([]);
            setHighlightGudoTargets([]);
            setHighlightGudoSelf([]);
            setGinyuMode(false);
            setGudoMode(false);
            if (roomRef.current) roomRef.current.gudoClientStep = 'idle';

            setHighlightJeiceTargets([]);
            setHighlightJeiceSource(null);
            setJeiceMode(false);
            setJeiceStep('idle');
            optimisticRef.current = null;

            updateTurnInfo(roomRef.current);
          });

          s.on('gudoCancelled', () => {
            setHighlightGudo([]);
            setHighlightGudoTargets([]);
            setHighlightGudoSelf([]);
            setGudoMode(false);
            if (roomRef.current) roomRef.current.gudoClientStep = 'idle';
          });

          s.on('ginyuCancelled', (payload) => {
            setHighlightSources([]);
            setHighlightTargets([]);
            setGinyuMode(false);
            if (payload?.message) alert(payload.message);
          });

          s.on('jeiceCancelled', (payload) => {
            setHighlightJeiceTargets([]);
            setHighlightJeiceSource(null);
            setJeiceMode(false);
            setJeiceStep('idle');
            if (payload?.message) alert(payload.message);
          });

          return () => {
            try {
              s.disconnect();
            } catch (e) {}

            window.removeEventListener('resize', onResize);
            if (window.visualViewport) {
              window.visualViewport.removeEventListener('resize', onResize);
              window.visualViewport.removeEventListener('scroll', onResize);
            }
            window.removeEventListener('pointerdown', tryUnlock);
          };
        }, []);

        // ✅ BGM 自動切換：Lobby / Battle / Victory（只管 BGM）
        React.useEffect(() => {
          const am = audioRef.current;
          if (!am) return;
          if (!am.unlocked || bgmMuted) return;

          if (result) {
            am.startVictory();
            return;
          }

          if (view === 'GAME' && room?.status === 'PLAYING') {
            am.startBattle();
            return;
          }

          if (view === 'ENTRY' || view === 'ROOM' || view === 'ROLE') {
            am.startLobby();
            return;
          }
        }, [view, room?.status, result, bgmMuted]);

        React.useEffect(() => {
          return () => {
            if (resultTimerRef.current) clearInterval(resultTimerRef.current);
            if (fxTimerRef.current) clearTimeout(fxTimerRef.current);
            if (toastTimerRef.current) clearTimeout(toastTimerRef.current);
          };
        }, []);


        function updateTurnInfo(r) {
          if (!r || !r.players || r.status !== 'PLAYING') {
            setTurnMeta(null);
            return;
          }

          const turnPlayer = r.players[r.turnIndex];
          const slot = r.mode === 'DUAL' ? r.turnSlot || 1 : 1;

          let roleIdx = getPlayerRoleIndex(r, turnPlayer, slot);
          const roleName = typeof roleIdx === 'number' ? ROLES[roleIdx]?.name : '未選角';
          const shape = typeof roleIdx === 'number' ? ROLES[roleIdx]?.shape : 'circle';

          const color =
            typeof turnPlayer?.colorIndex === 'number'
              ? COLORS[turnPlayer.colorIndex]
              : 'rgba(255,255,255,0.45)';

          // ✅ 關鍵：placedThisTurn 優先吃後端 turnMeta 的值（若有）
          const pt =
            typeof r?.turnMeta?.placedThisTurn === 'number'
              ? r.turnMeta.placedThisTurn
              : Number(turnPlayer?.placedThisTurn || 0);

          // （可選）如果你後端 turnMeta 也有 roleIndex，且你想以它為準：
          if (typeof r?.turnMeta?.roleIndex === 'number') roleIdx = r.turnMeta.roleIndex;

          setTurnMeta({
            round: r.roundCount || 1,
            playerName: turnPlayer?.name || 'N/A',
            slot,
            roleName,
            shape,
            color,
            roleIndex: typeof roleIdx === 'number' ? roleIdx : null,
            turnPlayerId: turnPlayer?.id || null,
            placedThisTurn: pt,
          });
        }


        function defaultTargetN(roomSnap) {
          // 你後端若有 room.targetN 就吃它，否則預設 5
          const n = Number(roomSnap?.targetN || 5);
          return n >= 3 ? n : 5;
        }
        

        // 掃描某 token 是否有 n 連線，回傳那條線的座標（只取第一條找到的）
        function findLineForToken(board2d, token, n) {
          if (!Array.isArray(board2d) || !board2d.length) return null;
          const H = board2d.length;
          const W = board2d[0]?.length || 0;
          if (!W) return null;

          const dirs = [
            [1, 0],  // →
            [0, 1],  // ↓
            [1, 1],  // ↘
            [-1, 1], // ↙
          ];

          const inb = (x, y) => x >= 0 && y >= 0 && x < W && y < H;

          for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
              if (board2d[y][x] !== token) continue;

              for (const [dx, dy] of dirs) {
                // 確保是「線段起點」（前一格不是同 token）
                const px = x - dx, py = y - dy;
                if (inb(px, py) && board2d[py][px] === token) continue;

                // 往前數連線
                let k = 0;
                const pts = [];
                while (inb(x + dx * k, y + dy * k) && board2d[y + dy * k][x + dx * k] === token) {
                  pts.push({ x: x + dx * k, y: y + dy * k });
                  k++;
                  if (pts.length >= n) return pts.slice(0, n);
                }
              }
            }
          }
          return null;
        }

        // winnerIndex 可能是 DUAL 任一槽勝利，所以掃兩個槽，找得到哪條線就用哪個槽
        function computeWinnerLineAndRoles(roomSnap, winnerIndex, finalBoard) {
          const winner = roomSnap?.players?.[winnerIndex];
          if (!winner) {
            return { winLine: null, winnerSlots: [], winnerRoleIdxs: [] };
          }

          const mode = roomSnap?.mode || 'SINGLE';
          const baseN = defaultTargetN(roomSnap);

          // 取得 winner 的角色卡（需求：DUAL 顯示兩張）
          const roleIdxs =
            mode === 'DUAL'
              ? [
                  typeof winner.roleIndex1 === 'number' ? winner.roleIndex1 : null,
                  typeof winner.roleIndex2 === 'number' ? winner.roleIndex2 : null,
                ].filter((v) => typeof v === 'number')
              : [typeof winner.roleIndex === 'number' ? winner.roleIndex : null].filter((v) => typeof v === 'number');

          if (mode !== 'DUAL') {
            // SINGLE：token = ownerIndex*2 + 1
            const token = winnerIndex * 2 + 1;
            const roleIdx = typeof winner.roleIndex === 'number' ? winner.roleIndex : null;
            const needN = roleIdx === 1 ? 6 : baseN; // 巴特=6
            const winLine = findLineForToken(finalBoard, token, needN);
            return { winLine, winnerSlots: [1], winnerRoleIdxs: roleIdxs };
          }

          // DUAL：掃 slot=1/2，誰先找到線就用誰（同一玩家同一角色勝利）
          for (let slot = 1; slot <= 2; slot++) {
            const token = winnerIndex * 2 + slot;
            const roleIdx = slot === 1 ? winner.roleIndex1 : winner.roleIndex2;
            const needN = roleIdx === 1 ? 6 : baseN;
            const winLine = findLineForToken(finalBoard, token, needN);
            if (winLine) return { winLine, winnerSlots: [slot], winnerRoleIdxs: roleIdxs };
          }

          return { winLine: null, winnerSlots: [], winnerRoleIdxs: roleIdxs };
        }
        function onRoleSwipeDown(ev) {
          // 只處理主要指標（避免多指亂跳）
          if (ev.pointerType === 'mouse' && ev.button !== 0) return;
          setDragging(true);
          dragStartXRef.current = ev.clientX;
          setDragPx(0);
          try { ev.currentTarget.setPointerCapture(ev.pointerId); } catch (e) {}
        }

        function onRoleSwipeMove(ev) {
          if (!dragging) return;
          const dx = ev.clientX - dragStartXRef.current;
          // 限制一下最大拖曳量，避免飛太遠
          setDragPx(clamp(dx, -220, 220));
        }

        function onRoleSwipeEnd() {
          if (!dragging) return;

          const dx = dragPx;
          setDragging(false);

          // 滑動切換門檻
          const TH = 70;

          if (dx > TH) {
            // 往右滑：上一張
            setRoleCursor((i) => (i - 1 + ROLES.length) % ROLES.length);
          } else if (dx < -TH) {
            // 往左滑：下一張
            setRoleCursor((i) => (i + 1) % ROLES.length);
          }

          // 放手回彈
          setDragPx(0);
        }

        function startResult({ winnerIndex, winnerName, finalBoard, roomSnap }) {
          // 清 timer
          if (resultTimerRef.current) clearInterval(resultTimerRef.current);
          pendingRoomAfterResultRef.current = null;

          const { winLine, winnerSlots, winnerRoleIdxs } = computeWinnerLineAndRoles(roomSnap, winnerIndex, finalBoard);

          // ✅ 立刻清殘局：把 restartGame 提前到「進結算那刻」就送出
          //    這樣就不會發生「上一局 timer 到點才 restartGame，卻把下一局清掉」
          const rid = roomSnap?.id;
          if (socket && rid) {
            try {
              socket.emit('restartGame', { roomId: rid });
            } catch (e) {}
          }

          // 顯示結算畫面（15秒）
          setResult({
            winnerIndex,
            winnerName,
            secondsLeft: 15,
            finalBoard,
            winLine: winLine || [],
            winnerSlots,
            winnerRoleIdxs,
          });

          if (!bgmMuted && audioRef.current?.unlocked) audioRef.current?.startVictory();

          let left = 15;
          resultTimerRef.current = setInterval(() => {
            left -= 1;
            setResult((rg) => (rg ? { ...rg, secondsLeft: left } : rg));
            if (left <= 0) {
              clearInterval(resultTimerRef.current);
              resultTimerRef.current = null;
              exitResult();
            }
          }, 1000);
        }

        // ✅ 離開結算：不再送 restartGame（已經在 startResult 送過）
        function exitResult() {
          audioRef.current?.uiClick();
          audioRef.current?.stopVictory();
          if (!bgmMuted && audioRef.current?.unlocked) audioRef.current?.startLobby();

          if (resultTimerRef.current) {
            clearInterval(resultTimerRef.current);
            resultTimerRef.current = null;
          }

          setResult(null);

          // ✅ 套用結算期間暫存的新 room（restartGame 後的新 lobby 狀態）
          const pending = pendingRoomAfterResultRef.current;
          if (pending) {
            roomRef.current = pending;
            setRoom(pending);
            setBoard(pending.board || []);
            updateTurnInfo(pending);
            pendingRoomAfterResultRef.current = null;
          }

          setView('ROOM');
        }


        function onCopyRoomId() {
          audioRef.current?.uiClick();
          if (!room?.id) return;
          copyText(String(room.id)).then((ok) => {
            if (!ok) return;
            setCopied(true);
            setTimeout(() => setCopied(false), 1200);
          });
        }

        function createRoom(mode) {
          audioRef.current?.uiClick();
          socket.emit('createRoom', { maxPlayers: 4, name: name.trim(), mode }, (res) => {
            if (res.ok) {
              setRoom(res.room);
              setView('ROOM');
            } else {
              alert(res.message || '建立失敗');
            }
          });
        }

        function joinRoom() {
          audioRef.current?.uiClick();
          const id = prompt('輸入房間ID');
          if (!id) return;
          socket.emit('joinRoom', { roomId: id, name: name.trim() }, (res) => {
            if (res.ok) {
              setRoom(res.room);
              setView('ROOM');
            } else alert(res.message || '加入失敗');
          });
        }

        function leaveRoom() {
          audioRef.current?.uiClick();
          audioRef.current?.stopVictory();

          const rid = roomRef.current?.id || room?.id;
          if (!rid) {
            setRoom(null);
            setBoard([]);
            setView('ENTRY');
            if (!bgmMuted && audioRef.current?.unlocked) audioRef.current?.startLobby();
            return;
          }
          socket.emit('leaveRoom', { roomId: rid }, (res) => {
            if (!res?.ok) {
              alert(res?.message || '退出房間失敗');
              return;
            }
            setRoom(null);
            setBoard([]);
            setSelectedColor(null);
            setSelectedRole1(null);
            setSelectedRole2(null);
            setHelpOpen(false);
            setAudioPanelOpen(false);
            setView('ENTRY');
            if (!bgmMuted && audioRef.current?.unlocked) audioRef.current?.startLobby();
          });
        }

        function pickColor(i) {
          audioRef.current?.uiClick();
          if (!room) return;
          setSelectedColor(i);
          socket.emit('pickColor', { roomId: room.id, colorIndex: i }, (res) => {
            if (res.ok) setRoom(res.room);
          });
        }

        function openRoleSelect(slot) {
          audioRef.current?.uiClick();
          if (!room) return;

          // ✅ 自己選角
          setPickingFor('self');
          setAiPickingTarget(null);

          try {
            if (document.activeElement && document.activeElement.blur) {
              document.activeElement.blur();
            }
          } catch (e) {}
          setupVisualViewportVars();
          setTimeout(() => setupVisualViewportVars(), 0);

          const s = slot === 2 ? 2 : 1;
          setPickingSlot(s);
          setView('ROLE');
        }

        // ✅ NEW：房主幫 AI 選角（同樣跳到全螢幕 ROLE）
        function openAiRoleSelect(targetIdOrName, slot) {
          audioRef.current?.uiClick();
          if (!room) return;

          setPickingFor('ai');
          setAiPickingTarget(targetIdOrName);

          try {
            if (document.activeElement && document.activeElement.blur) {
              document.activeElement.blur();
            }
          } catch (e) {}
          setupVisualViewportVars();
          setTimeout(() => setupVisualViewportVars(), 0);

          const s = slot === 2 ? 2 : 1;
          setPickingSlot(s);
          setView('ROLE');
        }
        // ✅ 只在「同一個玩家」內做 DUAL 兩角色不能重複
        function getPickingPlayer(r0) {
          if (!r0) return null;
          if (pickingFor === 'ai') {
            return getPlayerByTarget(r0, aiPickingTarget);
          }
          // self：用目前 me（同名回歸也 OK）
          return findMePlayer(r0, socket?.id, nameRef.current);
        }

        // ✅ 回傳：目前正在挑的 slot 的「另一槽」角色（只檢查同一玩家）
        function getOtherRoleIndexForSamePlayer(r0) {
          if (!r0 || r0.mode !== 'DUAL') return null;

          if (pickingFor === 'ai') {
            const p = getPickingPlayer(r0);
            if (!p) return null;
            return pickingSlot === 1 ? p.roleIndex2 : p.roleIndex1;
          }

          // self：用前端 state（最即時）
          return pickingSlot === 1 ? selectedRole2 : selectedRole1;
        }

        // ✅ ROLE UI 用：這個角色是否要被禁用（只禁同玩家另一槽）
        function isRoleDisabledForCurrentPicker(roleIdx) {
          const r0 = roomRef.current || room;
          if (!r0 || r0.mode !== 'DUAL') return false; // SINGLE：不禁用（跨玩家可重複）
          const other = getOtherRoleIndexForSamePlayer(r0);
          return typeof other === 'number' && other === roleIdx;
        }


        function confirmRole(roleIndex) {
          audioRef.current?.uiClick();
          if (!room) return;

          // =========================================================
          // ✅ (A) 房主幫 AI 選角：走 setAiRole（後端事件由 emitTry 嘗試）
          // =========================================================
          if (pickingFor === 'ai') {
            const target = aiPickingTarget;
            const r0 = roomRef.current || room;
            const p = getPlayerByTarget(r0, target);

            if (!target || !p) {
              alert('AI 玩家不存在（可能剛被移除或房間刷新）');
              setPickingFor('self');
              setAiPickingTarget(null);
              setView('ROOM');
              return;
            }

            // DUAL：同一 AI 的 角色1/角色2 不可重複
            if (room?.mode === 'DUAL') {
              const other = pickingSlot === 1 ? p.roleIndex2 : p.roleIndex1;
              if (other === roleIndex) {
                alert('同一 AI 的 角色1 / 角色2 不能重複');
                return;
              }
            }

            // ✅ 直接請後端設定 AI 角色
            setAiRole(target, roleIndex, pickingSlot);

            // 收尾
            setPickingFor('self');
            setAiPickingTarget(null);
            setView('ROOM');
            return;
          }

          // =========================================================
          // ✅ (B) 自己選角：維持原本 pickRole
          // =========================================================
          if (room?.mode === 'DUAL') {
            const other = pickingSlot === 1 ? selectedRole2 : selectedRole1;
            if (other === roleIndex) {
              alert('同一玩家的 角色1 / 角色2 不能重複');
              return;
            }
          }

          if (room?.mode === 'DUAL') {
            if (pickingSlot === 1) setSelectedRole1(roleIndex);
            else setSelectedRole2(roleIndex);
          } else {
            setSelectedRole1(roleIndex);
            setSelectedRole2(null);
          }

          socket.emit(
            'pickRole',
            room?.mode === 'DUAL'
              ? { roomId: room.id, roleIndex, slot: pickingSlot }
              : { roomId: room.id, roleIndex },
            (res) => {
              if (res.ok) setRoom(res.room);
              else if (res?.message) alert(res.message);
            }
          );

          setView('ROOM');
        }


        function readyUp() {
          audioRef.current?.uiClick();
          if (selectedColor === null) return alert('請先選擇顏色');

          if (room?.mode === 'DUAL') {
            if (selectedRole1 === null || selectedRole2 === null)
              return alert('DUAL 模式請先選擇 角色1 與 角色2');
          } else {
            if (selectedRole1 === null) return alert('請先選擇角色');
          }

          socket.emit('readyUp', { roomId: room.id }, (res) => {
            if (!res.ok && res.message) alert(res.message);
          });
        }

        function startGame() {
          audioRef.current?.uiClick();
          socket.emit('startGame', { roomId: room.id });
        }

        /* =========================================================
          ✅ AI helpers (front-end)
          - 會嘗試多個事件名稱，後端只要接其中一個即可
          ========================================================= */
        function isAiPlayer(p) {
          if (!p) return false;
          if (p.isAI || p.isAi || p.ai || p.bot) return true;
          const n = String(p.name || '').trim().toLowerCase();
          return n.startsWith('ai') || n.startsWith('bot') || n.includes('[ai]') || n.includes('(ai)');
        }

        // 依序嘗試多個事件名稱（避免你後端事件名還沒定案）
        function emitTry(eventNames, payload, cb, timeoutMs = 700) {
          if (!socket) return cb?.({ ok: false, message: 'socket not ready' });
          const names = Array.isArray(eventNames) ? eventNames.filter(Boolean) : [eventNames];
          let i = 0;
          let done = false;

          const tryOne = () => {
            if (done) return;
            if (i >= names.length) {
              done = true;
              cb?.({ ok: false, message: 'no handler matched (front-end tried events: ' + names.join(', ') + ')' });
              return;
            }
            const ev = names[i++];
            let timer = null;

            try {
              socket.emit(ev, payload, (res) => {
                if (done) return;
                done = true;
                if (timer) clearTimeout(timer);
                cb?.(res);
              });
            } catch (e) {
              // 直接換下一個
            }

            timer = setTimeout(() => {
              if (done) return;
              tryOne();
            }, timeoutMs);
          };

          tryOne();
        }

        function randInt(n) {
          return Math.floor(Math.random() * Math.max(1, n));
        }

        function pickRandomColorIndex() {
          return randInt(COLORS.length);
        }
        // ✅ 取得「同一玩家」另一槽角色：優先用 state，state 沒值就用 roomRef(後端同步) 補
        function getMyOtherRoleForSlot(slot) {
          const r0 = roomRef.current || room;
          if (!r0 || r0.mode !== 'DUAL') return null;

          const s = slot === 2 ? 2 : 1;

          // 1) 先吃前端 state（最快）
          const otherState = s === 1 ? selectedRole2 : selectedRole1;
          if (typeof otherState === 'number') return otherState;

          // 2) state 還沒更新 → 吃 roomRef 的 me（後端同步）
          const me0 = findMePlayer(r0, socket?.id, nameRef.current);
          if (!me0) return null;

          const otherRoom = s === 1 ? me0.roleIndex2 : me0.roleIndex1;
          return typeof otherRoom === 'number' ? otherRoom : null;
        }

        function pickRandomRoleIndex(excludeSet) {
          const ban = excludeSet ? new Set(excludeSet) : new Set();
          const pool = [];
          for (let i = 0; i < ROLES.length; i++) {
            if (!ban.has(i)) pool.push(i);
          }
          if (!pool.length) return 0;
          return pool[randInt(pool.length)];
        }


        /* ✅ 自己(玩家)一鍵隨機選角：SINGLE 1顆 / DUAL 兩角不重複 */
        function setMyRoleDirect(roleIndex, slot) {
          audioRef.current?.uiClick();
          if (!room) return;

          if (room?.mode === 'DUAL') {
            const s = slot === 2 ? 2 : 1;

            // ✅ 這裡不要只看 state：用「state + roomRef」取最可靠的另一槽角色
            const other = getMyOtherRoleForSlot(s);

            // ✅ 保底：如果撞到另一槽 → 重新抽（排除 other）
            if (typeof other === 'number' && other === roleIndex) {
              roleIndex = pickRandomRoleIndex([other]);
              // 極端保護（理論上不會發生，除非 ROLES 只有 1 個）
              if (roleIndex === other && ROLES.length > 1) roleIndex = (other + 1) % ROLES.length;
            }

            if (s === 1) setSelectedRole1(roleIndex);
            else setSelectedRole2(roleIndex);

            socket.emit('pickRole', { roomId: room.id, roleIndex, slot: s }, (res) => {
              if (res.ok) setRoom(res.room);
              else if (res?.message) alert(res.message);
            });
          } else {
            setSelectedRole1(roleIndex);
            setSelectedRole2(null);

            socket.emit('pickRole', { roomId: room.id, roleIndex }, (res) => {
              if (res.ok) setRoom(res.room);
              else if (res?.message) alert(res.message);
            });
          }
        }


        function randomPickMyRole(slot) {
          if (!room) return;
          const s = slot === 2 ? 2 : 1;

          const exclude = [];
          if (room?.mode === 'DUAL') {
            const other = getMyOtherRoleForSlot(s);
            if (typeof other === 'number') exclude.push(other);
          }

          const r = pickRandomRoleIndex(exclude);
          setMyRoleDirect(r, s);
        }


        /* ✅ AI 角色下拉 onChange */
        function onSelectAiRole(target, slot, ev) {
          const v = ev?.target?.value;
          if (v === '' || v === null || v === undefined) return;
          const idx = Number(v);
          if (Number.isNaN(idx)) return;
          setAiRole(target, idx, slot);
        }


        // ✅ 新增 AI（房主）
        function addAiPlayer() {
          audioRef.current?.uiClick();
          const rid = roomRef.current?.id || room?.id;
          if (!rid) return;

          emitTry(
            ['addAi', 'addAI', 'addAIPlayer', 'addBot', 'addRobot'],
            { roomId: rid },
            (res) => {
              if (res?.ok && res.room) {
                roomRef.current = res.room;
                setRoom(res.room);
              } else {
                alert(res?.message || '新增 AI 失敗（後端尚未接 addAi 事件？）');
              }
            }
          );
        }

        // ✅ 設定 AI 顏色（房主）
        function setAiColor(targetIdOrName, colorIndex) {
          audioRef.current?.uiClick();
          const rid = roomRef.current?.id || room?.id;
          if (!rid) return;

          emitTry(
            ['setAiColor', 'setAIColor', 'aiPickColor', 'pickColorFor', 'pickColorByHost'],
            { roomId: rid, target: targetIdOrName, colorIndex },
            (res) => {
              if (res?.ok && res.room) {
                roomRef.current = res.room;
                setRoom(res.room);
              } else if (res?.message) {
                alert(res.message);
              }
            }
          );
        }

        // ✅ 設定 AI 角色（房主）
        // - SINGLE: roleIndex
        // - DUAL: roleIndex + slot
        function setAiRole(targetIdOrName, roleIndex, slot) {
          audioRef.current?.uiClick();
          const rid = roomRef.current?.id || room?.id;
          if (!rid) return;

          // ✅ 先在前端擋掉 DUAL「角色1/角色2 重複」：不送出、也不提醒
          const r0 = roomRef.current || room;
          if (r0?.mode === 'DUAL') {
            const pl = (r0?.players || []).find(
              (p) => p?.id === targetIdOrName || p?.name === targetIdOrName
            );

            // 兼容不同欄位命名：roleIndex / roleIndex2 或 roles[0]/roles[1]
            const cur1 =
              typeof pl?.roleIndex === 'number'
                ? pl.roleIndex
                : Array.isArray(pl?.roles)
                  ? pl.roles[0]
                  : undefined;

            const cur2 =
              typeof pl?.roleIndex2 === 'number'
                ? pl.roleIndex2
                : Array.isArray(pl?.roles)
                  ? pl.roles[1]
                  : undefined;

            if (slot === 1 && roleIndex === cur2) return;
            if (slot === 2 && roleIndex === cur1) return;
          }

          const payload =
            r0?.mode === 'DUAL'
              ? { roomId: rid, target: targetIdOrName, roleIndex, slot }
              : { roomId: rid, target: targetIdOrName, roleIndex };

          emitTry(
            ['setAiRole', 'setAIRole', 'aiPickRole', 'pickRoleFor', 'pickRoleByHost'],
            payload,
            (res) => {
              if (res?.ok && res.room) {
                roomRef.current = res.room;
                setRoom(res.room);
              } else if (res?.message) {
                // ✅ 後端若回「不能重複」：直接忽略，不跳提醒
                const msg = String(res.message || '');
                if (
                  (r0?.mode === 'DUAL') &&
                  (msg.includes('不能重複') ||
                  msg.includes('角色') && msg.includes('重複') ||
                  msg.toLowerCase().includes('duplicate') ||
                  msg.toLowerCase().includes('same'))
                ) {
                  return;
                }
                alert(res.message);
              }
            }
          );
        }


        // ✅ AI 一鍵隨機（顏色 + 角色；DUAL 會確保 1/2 不重複）
        function randomizeAiAll(p) {
          const target = p?.id || p?.name;
          if (!target) return;

          // color
          setAiColor(target, pickRandomColorIndex());

          // role
          if (room?.mode === 'DUAL') {
            const r1 = pickRandomRoleIndex([]);
            const r2 = pickRandomRoleIndex([r1]);
            setAiRole(target, r1, 1);
            setAiRole(target, r2, 2);
          } else {
            const r = pickRandomRoleIndex([]);
            setAiRole(target, r, 1);
          }
        }

        function cancelGinyu() {
          audioRef.current?.uiClick();
          try {
            socket?.emit('ginyuCancel', { roomId: room?.id }, () => {});
          } catch (e) {}
          setHighlightSources([]);
          setHighlightTargets([]);
          setGinyuMode(false);
        }

        function cancelJeice() {
          audioRef.current?.uiClick();
          try {
            socket?.emit('jeiceCancel', { roomId: room?.id }, () => {});
          } catch (e) {}
          setHighlightJeiceTargets([]);
          setHighlightJeiceSource(null);
          setJeiceMode(false);
          setJeiceStep('idle');
        }

        function undoMove() {
          audioRef.current?.uiClick();
          audioRef.current?.playSfxKey('undo');
          const rid = room?.id;
          if (!rid) return;

          socket.emit('undoMove', { roomId: rid }, (res) => {
            if (!res?.ok) {
              if (res?.message) alert(res.message);
              return;
            }

            // postGame 期間不處理
            if (resultRef.current) return;

            // ✅ 1) 後端若回 room：以 room 為準（同步 turn/players/placedThisTurn/turnMeta）
            if (res.room) {
              try { roomRef.current = res.room; } catch (e) {}
              setRoom(res.room);
              setBoard(res.room.board || []);
              updateTurnInfo(res.room);
            }
            // ✅ 2) 後端若只回 board：至少更新 board；其餘欄位能接就接
            else if (res.board) {
              setBoard(res.board);

              // setRoom（React state）
              setRoom((prev) => {
                if (!prev) return prev;
                const next = { ...prev, board: res.board };

                if (typeof res.turnIndex === 'number') next.turnIndex = res.turnIndex;
                if (typeof res.turnSlot === 'number') next.turnSlot = res.turnSlot;
                if (typeof res.roundCount === 'number') next.roundCount = res.roundCount;
                if (res.status) next.status = res.status;
                if (res.turnMeta) next.turnMeta = res.turnMeta;

                return next;
              });

              // roomRef（避免 UI/判斷用到舊值）
              if (roomRef.current) {
                roomRef.current = {
                  ...roomRef.current,
                  board: res.board,
                  turnIndex: typeof res.turnIndex === 'number' ? res.turnIndex : roomRef.current.turnIndex,
                  turnSlot: typeof res.turnSlot === 'number' ? res.turnSlot : roomRef.current.turnSlot,
                  roundCount: typeof res.roundCount === 'number' ? res.roundCount : roomRef.current.roundCount,
                  status: res.status || roomRef.current.status,
                  turnMeta: res.turnMeta || roomRef.current.turnMeta,
                };
                updateTurnInfo(roomRef.current);
              }
            } else {
              // 什麼都沒回就至少刷新一次 turn info
              updateTurnInfo(roomRef.current || room);
            }

            // 清掉技能狀態
            setHighlightSources([]);
            setHighlightTargets([]);
            setHighlightGudo([]);
            setHighlightGudoTargets([]);
            setHighlightGudoSelf([]);
            setGinyuMode(false);
            setGudoMode(false);
            if (roomRef.current) roomRef.current.gudoClientStep = 'idle';

            setHighlightJeiceTargets([]);
            setHighlightJeiceSource(null);
            setJeiceMode(false);
            setJeiceStep('idle');

            // ✅ 最後保險再刷新一次（避免 UI 殘留）
            updateTurnInfo(roomRef.current || room);
          });
        }


        // ✅ 吉斯：每回合預設自動啟動（保持你原本）
        React.useEffect(() => {
          if (!socket || !room || room.status !== 'PLAYING') return;
          const me = findMePlayer(room, socket?.id, name);
          const isMyTurn = room && me && room.turnIndex !== undefined && isMyTurnByIdOrName(room, me);

          if (!isMyTurn || !me) return;

          const slot = room.mode === 'DUAL' ? room.turnSlot || 1 : 1;
          const myRoleIndex = getPlayerRoleIndex(room, me, slot);
          if (myRoleIndex !== 5) return;

          if (me.usedJeiceThisTurn) {
            setHighlightJeiceTargets([]);
            setHighlightJeiceSource(null);
            setJeiceMode(false);
            setJeiceStep('idle');
            return;
          }

          const turnKey = `${room.id}:${room.roundCount || 1}:${room.turnIndex}:${room.turnSlot || 1}`;
          if (jeiceAutoKeyRef.current === turnKey) return;
          jeiceAutoKeyRef.current = turnKey;

          socket.emit('jeiceAbilityStart', { roomId: room.id }, (res) => {
            if (res?.ok) {
              setJeiceMode(true);
              setJeiceStep('place');
              setHighlightJeiceTargets([]);
              setHighlightJeiceSource(null);
            } else {
              jeiceAutoKeyRef.current = null;
            }
          });
        }, [socket, room?.id, room?.status, room?.turnIndex, room?.turnSlot, room?.roundCount]);

        function place(x, y) {
          if (!room || room.status !== 'PLAYING') return;

          // ===== Jeice =====
          if (jeiceMode) {
            if (jeiceStep === 'place') {
              socket.emit('jeicePlace', { roomId: room.id, x, y }, (res) => {
                if (res?.ok) {
                  setHighlightJeiceSource({ x, y });

                  // optimistic render
                  try {
                    const r0 = roomRef.current || room;
                    const myIdx = (r0?.players || []).findIndex((p) => p.id === socket.id);
                    if (myIdx >= 0) {
                      const slot = r0?.mode === 'DUAL' ? r0.turnSlot || 1 : 1;
                      const token = myIdx * 2 + slot;
                      const b2 = deepCopyBoard(r0?.board || board);
                      if (b2?.[y]?.[x] === 0) b2[y][x] = token;
                      if (roomRef.current) roomRef.current.board = b2;
                      setBoard(b2);
                      setRoom((prev) => (prev ? { ...prev, board: b2 } : prev));
                    }
                  } catch (e) {}

                  const targets = Array.isArray(res.targets) ? res.targets : [];
                  if (targets.length) {
                    setHighlightJeiceTargets(targets);
                    setJeiceStep('selectTarget');
                  } else {
                    setHighlightJeiceTargets([]);
                    setHighlightJeiceSource(null);
                    setJeiceMode(false);
                    setJeiceStep('idle');
                  }
                } else {
                  if (res?.message) alert(res.message);
                  const msg = String(res?.message || '');
                  if (msg.includes('房間不存在') || msg.includes('遊戲未開始') || msg.includes('尚未輪到你')) {
                    cancelJeice();
                  }
                }
              });
              return;
            }

            if (jeiceStep === 'selectTarget') {
              const inTargets = highlightJeiceTargets.some((p) => p.x === x && p.y === y);

              if (!inTargets) {
                cancelJeice();
                return;
              }

              socket.emit('jeiceSelectTarget', { roomId: room.id, x, y }, (res) => {
                if (!res?.ok && res?.message) alert(res.message);
                setHighlightJeiceTargets([]);
                setHighlightJeiceSource(null);
                setJeiceMode(false);
                setJeiceStep('idle');
              });
              return;
            }
          }

          // ===== 基紐 =====
          if (ginyuMode) {
            const inSources = highlightSources.some((p) => p.x === x && p.y === y);
            const inTargets = highlightTargets.some((p) => p.x === x && p.y === y);

            if (highlightSources.length && !highlightTargets.length) {
              if (!inSources) {
                cancelGinyu();
                return;
              }
              socket.emit('ginyuSelectSource', { roomId: room.id, x, y }, (res) => {
                if (res.ok) setHighlightTargets(res.targets);
                else {
                  if (!String(res.message || '').includes('取消')) alert(res.message);
                  cancelGinyu();
                }
              });
              return;
            }

            if (highlightTargets.length) {
              if (!inTargets) {
                cancelGinyu();
                return;
              }
              socket.emit('ginyuSelectTarget', { roomId: room.id, x, y }, (res) => {
                if (!res.ok) {
                  if (!String(res.message || '').includes('取消')) alert(res.message);
                  cancelGinyu();
                }
              });
              return;
            }

            cancelGinyu();
            return;
          }

          // ===== 古杜 =====
          if (gudoMode) {
            const localRoom = roomRef.current || room;

            if (!localRoom.gudoClientStep || localRoom.gudoClientStep === 'idle') {
              socket.emit('gudoSelectSource', { roomId: localRoom.id, x, y }, (res) => {
                if (res.ok) {
                  setHighlightGudo(res.highlights || []);
                  localRoom.gudoClientStep = 'selectTarget';
                } else {
                  alert(res.message);
                  setGudoMode(false);
                  setHighlightGudo([]);
                  setHighlightGudoTargets([]);
                  setHighlightGudoSelf([]);
                  localRoom.gudoClientStep = 'idle';
                }
              });
              return;
            }

            if (localRoom.gudoClientStep === 'selectTarget') {
              socket.emit('gudoSelectTarget', { roomId: localRoom.id, x, y }, (res) => {
                if (res.ok) {
                  setHighlightGudo([]);
                  setHighlightGudoTargets(res.emptyAround || []);
                  localRoom.gudoClientStep = 'selectMove';
                } else {
                  alert(res.message);
                  setGudoMode(false);
                  setHighlightGudo([]);
                  setHighlightGudoTargets([]);
                  setHighlightGudoSelf([]);
                  localRoom.gudoClientStep = 'idle';
                }
              });
              return;
            }

            if (localRoom.gudoClientStep === 'selectMove') {
              socket.emit('gudoMovePiece', { roomId: localRoom.id, x, y }, (res) => {
                if (!res.ok) alert(res.message);
              });
              return;
            }
          }

          // ===== 一般落子 =====
          let optimisticKey = null;

          if (OPTIMISTIC_PLACE) {
            try {
              const r0 = roomRef.current || room;
              if (r0 && r0.status === 'PLAYING') {
                const me0 = findMePlayer(r0, socket?.id, nameRef.current);
                if (me0 && isMyTurnByIdOrName(r0, me0)) {
                  const slot = r0.mode === 'DUAL' ? (r0.turnSlot || 1) : 1;

                  const myIdx = (r0.players || []).findIndex(
                    (p) => p.id === socket.id || (me0?.name && p.name === me0.name)
                  );

                  const b0 = deepCopyBoard(r0.board || board);
                  if (myIdx >= 0 && b0?.[y]?.[x] === 0) {
                    const token = myIdx * 2 + slot;
                    const b2 = deepCopyBoard(b0);
                    b2[y][x] = token;

                    optimisticKey = `${r0.id}:${r0.roundCount || 1}:${r0.turnIndex}:${r0.turnSlot || 1}:${x},${y}`;
                    optimisticRef.current = { key: optimisticKey, prevBoard: b0 };

                    // 更新 UI
                    if (roomRef.current) roomRef.current = { ...r0, board: b2 };
                    setBoard(b2);
                    setRoom((prev) => (prev ? { ...prev, board: b2 } : prev));
                  }
                }
              }
            } catch (e) {}
          }

          socket.emit('place', { roomId: room.id, x, y }, (res) => {
            if (!res?.ok) {
              // ❗後端拒絕：若剛剛有 optimistic，就回滾
              try {
                const st = optimisticRef.current;
                if (st && st.key === optimisticKey && st.prevBoard) {
                  if (roomRef.current) roomRef.current = { ...(roomRef.current || room), board: st.prevBoard };
                  setBoard(st.prevBoard);
                  setRoom((prev) => (prev ? { ...prev, board: st.prevBoard } : prev));
                }
              } catch (e) {}

              if (res?.message) alert(res.message);
            }
          });

        }

        function activateGinyu() {
          audioRef.current?.uiClick();
          socket.emit('ginyuAbilityStart', { roomId: room.id }, (res) => {
            if (res.ok) {
              setGinyuMode(true);
              setHighlightSources(res.sources);
            } else alert(res.message);
          });
        }

        function activateGudo() {
          audioRef.current?.uiClick();
          socket.emit('gudoAbilityStart', { roomId: room.id }, (res) => {
            if (res.ok) {
              setGudoMode(true);
              setHighlightGudo([]);
              setHighlightGudoTargets([]);
              setHighlightGudoSelf(res.sources || []);
              if (roomRef.current) roomRef.current.gudoClientStep = 'idle';
            } else alert(res.message);
          });
        }

        function activateJeice() {
          audioRef.current?.uiClick();
          socket.emit('jeiceAbilityStart', { roomId: room.id }, (res) => {
            if (res?.ok) {
              setJeiceMode(true);
              setJeiceStep('place');
              setHighlightJeiceTargets([]);
              setHighlightJeiceSource(null);
            } else {
              alert(res?.message || '無法發動吉斯能力');
            }
          });
        }

        const me = findMePlayer(room, socket?.id, name);
        const isMyTurn = !!(room && me && room.turnIndex !== undefined && isMyTurnByIdOrName(room, me));


        const activeSlot = room?.mode === 'DUAL' ? room.turnSlot || 1 : 1;
        const myActiveRoleIndex = isMyTurn ? getPlayerRoleIndex(room, me, activeSlot) : null;

        // ✅ (6) 輪到你了 toast（狀態切換時彈一次）
        React.useEffect(() => {
          const nowMyTurn = !!(room && me && room.status === 'PLAYING' && isMyTurn);
          const prev = prevMyTurnRef.current;
          prevMyTurnRef.current = nowMyTurn;

          if (!nowMyTurn || prev) return;

          // 取本回合形狀顏色
          const slot = room.mode === 'DUAL' ? room.turnSlot || 1 : 1;
          const roleIdx = getPlayerRoleIndex(room, me, slot);
          const shape = typeof roleIdx === 'number' ? ROLES[roleIdx]?.shape : 'circle';
          const roleName = typeof roleIdx === 'number' ? ROLES[roleIdx]?.name : '未選角';
          const color = typeof me?.colorIndex === 'number' ? COLORS[me.colorIndex] : '#fff';

          setMyTurnToast({ show: true, shape, color, roleName });

          if (toastTimerRef.current) clearTimeout(toastTimerRef.current);
          toastTimerRef.current = setTimeout(() => {
            setMyTurnToast((t) => (t ? { ...t, show: false } : t));
          }, 1200);
        }, [room?.turnIndex, room?.turnSlot, room?.status, socket?.id]);

        const canStart =
          room &&
          room.hostId === socket?.id &&
          room.players &&
          room.players.length > 0 &&
          room.players.every((p) => p.ready);

        const boardToRender = result?.finalBoard ? result.finalBoard : board;
        const size = boardToRender?.length || 15;


        // ✅ 手機：依可用高度計算 cellSize
        const cellSize = React.useMemo(() => {
          if (!isGameMobile) return 28;
          const dockApprox = helpOpen ? 320 : 230;
          const topAvailH = Math.max(220, vp.h - dockApprox);
          const maxCellW = Math.floor((vp.w - 28) / size);
          const maxCellH = Math.floor((topAvailH - 28) / size);
          const c = Math.min(maxCellW, maxCellH);
          return clamp(c, 22, 34);
        }, [isGameMobile, vp.w, vp.h, size, helpOpen]);

        const pieceSize = React.useMemo(() => {
          return clamp(Math.round(cellSize * 0.78), 18, 28);
        }, [cellSize]);

        // ✅ (7) 桌機 hover 棋盤：游標變回合棋子 / 羅根第二步=灰叉 / 技能中=魔法棒
        const boardCursor = React.useMemo(() => {
          const fine = !isCoarse && view === 'GAME' && vp.w >= 920;
          if (!fine) return null;

          if (!room || room.status !== 'PLAYING') return null;

          // ✅ 不是你回合：不要顯示棋子游標（避免顯示別人的棋）
          const meLocal = findMePlayer(room, socket?.id, name);
          const nowMyTurn = isMyTurnByIdOrName(room, meLocal);
          if (!nowMyTurn) return null;

          // ✅ 技能中游標：
          // - 基紐/古杜：一律魔法棒
          if (ginyuMode || gudoMode) return cursorWand();

          // - 吉斯：只有「落子後要選擊退目標」才顯示魔法棒；
          //        「落子階段」仍顯示吉斯棋子游標
          if (jeiceMode && jeiceStep === 'selectTarget') return cursorWand();

          // ✅ 用 turnMeta（最準，undo/placed 都會更新）
          const tp = room.players?.[room.turnIndex];
          const baseColor =
            (turnMeta && turnMeta.color) ||
            (typeof tp?.colorIndex === 'number' ? COLORS[tp.colorIndex] : '#cfcfcf');

          const roleIdx =
            (turnMeta && typeof turnMeta.roleIndex === 'number')
              ? turnMeta.roleIndex
              : (() => {
                  const slot = room.mode === 'DUAL' ? room.turnSlot || 1 : 1;
                  return tp ? getPlayerRoleIndex(room, tp, slot) : null;
                })();

          const placed =
            (turnMeta && typeof turnMeta.placedThisTurn === 'number')
              ? Number(turnMeta.placedThisTurn || 0)
              : Number(tp?.placedThisTurn || 0);

          // ✅ 羅根第二步：灰叉（悔棋後 placed 會回到 0，游標自然回第一子）
          if (roleIdx === 3 && placed === 1) {
            return cursorGrayX(darkenHex(baseColor, 0.6));
          }

          const shape =
            (turnMeta && turnMeta.shape) ||
            (typeof roleIdx === 'number' ? ROLES[roleIdx]?.shape : 'circle');

          return cursorPiece(shape, baseColor);
        }, [
          isCoarse,
          view,
          vp.w,
          ginyuMode,
          gudoMode,
          jeiceMode,
          jeiceStep,
          room,
          socket?.id,
          name,
          turnMeta,
        ]);


        // ======= UI =======
        const inRoom = !!room?.id;
        const rootClass = 'appRoot' + (isGameMobile ? ' isGameMobile' : '');

        // ✅ 悔棋條件：巴特(1) / 羅根(3)，且 placedThisTurn===1（第二步前）
        // ✅ 改用 turnMeta（因為 placed event 不會更新 room.players）
        const canUndo =
          !!(
            turnMeta &&
            isMyTurn &&
            (turnMeta.roleIndex === 1 || turnMeta.roleIndex === 3) &&
            Number(turnMeta.placedThisTurn || 0) === 1
          );

        // ✅ 只讓「巴特 / 羅根」看到悔棋按鈕（其他角色完全不顯示）
        const showUndoBtn = !!(
          isMyTurn &&
          (myActiveRoleIndex === 1 || myActiveRoleIndex === 3)
        );

        const showMobileAudioUi = isCoarse || vp.w < 920;


        return e(
          'div',
          { className: rootClass },

          // ✅ Mobile audio panel overlay
          audioPanelOpen &&
            e(
              'div',
              { className: 'audioPanel' + (isGameMobile ? ' game' : '') },
              e('div', { className: 'audioRow' }, e('span', null, 'BGM'), e('button', { className: 'tinyBtn', onClick: toggleBgm }, bgmLabel())),
              e('div', { className: 'audioRow' }, e('span', null, 'SFX'), e('button', { className: 'tinyBtn', onClick: toggleSfx }, sfxLabel())),
              audioBlocked && !audioUnlocked
                ? e('div', { className: 'hint' }, '提示：若無聲音，先點一下 BGM/SFX 以解鎖瀏覽器播放。')
                : null
            ),

          // ✅ (6) 輪到你了 Toast
          myTurnToast
            ? e(
                'div',
                { className: 'myTurnToast ' + (myTurnToast.show ? 'show' : '') },
                e('div', {
                  className: myTurnToast.shape || 'circle',
                  style: { color: myTurnToast.color, '--piece': '18px' },
                }),
                e('div', null, e('div', { className: 'txt' }, '輪到你了！'), e('div', { className: 'subtxt' }, myTurnToast.roleName))
              )
            : null,

          // ===== TopBar（手機對局會被 CSS 隱藏）=====
          e(
            'div',
            { className: 'topBar' },
            e(
              'div',
              { className: 'brand' },
              e(
                'div',
                { className: 'title' },
                inRoom
                  ? view === 'GAME'
                    ? `基紐棋｜對局中（${room?.mode === 'DUAL' ? 'DUAL' : 'SINGLE'}）`
                    : `基紐棋｜房間（${room?.mode === 'DUAL' ? 'DUAL' : 'SINGLE'}）`
                  : '基紐棋｜建立或加入房間'
              ),
              e(
                'div',
                { className: 'sub' },
                inRoom
                  ? e(
                      React.Fragment,
                      null,
                      e('span', null, `房間：${room.id}`),
                      e(
                        'button',
                        { className: 'tinyBtn ' + (copied ? 'copied' : ''), onClick: onCopyRoomId, title: '一鍵複製房間編號' },
                        copied ? '已複製' : '複製'
                      ),
                      e('button', { className: 'tinyBtn', onClick: leaveRoom, title: '退出此房間（回到建立/加入畫面）' }, '退出房間')
                    )
                  : '建立或加入房間開始遊玩'
              )
            ),
            e(
              'div',
              { className: 'row' },
              e('div', { className: 'pill' }, socket?.id ? `你已連線` : '連線中…'),
              showMobileAudioUi
                ? e(
                    'button',
                    {
                      className: 'tinyBtn',
                      onClick: async () => {
                        audioRef.current?.uiClick();
                        // 先嘗試解鎖一次
                        await ensureUnlocked();
                        setAudioPanelOpen((v) => !v);
                      },
                      title: '音效面板',
                    },
                    '🔊'
                  )
                : e(
                    React.Fragment,
                    null,
                    e('button', { className: 'tinyBtn', onClick: toggleBgm, title: '背景音樂 BGM' }, bgmLabel()),
                    e('button', { className: 'tinyBtn', onClick: toggleSfx, title: '音效 SFX' }, sfxLabel())
                  )
            )
          ),

          // ===== ENTRY =====
          view === 'ENTRY' &&
            e(
              'div',
              { className: 'screen grid' },
              e(
                'div',
                { className: 'card panelPad grid' },
                e('div', { className: 'label' }, '名稱'),
                e('input', { value: name, onChange: (ev) => setName(ev.target.value), placeholder: '輸入名稱（必填）' }),
                e(
                  'div',
                  { className: 'row', style: { flexWrap: 'wrap' } },
                  e('button', { onClick: () => createRoom('SINGLE'), disabled: !name.trim() }, '建立房間：單人模式'),
                  e('button', { onClick: () => createRoom('DUAL'), disabled: !name.trim() }, '建立房間：雙人模式'),
                  e('button', { onClick: joinRoom, disabled: !name.trim() }, '加入房間')
                ),
                e('div', { className: 'hint' }, '進房後將隱藏建立/加入按鈕（防呆），只保留房號複製與退出房間。')
              )
            ),

          // ===== ROOM =====
          view === 'ROOM' &&
            inRoom &&
            e(
              'div',
              { className: 'screen twoCols' },

              e(
                'div',
                { className: 'card panelPad grid' },
                e('div', { style: { fontWeight: 1000, marginBottom: 6 } }, room?.status === 'LOBBY' ? '房間設定（Lobby）' : '房間（等待回到 Lobby…）'),

                room?.status !== 'LOBBY'
                  ? e('div', { className: 'hint' }, '目前不在 Lobby 狀態（可能正在對局或賽後倒數），稍後會回到 Lobby。')
                  : null,

                room?.status === 'LOBBY' &&
                  e(
                    React.Fragment,
                    null,
                    e('div', { className: 'label' }, '顏色'),
                    e(
                      'div',
                      { className: 'rowWrap' },
                      COLORS.map((c, i) =>
                        e('div', {
                          key: i,
                          className: 'choice',
                          onClick: () => pickColor(i),
                          style: {
                            background: c,
                            outline: selectedColor === i ? '2px solid rgba(255,255,255,0.9)' : 'none',
                          },
                        })
                      )
                    ),

                    e('div', { className: 'label', style: { marginTop: 10 } }, room?.mode === 'DUAL' ? '角色（DUAL：角色1 / 角色2）' : '角色'),

                    room?.mode === 'DUAL'
                      ? e(
                          'div',
                          { className: 'row', style: { flexWrap: 'wrap' } },
                          e(
                            'button',
                            { onClick: () => openRoleSelect(1) },
                            selectedRole1 === null ? '選擇角色1（全螢幕）' : `角色1：${ROLES[selectedRole1]?.name}（重選）`
                          ),
                          e(
                            'button',
                            { onClick: () => openRoleSelect(2) },
                            selectedRole2 === null ? '選擇角色2（全螢幕）' : `角色2：${ROLES[selectedRole2]?.name}（重選）`
                          )
                        )
                      : e('button', { onClick: () => openRoleSelect(1) }, selectedRole1 === null ? '選擇角色（全螢幕）' : `已選：${ROLES[selectedRole1]?.name}（點我重選）`),

                    room?.mode === 'DUAL'
                      ? e(
                          React.Fragment,
                          null,
                          e('div', { className: 'hint' }, `角色1技能：${selectedRole1 !== null ? ROLES[selectedRole1]?.desc : '—'}`),
                          e('div', { className: 'hint' }, `角色2技能：${selectedRole2 !== null ? ROLES[selectedRole2]?.desc : '—'}`)
                        )
                      : selectedRole1 !== null && e('div', { className: 'hint' }, `技能：${ROLES[selectedRole1]?.desc || ''}`),

                    e(
                      'div',
                      { className: 'row', style: { marginTop: 10, flexWrap: 'wrap' } },
                      e('button', { onClick: readyUp }, '準備完成'),

                      // ✅ 房主：新增 AI
                      room?.hostId === socket?.id &&
                        e(
                          'button',
                          {
                            onClick: addAiPlayer,
                            style: {
                              background: 'linear-gradient(135deg, rgba(255,193,7,0.30), rgba(255,193,7,0.12))',
                              border: '1px solid rgba(255,255,255,0.18)',
                            },
                            title: '由房主新增一位 AI 對手（後端需支援 addAi 事件其一）',
                          },
                          '新增 AI'
                        ),

                      canStart &&
                        e(
                          'button',
                          {
                            onClick: startGame,
                            style: {
                              background: 'linear-gradient(135deg, rgba(76,175,80,0.38), rgba(76,175,80,0.18))',
                              border: '1px solid rgba(255,255,255,0.18)',
                            },
                          },
                          'Start Game'
                        )
                    )

                  )
              ),

              e(
                'div',
                { className: 'card panelPad grid' },
                e('div', { className: 'label' }, '玩家列表'),
                room.players &&
                  room.players.map((p) => {
                    let roleText = '選角中';
                    if (room?.mode === 'DUAL') {
                      const r1 = typeof p.roleIndex1 === 'number' ? ROLES[p.roleIndex1]?.name : null;
                      const r2 = typeof p.roleIndex2 === 'number' ? ROLES[p.roleIndex2]?.name : null;
                      if (r1 || r2) roleText = `角色1：${r1 || '—'}｜角色2：${r2 || '—'}`;
                    } else {
                      const rn = typeof p.roleIndex === 'number' ? ROLES[p.roleIndex]?.name : null;
                      roleText = rn ? rn : '選角中';
                    }

                    const color = typeof p.colorIndex === 'number' ? COLORS[p.colorIndex] : 'rgba(255,255,255,0.25)';

                    const ai = isAiPlayer(p);
                    const isHost = room?.hostId === socket?.id;

                    return e(
                      'div',
                      { key: p.id || p.name, className: 'playerLine' },

                      // left
                      e(
                        'div',
                        { className: 'playerLeft' },
                        e('div', { className: 'dot', style: { background: color } }),
                        e(
                          'div',
                          { style: { minWidth: 0 } },
                          e(
                            'div',
                            { className: 'playerName' },
                            p?.name || 'Player',
                            ai ? e('span', { className: 'badge aiBadge', style: { marginLeft: 8 } }, 'AI') : null
                          ),
                          e('div', { className: 'playerMeta' }, roleText)
                        )
                      ),

                      // right
                      e(
                        'div',
                        { style: { display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: 6 } },

                        // badges
                        e(
                          'div',
                          { className: 'rowWrap', style: { justifyContent: 'flex-end' } },
                          p.ready ? e('span', { className: 'badge' }, '已準備') : e('span', { className: 'badge' }, '未準備'),
                          (room?.hostId === p.id || room?.hostId === p?.id) ? e('span', { className: 'badge' }, '房主') : null
                        ),

                        // ✅ AI controls (only host & only in LOBBY)
                        ai && isHost && room?.status === 'LOBBY'
                          ? e(
                              'div',
                              { className: 'aiControls' },

                              e(
                                'button',
                                { className: 'tinyBtn', onClick: () => randomizeAiAll(p), title: '隨機顏色 + 角色（DUAL 會自動避免重複）' },
                                'AI 隨機'
                              ),

                              // color pick
                              e(
                                'div',
                                { className: 'rowWrap', style: { justifyContent: 'flex-end' } },
                                COLORS.map((c, i) =>
                                  e('div', {
                                    key: i,
                                    className: 'choice',
                                    onClick: () => setAiColor(p?.id || p?.name, i),
                                    title: '設定 AI 顏色',
                                    style: {
                                      background: c,
                                      width: 26,
                                      height: 26,
                                      borderRadius: 10,
                                      outline:
                                        typeof p?.colorIndex === 'number' && p.colorIndex === i
                                          ? '2px solid rgba(255,255,255,0.9)'
                                          : 'none',
                                    },
                                  })
                                )
                              ),

                              // ✅ role pick：改成「按鈕 → 全螢幕選角」
                              room?.mode === 'DUAL'
                                ? e(
                                    React.Fragment,
                                    null,
                                    e(
                                      'button',
                                      {
                                        className: 'tinyBtn',
                                        onClick: () => openAiRoleSelect(p?.id || p?.name, 1),
                                        title: '房主幫 AI 選擇 角色1（全螢幕）',
                                      },
                                      typeof p?.roleIndex1 === 'number'
                                        ? `AI 角色1：${ROLES[p.roleIndex1]?.name}（重選）`
                                        : 'AI 角色1：未選（點我選）'
                                    ),
                                    e(
                                      'button',
                                      {
                                        className: 'tinyBtn',
                                        onClick: () => openAiRoleSelect(p?.id || p?.name, 2),
                                        title: '房主幫 AI 選擇 角色2（全螢幕）',
                                      },
                                      typeof p?.roleIndex2 === 'number'
                                        ? `AI 角色2：${ROLES[p.roleIndex2]?.name}（重選）`
                                        : 'AI 角色2：未選（點我選）'
                                    )
                                  )
                                : e(
                                    'button',
                                    {
                                      className: 'tinyBtn',
                                      onClick: () => openAiRoleSelect(p?.id || p?.name, 1),
                                      title: '房主幫 AI 選擇 角色（全螢幕）',
                                    },
                                    typeof p?.roleIndex === 'number'
                                      ? `AI 角色：${ROLES[p.roleIndex]?.name}（重選）`
                                      : 'AI 角色：未選（點我選）'
                                  )

                            )
                          : null
                      )
                    );


                  })
              )
            ),

          // ===== GAME =====
          view === 'GAME' &&
            (isGameMobile
              ? e(
                  'div',
                  { className: 'gameShell' },
                  e(
                    'div',
                    { className: 'gameBoardArea' },
                    e(
                    'div',
                    { className: 'gameBoardCard' }, // ✅ 拿掉 card，避免露出圓角背景卡片
                    boardToRender.length > 0
                      ? e(
                          'div',
                          { className: 'arena', style: { '--cell': cellSize + 'px', '--boardW': size * cellSize + 'px' } },
                          e(
                            'div',
                            { className: 'arenaStage' },
                            e(Board, {
                                board: boardToRender,
                                onPlace: place,
                                room,
                                highlightSources,
                                highlightTargets,
                                highlightGudo,
                                highlightGudoTargets,
                                highlightGudoSelf,
                                highlightJeiceTargets,
                                highlightJeiceSource,
                                fx,
                                cellSize,
                                pieceSize,
                                cursor: null,
                              })

                          )
                        )
                      : e('div', null, '尚未開始遊戲')
                    )
                  ),
                  e(
                    'div',
                    { className: 'gameDock' },

                    // 房間/複製/音效/退出
                    e(
                      'div',
                      { className: 'dockRow' },
                      e(
                        'div',
                        { className: 'dockLeft' },
                        e('div', { className: 'pill' }, `房間：${room?.id || '--'}`),
                        e('button', { className: 'tinyBtn ' + (copied ? 'copied' : ''), onClick: onCopyRoomId }, copied ? '已複製' : '複製')
                      ),
                      e(
                        'div',
                        { className: 'dockRight' },
                        // ✅ 手機：一顆音效按鈕（展開面板）
                        e(
                          'button',
                          {
                            className: 'tinyBtn',
                            onClick: async () => {
                              audioRef.current?.uiClick();
                              await ensureUnlocked();
                              setAudioPanelOpen((v) => !v);
                            },
                          },
                          '🔊'
                        ),
                        e('button', { className: 'tinyBtn', onClick: leaveRoom }, '退出房間')
                      )
                    ),

                    // ✅ (5) 回合順序條 + 箭頭
                    e(TurnOrderBar, { room }),

                    // 回合資訊（當前）
                    turnMeta
                      ? e(
                          'div',
                          { className: 'pill turnPill', style: { marginTop: 10, width: '100%' } },
                          e('div', { className: 'turnDot', style: { background: turnMeta.color } }),
                          e('div', { className: 'turnIcon' }, e('div', { className: turnMeta.shape || 'circle', style: { color: turnMeta.color } })),
                          e(
                            'div',
                            null,
                            e('div', { className: 'turnText' }, `輪到：${turnMeta.playerName}`),
                            e(
                              'div',
                              { className: 'turnSub' },
                              `回合：${turnMeta.round}｜角色${room?.mode === 'DUAL' ? turnMeta.slot : 1}：${turnMeta.roleName}`
                            )
                          )
                        )
                      : null,

                    // 技能 / 悔棋 / 說明
                    e(
                      'div',
                      { className: 'dockBtns' },
                      isMyTurn && myActiveRoleIndex === 0
                        ? e('button', { onClick: activateGinyu, style: { background: 'rgba(156,39,176,0.35)' } }, '基紐能力')
                        : null,
                      isMyTurn && myActiveRoleIndex === 4
                        ? e('button', { onClick: activateGudo, style: { background: 'rgba(76,175,80,0.35)' } }, '古杜能力')
                        : null,
                      isMyTurn && myActiveRoleIndex === 5
                        ? e(
                            'button',
                            { onClick: activateJeice, style: { background: 'rgba(255,40,40,0.30)' } },
                            jeiceMode ? (jeiceStep === 'place' ? '吉斯：請先落子' : '吉斯：選擊退目標') : '吉斯能力'
                          )
                        : null,
                      isMyTurn && myActiveRoleIndex === 5 && jeiceMode
                        ? e('button', { onClick: cancelJeice, className: 'ghost' }, '取消吉斯')
                        : null,

                      // ✅ 悔棋 UI：只給 巴特/羅根 顯示；可用與否照 canUndo
                      showUndoBtn
                        ? e(
                            'button',
                            { onClick: undoMove, disabled: !canUndo, style: { background: 'rgba(255,255,255,0.14)' } },
                            '悔棋'
                          )
                        : null,


                      // ✅ (4) 手機技能說明抽屜
                      e('button', { className: 'tinyBtn', onClick: () => setHelpOpen((v) => !v) }, helpOpen ? '收起說明' : '技能說明')
                    ),

                    helpOpen ? e('div', { className: 'helpDrawer' }, e(SkillPanel, { room })) : null,

                    // 提示
                    jeiceMode
                      ? e(
                          'div',
                          { className: 'dockHint' },
                          jeiceStep === 'place'
                            ? '吉斯：點空格落子；落子後若相鄰有目標，再點 1 顆擊退。'
                            : '吉斯：點紅色虛線目標擊退；點其他地方可放棄擊退（落子仍有效）。'
                        )
                      : canUndo
                      ? e('div', { className: 'dockHint' }, '你可在第二步前悔棋（回到本回合第一步之前）。')
                      : e('div', { className: 'dockHint' }, '提示：點棋盤下子。需要能力時使用上方按鈕。')
                  )
                )
              : // ✅ 桌機：三欄（左控制 / 中棋盤 / 右技能說明）
                e(
                  'div',
                  { className: 'screen gameDesktop3' },

                  // 左：控制區
                  e(
                    'div',
                    { className: 'card panelPad grid' },
                    e('div', { style: { fontWeight: 1000, marginBottom: 6 } }, '對局控制'),

                    e(TurnOrderBar, { room }),

                    turnMeta
                      ? e(
                          'div',
                          { className: 'pill turnPill', style: { display: 'inline-flex' } },
                          e('div', { className: 'turnDot', style: { background: turnMeta.color } }),
                          e('div', { className: 'turnIcon' }, e('div', { className: turnMeta.shape || 'circle', style: { color: turnMeta.color } })),
                          e(
                            'div',
                            null,
                            e('div', { className: 'turnText' }, `輪到：${turnMeta.playerName}`),
                            e(
                              'div',
                              { className: 'turnSub' },
                              `回合：${turnMeta.round}｜角色${room?.mode === 'DUAL' ? turnMeta.slot : 1}：${turnMeta.roleName}`
                            )
                          )
                        )
                      : null,

                    e(
                      'div',
                      { style: { display: 'flex', gap: 10, flexWrap: 'wrap' } },
                      isMyTurn && myActiveRoleIndex === 0
                        ? e('button', { onClick: activateGinyu, style: { background: 'rgba(156,39,176,0.35)' } }, '發動基紐能力')
                        : null,
                      isMyTurn && myActiveRoleIndex === 4
                        ? e('button', { onClick: activateGudo, style: { background: 'rgba(76,175,80,0.35)' } }, '發動古杜能力')
                        : null,
                      isMyTurn && myActiveRoleIndex === 5
                        ? e(
                            'button',
                            { onClick: activateJeice, style: { background: 'rgba(255,40,40,0.30)' } },
                            jeiceMode ? (jeiceStep === 'place' ? '吉斯：請先落子' : '吉斯：選擇擊退目標') : '發動吉斯能力'
                          )
                        : null,
                      isMyTurn && myActiveRoleIndex === 5 && jeiceMode ? e('button', { onClick: cancelJeice, className: 'ghost' }, '取消吉斯') : null,

                      // ✅ 悔棋 UI：只給 巴特/羅根 顯示；可用與否照 canUndo
                      showUndoBtn ? e('button', { onClick: undoMove, disabled: !canUndo }, '悔棋') : null

                    ),

                    e(
                      'div',
                      { className: 'hint' },
                      ginyuMode
                        ? '基紐：先點你的基紐棋，再點同列/同行目標棋交換。'
                        : gudoMode
                        ? '古杜：先點你的古杜棋，再點相鄰目標棋，最後點移動到的空格。'
                        : jeiceMode
                        ? jeiceStep === 'place'
                          ? '吉斯：點空格落子（落子後再選擊退目標）。'
                          : '吉斯：點紅色虛線目標擊退；點其他地方可放棄擊退。'
                        : canUndo
                        ? '提示：巴特/羅根在第二步前可悔棋。'
                        : '提示：桌機游標會顯示本回合棋子；羅根第二步顯示灰叉；技能中游標為魔法棒。'
                    )
                  ),

                  // 中：棋盤
                  e(
                    'div',
                    { className: 'card boardWrap' },
                    boardToRender.length > 0
                      ? e(
                          'div',
                          {
                            className: 'arena',
                            style: {
                              '--cell': '28px',
                              '--boardW': size * 28 + 'px',
                            },
                          },
                          e(
                            'div',
                            { className: 'arenaTop' },
                            e('img', {
                              src: '/img/building003.png',
                              alt: 'building',
                              draggable: 'false',
                            })
                          ),
                          e(
                            'div',
                            { className: 'arenaStage' },
                            e(Board, {
                              board: boardToRender,
                              onPlace: place,
                              room,
                              highlightSources,
                              highlightTargets,
                              highlightGudo,
                              highlightGudoTargets,
                              highlightGudoSelf,
                              highlightJeiceTargets,
                              highlightJeiceSource,
                              fx,
                              cellSize: 28,
                              pieceSize: 22,
                              cursor: boardCursor,
                            })
                          )
                        )
                      : e('div', null, '尚未開始遊戲')
                  ),


                  // 右：技能說明
                  e(
                    'div',
                    { className: 'card panelPad grid' },
                    e('div', { style: { fontWeight: 1000 } }, '技能說明'),
                    e('div', { className: 'hint' }, '新手可在此查看角色能力。'),
                    e(SkillPanel, { room })
                  )
                )),

          // ===== ROLE SCREEN =====
          view === 'ROLE' &&
            e(RoleSelectScreen, {
              room,
              slot: pickingSlot,

              // ✅ 依「正在選角的人」決定 selectedRole / blockedRoleIndex
              selectedRole: (() => {
                const r0 = roomRef.current || room;
                if (!r0) return null;

                // AI：讀 AI 自己的 roleIndex1/2 或 roleIndex
                if (pickingFor === 'ai') {
                  const p = getPlayerByTarget(r0, aiPickingTarget);
                  if (!p) return null;
                  if (r0.mode === 'DUAL') return pickingSlot === 1 ? p.roleIndex1 : p.roleIndex2;
                  return p.roleIndex;
                }

                // self：沿用你原本的 state
                if (r0.mode === 'DUAL') return pickingSlot === 1 ? selectedRole1 : selectedRole2;
                return selectedRole1;
              })(),

              // ✅ DUAL 才有 blocked：只擋「同一個玩家」另一槽
              blockedRoleIndex: (() => {
                const r0 = roomRef.current || room;
                if (!r0 || r0.mode !== 'DUAL') return null;

                if (pickingFor === 'ai') {
                  const p = getPlayerByTarget(r0, aiPickingTarget);
                  if (!p) return null;
                  const other = pickingSlot === 1 ? p.roleIndex2 : p.roleIndex1;
                  return typeof other === 'number' ? other : null;
                }

                const other = pickingSlot === 1 ? selectedRole2 : selectedRole1;
                return typeof other === 'number' ? other : null;
              })(),

              // ✅ 顯示用：你是在幫誰選角
              pickerLabel: (() => {
                if (pickingFor !== 'ai') return '你';
                const r0 = roomRef.current || room;
                const p = r0 ? getPlayerByTarget(r0, aiPickingTarget) : null;
                return `AI：${p?.name || aiPickingTarget || 'AI'}`;
              })(),

              onClose: () => {
                audioRef.current?.uiClick();
                setView('ROOM');
              },
              onConfirm: confirmRole,
              audio: audioRef.current,
            }),


          // ✅ 結算畫面（result 存在才顯示）
          result &&
            e(
              'div',
              { className: 'resultScreen' },
              e(
                'div',
                { className: 'resultCard' },

                // left
                e(
                  'div',
                  { className: 'resultLeft' },
                  e('div', { className: 'resultTitle' }, `🎉 ${result.winnerName} 勝利！`),
                  e(
                    'div',
                    { className: 'resultSub' },
                    `倒數 ${result.secondsLeft}s（可提前返回房間）`
                  ),

                  (() => {
                    // ✅ winnerRoleIdxs 在 startResult 已經算好（DUAL 會有兩個）
                    const roleIdxs = Array.isArray(result.winnerRoleIdxs) ? result.winnerRoleIdxs : [];
                    const isDual = roleIdxs.length >= 2;

                    return e(
                      'div',
                      { className: 'resultCards' + (isDual ? ' dual' : '') },
                      roleIdxs.slice(0, 2).map((ri, k) => {
                        const r = typeof ri === 'number' ? ROLES[ri] : null;
                        const src = r?.cardArt || '';
                        return e(
                          'div',
                          { key: k, className: 'resultRoleCard' },
                          src
                            ? e('img', {
                                src,
                                alt: r?.name || 'role',
                                draggable: 'false',
                                onError: (ev) => {
                                  try { ev.target.style.display = 'none'; } catch (e) {}
                                },
                              })
                            : null
                        );
                      })
                    );
                  })(),

                  e(
                    'div',
                    { className: 'resultBottom' },
                    e(
                      'button',
                      { className: 'resultBtn', onClick: exitResult },
                      `返回房間（${result.secondsLeft}s）`
                    ),
                    e('div', { className: 'resultHint' }, '你也可以等倒數結束自動返回房間')
                  )
                ),

                // Right: board snapshot
                e(
                  'div',
                  { className: 'resultRight' },
                  e(
                    'div',
                    { style: { pointerEvents: 'none' } },
                    e(Board, {
                      board: result.finalBoard,
                      onPlace: place, // 仍然傳入，但 Board 會 readOnly 不會觸發
                      room,
                      highlightSources: [],
                      highlightTargets: [],
                      highlightGudo: [],
                      highlightGudoTargets: [],
                      highlightGudoSelf: [],
                      highlightJeiceTargets: [],
                      highlightJeiceSource: null,
                      fx: null,
                      cellSize,
                      pieceSize,
                      cursor: null,

                      // ✅ 新增：結算要用
                      readOnly: true,
                      winLine: result.winLine || [],
                    })
                  )
                )
              )
            )

        );
      }

      function RoleSelectScreen({ room, slot, selectedRole, blockedRoleIndex, pickerLabel, onClose, onConfirm, audio }) {
        const n = ROLES.length;
        const [current, setCurrent] = React.useState(typeof selectedRole === 'number' ? selectedRole : 0);

        const [lockedIndex, setLockedIndex] = React.useState(null);

        const [dragPx, setDragPx] = React.useState(0);
        const dragPxRef = React.useRef(0);
        const rafRef = React.useRef(0);
        const dragRef = React.useRef({ down: false, x0: 0, lastX: 0, lastT: 0, v: 0, pointerId: null });

        const snapPxRef = React.useRef(260);

        React.useEffect(() => {
          const prevOverflow = document.body.style.overflow;
          document.body.style.overflow = 'hidden';
          setupVisualViewportVars();
          const t = setTimeout(() => setupVisualViewportVars(), 0);
          return () => {
            clearTimeout(t);
            document.body.style.overflow = prevOverflow;
            setupVisualViewportVars();
          };
        }, []);

        React.useEffect(() => {
          function recalc() {
            const vw = window.innerWidth || 360;
            const cardW = Math.min(vw * 0.92, 420);
            snapPxRef.current = Math.max(200, Math.min(cardW * 0.78, 320));
          }
          recalc();
          window.addEventListener('resize', recalc);
          return () => window.removeEventListener('resize', recalc);
        }, []);

        React.useEffect(() => {
          try { audio?.playRoleVoice(current); } catch (e) {}
        }, [current]);

        function scheduleDragUpdate(px) {
          dragPxRef.current = px;
          if (rafRef.current) return;
          rafRef.current = requestAnimationFrame(() => {
            rafRef.current = 0;
            setDragPx(dragPxRef.current);
          });
        }

        function onPointerDown(ev) {
          dragRef.current.down = true;
          dragRef.current.x0 = ev.clientX;
          dragRef.current.lastX = ev.clientX;
          dragRef.current.lastT = performance.now();
          dragRef.current.v = 0;
          dragRef.current.pointerId = ev.pointerId;
          scheduleDragUpdate(0);
          try { ev.currentTarget.setPointerCapture(ev.pointerId); } catch (e) {}
        }

        function onPointerMove(ev) {
          if (!dragRef.current.down) return;
          const now = performance.now();
          const dx = ev.clientX - dragRef.current.lastX;
          const dt = Math.max(8, now - dragRef.current.lastT);
          dragRef.current.v = dx / dt;
          dragRef.current.lastX = ev.clientX;
          dragRef.current.lastT = now;

          const total = ev.clientX - dragRef.current.x0;
          scheduleDragUpdate(total);
        }

        function onPointerUp(ev) {
          if (!dragRef.current.down) return;
          dragRef.current.down = false;

          const total = dragPxRef.current;
          const snapPx = snapPxRef.current;
          const progress = clamp(-total / snapPx, -1, 1);
          const v = dragRef.current.v;

          const flick = Math.abs(v) > 0.65;

          if (flick) {
            if (v < 0) setCurrent((c) => (c + 1) % n);
            else setCurrent((c) => (c - 1 + n) % n);
          } else {
            if (progress > 0.28) setCurrent((c) => (c + 1) % n);
            else if (progress < -0.28) setCurrent((c) => (c - 1 + n) % n);
          }

          scheduleDragUpdate(0);
          try { ev.currentTarget.releasePointerCapture(ev.pointerId); } catch (e) {}
        }

        function shortDelta(i, c) {
          let d = i - c;
          const half = Math.floor(n / 2);
          while (d > half) d -= n;
          while (d < -half) d += n;
          return d;
        }

        const others = (room?.players || []).map((p) => {
          if (room?.mode === 'DUAL') {
            const r1 = typeof p.roleIndex1 === 'number' ? ROLES[p.roleIndex1]?.name : null;
            const r2 = typeof p.roleIndex2 === 'number' ? ROLES[p.roleIndex2]?.name : null;
            return { name: p.name || 'Player', role: `1:${r1 || '—'} 2:${r2 || '—'}` };
          }
          const rn = typeof p.roleIndex === 'number' ? ROLES[p.roleIndex]?.name : null;
          return { name: p.name || 'Player', role: rn || '選角中' };
        });

        const role = ROLES[current];
        const snapPx = snapPxRef.current;
        const dragProgress = clamp(-dragPx / snapPx, -1, 1);
        const blocked = room?.mode === 'DUAL' && typeof blockedRoleIndex === 'number' ? blockedRoleIndex : null;

        // ✅ NEW：左下角技能面板開關（手機卡片用）
        const [skillOpen, setSkillOpen] = React.useState(false);

        // ✅ 換卡就收起（避免切到下一張還開著）
        React.useEffect(() => {
          setSkillOpen(false);
        }, [current]);

        // ✅ 單卡跟手：位移/旋轉（限制最大值避免拖太遠）
        const followX = clamp(dragPx * 0.35, -90, 90);
        const followDeg = clamp(dragPx * 0.03, -8, 8);

        return e(
          'div',
          { className: 'roleScreen' },

          e(
            'div',
            { className: 'roleTop' },
            e(
              'div',
              { className: 'roleTopLeft' },
              e(
                'div',
                { className: 'brand' },
                e('div', { className: 'title' }, room?.mode === 'DUAL'
                    ? `${pickerLabel || '你'}：選擇角色（角色${slot}）`
                    : `${pickerLabel || '你'}：選擇角色`
                  ),
                e('div', { className: 'sub' }, '手機：滑動選卡｜桌機：點擊鎖定（避免滑鼠移動誤選）')
              ),
              e(
                'div',
                { className: 'miniList' },
                others.map((o, idx) => e('div', { key: idx, className: 'miniChip' }, `${o.name}：${o.role}`))
              )
            ),
            e(
              'button',
              {
                className: 'ghost',
                onClick: () => { audio?.uiClick?.(); onClose(); },
              },
              '返回房間'
            )
          ),

          e(
            'div',
            { className: 'roleMain' },

            /* ===== 手機：carousel 卡片（仍只顯示目前這張，但拖曳時會微微跟手） ===== */
            e(
              'div',
              {
                className: 'carousel' + (dragRef.current.down ? ' dragging' : ''),
                onPointerDown,
                onPointerMove,
                onPointerUp,
                onPointerCancel: onPointerUp, // ✅ 補強：避免來電/切視窗時卡住
              },
              e(
                'div',
                { className: 'carouselInner' },
                (() => {
                  const r = ROLES[current];
                  if (!r) return null;

                  const style = {
                    transform: `translate3d(${followX}px, 0, 0) rotate(${followDeg}deg) scale(1)`,
                    opacity: 1,
                    filter: 'none',
                    zIndex: 1000,

                    transition: dragRef.current.down
                      ? 'none'
                      : 'transform 160ms cubic-bezier(.2,.9,.2,1)',

                    // ❌ 不能是 none，不然按鈕永遠點不到
                    // pointerEvents: 'none',

                    boxShadow: '0 34px 90px rgba(0,0,0,0.62)',
                    borderColor: 'rgba(255,255,255,0.28)',
                    willChange: 'transform',
                  };

                  return e(
                    'div',
                    {
                      key: current,
                      className: 'roleCard',
                      style,
                    },

                    CardArtLayer(r),

                    // ✅ NEW：左下角「技能」按鈕
                    e(
                      'button',
                      {
                        className: 'cardSkillBtn',
                        onPointerDown: (ev) => {
                          // 不要啟動 swipe
                          ev.stopPropagation();
                          try { ev.currentTarget.setPointerCapture(ev.pointerId); } catch (e) {}
                        },
                        onPointerMove: (ev) => { ev.stopPropagation(); },
                        onPointerUp: (ev) => {
                          ev.stopPropagation();
                          try { ev.currentTarget.releasePointerCapture(ev.pointerId); } catch (e) {}
                        },
                        onClick: (ev) => {
                          ev.stopPropagation();
                          ev.preventDefault();
                          audio?.uiClick?.();
                          setSkillOpen((v) => !v);
                        },
                        title: '顯示/收起技能',
                      },
                      skillOpen ? '收起' : '技能'
                    ),

                    // ✅ NEW：左下角技能面板（縮小顯示）
                    e(
                      'div',
                      {
                        className: 'cardSkillPop' + (skillOpen ? ' open' : ''),
                        onPointerDown: (ev) => {
                          // 允許在面板內滑動，不要觸發 swipe
                          ev.stopPropagation();
                          try { ev.currentTarget.setPointerCapture(ev.pointerId); } catch (e) {}
                        },
                        onPointerMove: (ev) => { ev.stopPropagation(); },
                        onPointerUp: (ev) => {
                          ev.stopPropagation();
                          try { ev.currentTarget.releasePointerCapture(ev.pointerId); } catch (e) {}
                        },
                        onClick: (ev) => { ev.stopPropagation(); },
                      },
                      e('div', { className: 'cardSkillTitle' }, '技能說明'),
                      e('div', { className: 'cardSkillText' }, r?.desc || '')
                    ),

                    // ✅ 卡片內：只保留右上棋子 icon
                    e(
                      'div',
                      { className: 'roleCardHeader', style: { justifyContent: 'flex-end' } },
                      e('div', { className: 'roleIcon' }, e('div', { className: r.shape, style: { color: '#fff' } }))
                    )
                  );

                })()
              )
            ),


            /* ===== 桌機：deck 卡片（同樣只留 icon + 右下直排名） ===== */
            e(
              'div',
              { className: 'desktopDeck' },
              ROLES.map((r, i) => {
                const active = i === current;
                const cls = 'desktopCard ' + (active ? 'active' : 'dim');
                return e(
                  'div',
                  {
                    key: i,
                    className: cls,
                    onMouseEnter: () => {
                      if (lockedIndex === null) {
                        setCurrent(i);
                        try { audio?.playRoleVoice?.(i); } catch (e) {}
                      }
                    },
                    onClick: () => {
                      audio?.uiClick?.();
                      setCurrent(i);
                      setLockedIndex(i);
                      try { audio?.playRoleVoice?.(i); } catch (e) {}
                    },
                  },

                  CardArtLayer(r),

                  e(
                    'div',
                    { className: 'roleCardHeader', style: { justifyContent: 'flex-end' } },
                    e('div', { className: 'roleIcon' }, e('div', { className: r.shape, style: { color: '#fff' } }))
                  )
                );
              })
            ),
          ),

          e(
            'div',
            { className: 'roleBottom' },
            e(
              'button',
              {
                className: 'confirm',
                disabled: blocked !== null && current === blocked,
                onClick: () => {
                  audio?.uiClick?.();
                  if (blocked !== null && current === blocked) {
                    alert('同一玩家的 角色1 / 角色2 不能重複');
                    return;
                  }
                  onConfirm(current);
                },
              },
              room?.mode === 'DUAL' ? `確定為 角色${slot}` : '確定角色'
            )
          )

        );
      }
      function posKey(x, y) {
        return x + ',' + y;
      }
      function makePosSet(arr) {
        const s = new Set();
        (arr || []).forEach((p) => {
          if (!p) return;
          const x = p.x, y = p.y;
          if (typeof x === 'number' && typeof y === 'number') s.add(posKey(x, y));
        });
        return s;
      }

      function Board({
        board,
        onPlace,
        room,
        highlightSources,
        highlightTargets,
        highlightGudo,
        highlightGudoTargets,
        highlightGudoSelf,
        highlightJeiceTargets,
        highlightJeiceSource,
        fx,
        cellSize,
        pieceSize,
        cursor,

        // ✅ 新增：結算畫面用
        readOnly,
        winLine,
      }) {

        const size = board.length;
        const cells = [];

        function isFxCell(pos, x, y) {
          return pos && pos.x === x && pos.y === y;
        }

        // ✅ 避免每格都 .some()（手機會慢），先做成 Set
        const setSources = React.useMemo(() => makePosSet(highlightSources), [highlightSources]);
        const setTargets = React.useMemo(() => makePosSet(highlightTargets), [highlightTargets]);
        const setGudo = React.useMemo(() => makePosSet(highlightGudo), [highlightGudo]);
        const setGudoTargets = React.useMemo(() => makePosSet(highlightGudoTargets), [highlightGudoTargets]);
        const setGudoSelf = React.useMemo(() => makePosSet(highlightGudoSelf), [highlightGudoSelf]);
        const setJeiceTargets = React.useMemo(() => makePosSet(highlightJeiceTargets), [highlightJeiceTargets]);
        // ✅ 勝利連線（閃電）：把座標轉成 Set，加速判斷
        const setWin = React.useMemo(() => makePosSet(winLine), [winLine]);

        const jeiceSourceKey =
          highlightJeiceSource ? posKey(highlightJeiceSource.x, highlightJeiceSource.y) : null;

        // ✅ 事件委派：只用一個 handler（避免 225 個 closure / render 開銷）
        function onGridPointerDown(ev) {
          if (readOnly) return;

          const el = ev?.target?.closest ? ev.target.closest('.cell') : null;
          if (!el) return;

          // 右鍵/中鍵不處理
          if (ev.pointerType === 'mouse' && ev.button !== 0) return;

          // touch/pen：避免產生後續 ghost click
          if (ev.pointerType !== 'mouse') {
            try { ev.preventDefault(); } catch (e) {}
          }

          const x = Number(el.dataset.x);
          const y = Number(el.dataset.y);
          if (Number.isNaN(x) || Number.isNaN(y)) return;

          onPlace(x, y);
        }


        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const v = board[y][x];

            let className = 'cell';
            const k = posKey(x, y);

            if (setSources.has(k)) className += ' highlight-source';
            if (setTargets.has(k)) className += ' highlight-target';
            if (setGudo.has(k)) className += ' highlight-gudo';
            if (setGudoTargets.has(k)) className += ' highlight-gudo-target';
            if (setGudoSelf.has(k)) className += ' highlight-gudo-self';

            if (setJeiceTargets.has(k)) className += ' highlight-jeice-target';
            if (jeiceSourceKey && jeiceSourceKey === k) className += ' highlight-jeice-source';

            if (isFxCell(fx?.target, x, y)) className += ' fx-shake';
            if (isFxCell(fx?.to, x, y)) className += ' fx-pop';

            let inner = null;

            if (v > 0) {
              const { ownerIndex, slot } = decodeToken(v);
              const player = room.players?.[ownerIndex] || null;
              const ci = typeof player?.colorIndex === 'number' ? player.colorIndex : 0;
              const color = player ? COLORS[ci] : '#fff';
              const roleIdx = getPlayerRoleIndex(room, player, slot);
              const role = ROLES[typeof roleIdx === 'number' ? roleIdx : 0];
              inner = e('div', { className: role.shape, style: { color } });
            } else if (v < 0) {
              const ownerIndex = Math.abs(v) - 1;
              const owner = room.players?.[ownerIndex];
              const ci = typeof owner?.colorIndex === 'number' ? owner.colorIndex : 0;
              const baseColor = owner ? COLORS[ci] : '#888';
              const darker = darkenHex(baseColor, 0.6);
              inner = e('div', { className: 'grayX', style: { color: darker } });
            }

            const isWin = setWin.has(k);
            if (isWin) className += ' winCell';

            // ✅ 注意：cell 不再掛 onClick / onPointerDown
            cells.push(
              e(
                'div',
                { key: `${x},${y}`, className, 'data-x': x, 'data-y': y },
                inner,
                null
              )
            );

          }
        }

        function orbStyle(from, to) {
          if (!from || !to) return null;
          const cell = cellSize || 28;
          const piece = pieceSize || 22;
          const pad = (cell - piece) / 2;
          const sx = from.x * cell + pad;
          const sy = from.y * cell + pad;
          const dx = (to.x - from.x) * cell;
          const dy = (to.y - from.y) * cell;
          return { left: sx + 'px', top: sy + 'px', '--dx': dx, '--dy': dy };
        }

        const fx1 = fx?.type === 'jeice' ? orbStyle(fx.from, fx.target) : null;
        const fx2 = fx?.type === 'jeice' && fx?.to ? orbStyle(fx.target, fx.to) : null;

        const cell = cellSize || 28;
        const piece = pieceSize || 22;

        return e(
          'div',
          {
            className: 'board',
            style: {
              '--cell': cell + 'px',
              '--piece': piece + 'px',
              cursor: readOnly ? 'default' : (cursor || 'pointer'),
            },
          },

          e(
            'div',
            {
              className: 'boardGrid',
              style: { gridTemplateColumns: `repeat(${size}, ${cell}px)` },
              onPointerDown: onGridPointerDown,
            },
            cells
          ),

          fx?.type === 'jeice'
            ? e(
                'div',
                { className: 'fxLayer' },
                fx1 ? e('div', { className: 'jeiceOrb', style: fx1 }) : null,
                fx2 ? e('div', { className: 'jeiceOrb secondary', style: fx2 }) : null
              )
            : null,

          // ✅ 勝利整條閃電線（readOnly 結算畫面才需要也行，你想顯示在任何地方就不加 readOnly 判斷）
          e(WinnerLineOverlay, { winLine, size, cellSize: cell })
        );
      }


      ReactDOM.createRoot(document.getElementById('app')).render(e(App));
    </script>
  </body>
</html>
