<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Âü∫Á¥êÊ£ã (Geniuchi)</title>
    <style>
      :root {
        --bg: #0b0f19;
        --panel: rgba(255, 255, 255, 0.08);
        --panel2: rgba(255, 255, 255, 0.12);
        --stroke: rgba(255, 255, 255, 0.18);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --shadow: 0 16px 50px rgba(0, 0, 0, 0.45);
        --r: 18px;

        /* ‚úÖ visualViewport vars (mobile keyboard / zoom safe) */
        --vvh: 100dvh;
        --vv-top: 0px;
        --vv-bottom: 0px;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          Arial, Helvetica, sans-serif;
        margin: 0;
        padding: 0;
        background: radial-gradient(
            1200px 600px at 20% 0%,
            #19223b 0%,
            rgba(11, 15, 25, 0) 55%
          ),
          radial-gradient(
            900px 700px at 100% 0%,
            #173c32 0%,
            rgba(11, 15, 25, 0) 55%
          ),
          var(--bg);
        color: var(--text);
        overscroll-behavior: none;
      }

      button {
        border: 0;
        border-radius: 14px;
        padding: 10px 12px;
        font-weight: 800;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.14);
        color: var(--text);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.25);
        -webkit-tap-highlight-color: transparent;
      }
      button:active {
        transform: translateY(1px);
      }
      button[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      input {
        width: 100%;
        border-radius: 14px;
        padding: 12px 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        outline: none;

        /* ‚úÖ iOS Safari/Chrome auto-zoom prevention */
        font-size: 16px;
        line-height: 1.2;
      }

      .appRoot {
        min-height: 100vh;
        min-height: 100dvh;
        display: flex;
        flex-direction: column;
      }

      .topBar {
        padding: 14px 14px 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .brand {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .brand .title {
        font-size: 16px;
        font-weight: 1000;
        letter-spacing: 0.4px;
      }
      .brand .sub {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .pill {
        padding: 8px 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.14);
        font-size: 12px;
        color: var(--muted);
      }

      .tinyBtn {
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.16);
        box-shadow: none;
      }
      .tinyBtn.copied {
        background: rgba(76, 175, 80, 0.22);
        border: 1px solid rgba(76, 175, 80, 0.35);
        color: rgba(255, 255, 255, 0.92);
      }

      .screen {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 14px;
        gap: 12px;
      }

      .card {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.13),
          rgba(255, 255, 255, 0.06)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: var(--r);
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      .grid {
        display: grid;
        gap: 12px;
      }

      .twoCols {
        display: grid;
        gap: 12px;
        grid-template-columns: 1fr;
      }
      @media (min-width: 920px) {
        .twoCols {
          grid-template-columns: 360px 1fr;
          align-items: start;
        }
      }

      .panelPad {
        padding: 12px;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .rowWrap {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .label {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .choice {
        width: 34px;
        height: 34px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      /* ===== Ê£ãÂ≠êÂΩ¢ÁãÄÔºàÊîπÊàêÂêÉ --pieceÔºâ ===== */
      .circle {
        width: var(--piece);
        height: var(--piece);
        border-radius: 50%;
        background: currentColor;
      }

      .jeice {
        position: relative;
        width: var(--piece);
        height: var(--piece);
      }
      .jeice::before,
      .jeice::after {
        content: '';
        position: absolute;
        top: calc(var(--piece) * 0.08);
        left: 50%;
        width: calc(var(--piece) * 0.26);
        height: calc(var(--piece) * 0.92);
        background: currentColor;
        border-radius: 999px;
        transform-origin: 50% 0%;
      }
      .jeice::before {
        transform: translateX(-50%) rotate(38deg);
      }
      .jeice::after {
        transform: translateX(-50%) rotate(-38deg);
      }

      .star::before {
        content: '‚òÖ';
        font-size: calc(var(--piece) * 1.18);
        line-height: 1;
        color: currentColor;
      }

      .square {
        width: var(--piece);
        height: var(--piece);
        background: currentColor;
      }

      .triangle {
        width: 0;
        height: 0;
        border-left: calc(var(--piece) * 0.5) solid transparent;
        border-right: calc(var(--piece) * 0.5) solid transparent;
        border-bottom: calc(var(--piece) * 0.9) solid currentColor;
      }

      .logan {
        position: relative;
        width: calc(var(--piece) * 0.72);
        height: calc(var(--piece) * 0.72);
        border-radius: 50%;
        border: calc(var(--piece) * 0.11) solid currentColor;
      }
      .logan::before,
      .logan::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: calc(var(--piece) * 1.25);
        height: calc(var(--piece) * 0.14);
        background: currentColor;
        transform-origin: center;
      }
      .logan::before {
        transform: translate(-50%, -50%) rotate(45deg);
      }
      .logan::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }

      /* ‚úÖ ÂõûÂêàÈ°ØÁ§∫ÔºöÈ°èËâ≤Èªû + ËßíËâ≤icon */
      .turnPill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 12px;
      }
      .turnDot {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.24);
        background: rgba(255, 255, 255, 0.35);
      }
      .turnIcon {
        width: 22px;
        height: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: scale(0.85);
        transform-origin: center;
      }
      .turnText {
        color: rgba(255, 255, 255, 0.82);
        font-weight: 900;
      }
      .turnSub {
        color: rgba(255, 255, 255, 0.65);
        font-weight: 700;
      }

      /* ===== ÊàøÈñìÁé©ÂÆ∂Âàó ===== */
      .playerLine {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 10px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
      }
      .playerLeft {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
      }
      .dot {
        width: 14px;
        height: 14px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.25);
      }
      .playerName {
        font-weight: 1000;
        max-width: 180px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .playerMeta {
        font-size: 12px;
        color: var(--muted);
      }
      .badge {
        font-size: 12px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
      }

      /* ===== BoardÔºàÂêÉ --cell / --pieceÔºâ ===== */
      .boardWrap {
        padding: 12px;
      }
      .board {
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        display: inline-block;
        border-radius: 14px;
        overflow: hidden;

        --cell: 28px;
        --piece: 22px;
      }
      .boardGrid {
        display: grid;
      }
      .cell {
        width: var(--cell);
        height: var(--cell);
        border: 1px solid rgba(255, 255, 255, 0.06);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
        -webkit-tap-highlight-color: transparent;
      }
      .highlight-source {
        outline: 2px solid #b84bff;
      }
      .highlight-target {
        outline: 2px dashed #b84bff;
      }
      .highlight-gudo {
        outline: 2px solid #55ffb0;
      }
      .highlight-gudo-target {
        outline: 2px dashed #55ffb0;
      }
      .highlight-gudo-self {
        outline: 2px solid #35c66a;
      }
      .highlight-jeice-source {
        outline: 2px solid rgba(255, 77, 77, 0.95);
      }
      .highlight-jeice-target {
        outline: 2px dashed rgba(255, 77, 77, 0.95);
      }

      .grayX {
        position: relative;
        width: var(--piece);
        height: var(--piece);
      }
      .grayX::before,
      .grayX::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: var(--piece);
        height: calc(var(--piece) * 0.18);
        background: currentColor;
        transform-origin: center;
      }
      .grayX::before {
        transform: translate(-50%, -50%) rotate(45deg);
      }
      .grayX::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }

      /* ===== Jeice FX layer ===== */
      .fxLayer {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .jeiceOrb {
        position: absolute;
        width: var(--piece);
        height: var(--piece);
        border-radius: 50%;
        background: rgba(255, 40, 40, 0.92);
        filter: drop-shadow(0 0 10px rgba(255, 40, 40, 0.75));
        transform: translate3d(0, 0, 0) scale(1);
        animation: jeiceMove 320ms cubic-bezier(0.15, 0.9, 0.25, 1) forwards;
      }
      .jeiceOrb::after {
        content: '';
        position: absolute;
        inset: calc(var(--piece) * -0.45);
        border-radius: 50%;
        background: radial-gradient(
          circle,
          rgba(255, 40, 40, 0.55),
          rgba(255, 40, 40, 0)
        );
        animation: jeicePulse 320ms ease-out forwards;
      }
      .jeiceOrb.secondary {
        animation-delay: 200ms;
      }
      .jeiceOrb.secondary::after {
        animation-delay: 200ms;
      }

      @keyframes jeiceMove {
        to {
          transform: translate3d(
              calc(var(--dx) * 1px),
              calc(var(--dy) * 1px),
              0
            )
            scale(0.92);
        }
      }
      @keyframes jeicePulse {
        0% {
          opacity: 0.9;
          transform: scale(0.85);
        }
        100% {
          opacity: 0;
          transform: scale(1.25);
        }
      }

      .fx-shake {
        animation: fxShake 260ms ease-out;
      }
      @keyframes fxShake {
        0% {
          transform: translate3d(0, 0, 0);
        }
        25% {
          transform: translate3d(1px, 0, 0);
        }
        50% {
          transform: translate3d(-1px, 0, 0);
        }
        75% {
          transform: translate3d(1px, 0, 0);
        }
        100% {
          transform: translate3d(0, 0, 0);
        }
      }

      .fx-pop::after {
        content: '';
        position: absolute;
        inset: 4px;
        border-radius: 10px;
        background: rgba(255, 40, 40, 0.12);
        border: 1px solid rgba(255, 40, 40, 0.28);
        animation: fxPop 520ms ease-out forwards;
        pointer-events: none;
      }
      @keyframes fxPop {
        0% {
          opacity: 0;
          transform: scale(0.75);
        }
        25% {
          opacity: 1;
          transform: scale(1);
        }
        100% {
          opacity: 0;
          transform: scale(1.1);
        }
      }

      /* ===== ÈÅ∏ËßíÔºöÂÖ®Ëû¢ÂπïÔºàmobile viewport safeÔºâ===== */
      .roleScreen {
        position: fixed;
        left: 0;
        right: 0;
        top: var(--vv-top);
        height: var(--vvh);
        z-index: 50;
        background: radial-gradient(
            900px 700px at 30% 0%,
            rgba(76, 175, 80, 0.18) 0%,
            rgba(0, 0, 0, 0) 55%
          ),
          radial-gradient(
            800px 800px at 90% 10%,
            rgba(156, 39, 176, 0.18) 0%,
            rgba(0, 0, 0, 0) 55%
          ),
          var(--bg);
        display: flex;
        flex-direction: column;
        overscroll-behavior: none;
      }

      .roleTop {
        padding: calc(14px + env(safe-area-inset-top)) 14px 12px;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
      }

      .roleTopLeft {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-width: 70vw;
      }

      .miniList {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .miniChip {
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
        color: var(--muted);
        white-space: nowrap;
      }

      /* ‚úÖ Áµ¶Â∫ïÈÉ® Dock È†êÁïôÁ©∫ÈñìÔºåÈÅøÂÖçË¢´ÈÅÆ‰Ωè */
      .roleMain {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 12px;
        padding: 0 12px;
        padding-bottom: calc(
          150px + env(safe-area-inset-bottom) + var(--vv-bottom)
        );
      }

      /* ‚úÖ Â∫ïÈÉ® DockÔºöÊõ¥„Äå‰∏ÄÈ´î„ÄçÔºãÈçµÁõ§ÂΩàÂá∫‰πü‰∏çÊìãÊåâÈàï */
      .roleBottom {
        position: fixed;
        left: 12px;
        right: 12px;
        bottom: calc(12px + var(--vv-bottom));
        z-index: 70;

        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;

        padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
        border-radius: 22px;

        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.22),
          rgba(0, 0, 0, 0.35)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: 0 28px 70px rgba(0, 0, 0, 0.62);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      .roleBottom::before {
        content: '';
        position: absolute;
        left: 10px;
        right: 10px;
        top: -18px;
        height: 22px;
        border-radius: 20px 20px 0 0;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0),
          rgba(0, 0, 0, 0.25)
        );
        pointer-events: none;
      }

      .confirm {
        flex: 1;
        padding: 14px 14px;
        border-radius: 16px;
        background: linear-gradient(
          135deg,
          rgba(79, 172, 254, 0.35),
          rgba(0, 242, 254, 0.18)
        );
        border: 1px solid rgba(255, 255, 255, 0.18);
      }

      .ghost {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }

      /* ===== ÊâãÊ©üÔºöÊªëÂãïÈÅ∏Âç° ===== */
      .carousel {
        position: relative;
        height: min(520px, 66vh);
        overflow: hidden;
        touch-action: pan-y;
        -webkit-user-select: none;
        user-select: none;
      }
      .carousel::before,
      .carousel::after {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        width: 64px;
        z-index: 6;
        pointer-events: none;
      }
      .carousel::before {
        left: 0;
        background: linear-gradient(
          90deg,
          rgba(11, 15, 25, 0.92),
          rgba(11, 15, 25, 0)
        );
      }
      .carousel::after {
        right: 0;
        background: linear-gradient(
          270deg,
          rgba(11, 15, 25, 0.92),
          rgba(11, 15, 25, 0)
        );
      }

      .carouselInner {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        perspective: 900px;
      }

      .roleCard {
        position: absolute;
        width: min(92vw, 420px);
        height: min(56vh, 460px);
        border-radius: 22px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.16),
          rgba(255, 255, 255, 0.06)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: 0 28px 80px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        transform-origin: center;
        pointer-events: none;
        will-change: transform, opacity, filter;
        backface-visibility: hidden;
        transform-style: preserve-3d;
      }

      .roleCardHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .roleName {
        font-size: 22px;
        font-weight: 1000;
        letter-spacing: 0.6px;
      }
      .roleIcon {
        width: 46px;
        height: 46px;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(0, 0, 0, 0.15);
      }
      .roleDesc {
        color: var(--muted);
        font-size: 14px;
        line-height: 1.45;
      }
      .roleStats {
        margin-top: auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .stat {
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
        padding: 10px;
        font-size: 12px;
        color: var(--muted);
      }
      .stat b {
        color: var(--text);
      }

      .desktopDeck {
        display: none;
        height: min(520px, 70vh);
        gap: 14px;
        padding: 6px;
      }
      .desktopCard {
        flex: 1;
        border-radius: 22px;
        padding: 18px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.15),
          rgba(255, 255, 255, 0.06)
        );
        box-shadow: 0 28px 80px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 10px;
        transition: transform 220ms ease, filter 220ms ease, opacity 220ms ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .desktopCard::after {
        content: '';
        position: absolute;
        inset: -2px;
        border-radius: 24px;
        border: 2px solid rgba(255, 255, 255, 0);
        transition: border-color 220ms ease;
        pointer-events: none;
      }
      .desktopCard.active {
        transform: scale(1.06);
        filter: saturate(1.15) contrast(1.05);
      }
      .desktopCard.active::after {
        border-color: rgba(255, 255, 255, 0.4);
      }
      .desktopCard.dim {
        opacity: 0.55;
        filter: grayscale(0.2) saturate(0.8);
      }

      @media (hover: hover) and (pointer: fine) {
        .carousel {
          display: none;
        }
        .desktopDeck {
          display: flex;
        }
      }

      @media (max-width: 420px) {
        .roleName {
          font-size: 20px;
        }
        .roleCard {
          padding: 16px;
        }
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
      }

      /* ===== Ë≥ΩÂæå‰øùÁïôÊ£ãÁõ§ 10 Áßí Overlay ===== */
      .postGame {
        position: fixed;
        inset: 0;
        z-index: 60;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding: 14px;
        pointer-events: none;
      }
      .postGame .box {
        width: min(720px, 100%);
        background: rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 18px;
        padding: 14px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        pointer-events: auto;
      }
      .postGame .box .title {
        font-weight: 1000;
        font-size: 14px;
        margin-bottom: 6px;
      }
      .postGame .box .sub {
        color: rgba(255, 255, 255, 0.78);
        font-size: 12px;
        line-height: 1.4;
        margin-bottom: 12px;
      }
      .postGame .box .btn {
        width: 100%;
        padding: 14px 12px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.16);
      }

      /* =========================================================
         ‚úÖ ÊâãÊ©üÊ£ãÂ±ÄÂõ∫ÂÆöÁâàÈù¢ÔºöÊ£ãÁõ§‰∏äÊñπ / Ë≥áË®ä‰∏ãÊñπ Dock
         ========================================================= */
      .gameShell {
        position: fixed;
        left: 0;
        right: 0;
        top: var(--vv-top);
        height: var(--vvh);
        z-index: 20;
        display: flex;
        flex-direction: column;
        padding: 12px;
        padding-top: calc(10px + env(safe-area-inset-top));
        padding-bottom: calc(
          12px + env(safe-area-inset-bottom) + var(--vv-bottom)
        );
        gap: 10px;
      }

      .gameBoardArea {
        flex: 1;
        min-height: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .gameBoardCard {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px;
        border-radius: 22px;
      }

      .gameDock {
        width: 100%;
        border-radius: 22px;
        padding: 12px;
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 0.22),
          rgba(0, 0, 0, 0.35)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: 0 28px 70px rgba(0, 0, 0, 0.62);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      .dockRow {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
      }

      .dockLeft {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .dockRight {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .dockBtns {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 8px;
      }

      .dockHint {
        margin-top: 8px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.65);
        line-height: 1.35;
      }

      /* ‚úÖ ÊâãÊ©üÊ£ãÂ±ÄÊôÇÔºöÊää topBar Èö±ËóèÔºåÁ©∫ÈñìÁïôÁµ¶Ê£ãÁõ§ */
      .appRoot.isGameMobile .topBar {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/socket.io/client-dist/socket.io.min.js"></script>

    <script>
      const e = React.createElement;

      const COLORS = [
        '#e53935',
        '#8e24aa',
        '#3949ab',
        '#1e88e5',
        '#00897b',
        '#fdd835',
      ];

      const ROLES = [
        {
          name: 'Âü∫Á¥ê',
          shape: 'circle',
          desc: 'ÂõûÂêàÈñãÂßãÂèØ‰∫§ÊèõÔºöÈÅ∏Ëá™Â∑±ÁöÑÂü∫Á¥êÊ£ãÔºåËàáÂêåË°å/ÂêåÂàóÁöÑ‰ªª‰∏Ä„ÄåÈùûËá™Â∑±Ê≠§ËßíËâ≤„ÄçÁöÑÊ≠£Â∏∏Ê£ã‰∫§ÊèõÔºàÂåÖÂê´Â∞çÊâãËàáËá™Â∑±Âè¶‰∏ÄËßíËâ≤Ôºâ„ÄÇ',
        },
        {
          name: 'Â∑¥Áâπ',
          shape: 'star',
          desc: 'ÊØèÂõûÂêàÂèØ‰∏ãÂÖ©Â≠êÔºõ‰ΩÜÂãùÂà©ÈúÄË¶Å 6 ÈÄ£Á∑öÔºàÂêå‰∏ÄÁé©ÂÆ∂Âêå‰∏ÄËßíËâ≤Ôºâ„ÄÇ',
        },
        {
          name: 'ÂäõÂ∫´ÂßÜ',
          shape: 'square',
          desc: 'ÂèØË¶ÜËìã‰∏ÄËà¨Ê£ãÔºà‰∏çËÉΩË¶ÜËìãÂèâÂèâÔºâ„ÄÇÂèØË¶ÜËìã‰ªª‰Ωï„ÄåÈùûÂèâÂèâ„ÄçÊ£ãÔºàÂåÖÂê´Â∞çÊâãËàáËá™Â∑±Âè¶‰∏ÄËßíËâ≤Ôºâ„ÄÇ',
        },
        {
          name: 'ÁæÖÊ†π',
          shape: 'logan',
          desc: 'ÊØèÂõûÂêàÂÖ©Ê≠•ÔºöÁ¨¨ 1 Ê≠•‰∏ãÊ≠£Â∏∏Ê£ãÔºåÁ¨¨ 2 Ê≠•‰∏ãÁÅ∞Âèâ„ÄÇ',
        },
        {
          name: 'Âè§Êùú',
          shape: 'triangle',
          desc: 'ÂõûÂêàÈñãÂßãÂèØÁßªÂãïÔºöÈÅ∏Ëá™Â∑±ÁöÑÂè§ÊùúÊ£ãÔºåÈÅ∏Âë®Âúç‰∏ÄÊ†ºÁöÑ„ÄåÈùûËá™Â∑±Ê≠§ËßíËâ≤„ÄçÊ≠£Â∏∏Ê£ãÔºàÂåÖÂê´Â∞çÊâãËàáËá™Â∑±Âè¶‰∏ÄËßíËâ≤ÔºâÔºåÂ∞áÂÖ∂ÁßªÂà∞Ë©≤Ê£ãÂë®ÂúçÁ©∫Ê†º„ÄÇ',
        },
        {
          name: 'ÂêâÊñØ',
          shape: 'jeice',
          desc: 'Á≤âÁ¢éÁêÉ„ÉªÊìäÈÄÄÔºöÁôºÂãïÂæåËêΩÂ≠êÔºåËã•Êñ∞ËêΩÂ≠êÁõ∏ÈÑ∞(8ÊñπÂêë)Êúâ„ÄåÈùûËá™Â∑±Ê≠§ËßíËâ≤„ÄçÊ≠£Â∏∏Ê£ãÔºåÂèØÈÅ∏ 1 È°ÜÂ∞áÂÖ∂ÂæÄÈÅ†Èõ¢ÊñπÂêëÊìäÈÄÄÔºàÊúÄÂ§ö 2 Ê†ºÔºõÈúÄÂæåÊñπÊòØÁ©∫Ê†ºÔºõ‰∏çËÉΩÊìäÈÄÄÁÅ∞ÂèâÔºâ„ÄÇ',
        },
      ];

      function connectSocket() {
        const params = new URLSearchParams(location.search);
        const serverUrl = params.get('server');
        if (serverUrl)
          return io(serverUrl, { transports: ['websocket', 'polling'] });
        return io();
      }

      function deepCopyBoard(b) {
        return Array.isArray(b) ? b.map((row) => row.slice()) : [];
      }

      function copyText(text) {
        if (!text) return Promise.resolve(false);
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard
            .writeText(String(text))
            .then(() => true)
            .catch(() => false);
        }
        return new Promise((resolve) => {
          try {
            const ta = document.createElement('textarea');
            ta.value = String(text);
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            const ok = document.execCommand('copy');
            document.body.removeChild(ta);
            resolve(!!ok);
          } catch (e) {
            resolve(false);
          }
        });
      }

      // token Ëß£ÊûêÔºötoken = ownerIndex*2 + slotÔºàslot=1/2ÔºâÔºåtoken Âæû 1 ÈñãÂßã
      function decodeToken(v) {
        const ownerIndex = Math.floor((v - 1) / 2);
        const slot = ((v - 1) % 2) + 1;
        return { ownerIndex, slot };
      }

      function getPlayerRoleIndex(room, player, slot) {
        if (!room || !player) return null;
        if (room.mode === 'DUAL') {
          return slot === 2 ? player.roleIndex2 : player.roleIndex1;
        }
        return player.roleIndex;
      }

      /* ‚úÖ visualViewport -> CSS vars */
      function setupVisualViewportVars() {
        const root = document.documentElement;
        const vv = window.visualViewport;

        if (!vv) {
          root.style.setProperty('--vvh', window.innerHeight + 'px');
          root.style.setProperty('--vv-top', '0px');
          root.style.setProperty('--vv-bottom', '0px');
          return;
        }

        const h = Math.max(100, Math.round(vv.height));
        const top = Math.max(0, Math.round(vv.offsetTop || 0));
        const bottom = Math.max(
          0,
          Math.round(window.innerHeight - (vv.height + vv.offsetTop))
        );

        root.style.setProperty('--vvh', h + 'px');
        root.style.setProperty('--vv-top', top + 'px');
        root.style.setProperty('--vv-bottom', bottom + 'px');
      }

      function clamp(v, a, b) {
        return Math.max(a, Math.min(b, v));
      }

      /* =========================================================
         ‚úÖ Audio Ë®≠ÂÆöÔºà‰Ω†‰πãÂæåÂè™Ë¶ÅÊîπÊ™îÂêç/ÊõøÊèõÈü≥Ê™îÂç≥ÂèØÔºâ
         ÊîæÈü≥Ê™î‰ΩçÁΩÆÔºöpublic/audio/
         ========================================================= */
      const AUDIO_ASSETS = {
        // ‚úÖ ÈÄ≤Á∂≤Á´ô / Lobby ÊúÉÊí≠ÊîæÔºà‰πãÂæåÊèõ Cha-La Head-Cha-LaÔºâ
        bgm_lobby: 'audio/chala_head_chala.mp3',

        // ‚úÖ ÈÄ≤Ê£ãÂ±ÄÔºöÊà∞È¨•Èü≥Ê®ÇÔºàÂñÆÈ¶ñ loopÔºâ
        bgm_battle_intro: 'audio/fighting_music.mp3',
        bgm_battle_loop: 'audio/fighting_music_all.mp3',

        // ‚úÖ ÂãùÂà©Èü≥ÊïàÔºà10Áßí‰øùÁïôÊ£ãÁõ§ÊúüÈñìÊí≠ÊîæÔºõÂõûÊàøÈñìÊúÉ‰∏≠Êñ∑Ôºâ
        sfx_victory: 'audio/sfx_victory_placeholder.mp3',

        // ‚úÖ UIÊåâÈàïÂÖ±Áî®
        sfx_ui_click: 'audio/sfx_ui_click_placeholder.mp3',

        // ‚úÖ ËßíËâ≤ÂñäÂêçÔºàÊ°åÊ©ü hover / ÊâãÊ©üÊªëÂà∞‰∏≠ÂøÉÔºâ
        voice_role: {
          0: 'audio/voice_ginyu_placeholder.mp3',
          1: 'audio/voice_burter_placeholder.mp3',
          2: 'audio/voice_recoome_placeholder.mp3',
          3: 'audio/voice_logan_placeholder.mp3',
          4: 'audio/voice_guldo_placeholder.mp3',
          5: 'audio/voice_jeice_placeholder.mp3',
        },

        // ‚úÖ Ê£ãÂ≠ê‰∫íÂãïÈü≥ÊïàÔºàÁî± server ÈÄèÈÅé socket emit key Ëß∏ÁôºÔºâ
        //    ‰Ω†ÊèõÈü≥ÊïàÂè™Ë¶Å‰øùÁïô key ‰∏çËÆä„ÄÅÊèõÊ™îÂêçÂç≥ÂèØ„ÄÇ
        sfx_map: {
          ginyu_place: 'audio/sfx_ginyu_place_placeholder.mp3',
          ginyu_swap: 'audio/sfx_ginyu_swap_placeholder.mp3',

          burter_place1: 'audio/sfx_burter_place1_placeholder.mp3',
          burter_place2: 'audio/sfx_burter_place2_placeholder.mp3',

          recoome_place: 'audio/sfx_recoome_place_placeholder.mp3',

          logan_place: 'audio/sfx_logan_place_placeholder.mp3',
          logan_cross: 'audio/sfx_logan_cross_placeholder.mp3',

          gudo_place: 'audio/sfx_gudo_place_placeholder.mp3',
          gudo_skill: 'audio/sfx_gudo_skill_placeholder.mp3',

          jeice_place: 'audio/sfx_jeice_place_placeholder.mp3',
          jeice_skill: 'audio/sfx_jeice_skill_placeholder.mp3',
        },
      };

      class AudioMgr {
        constructor({ onNeedGesture, onUnlocked } = {}) {
          this.onNeedGesture =
            typeof onNeedGesture === 'function' ? onNeedGesture : () => {};
          this.onUnlocked =
            typeof onUnlocked === 'function' ? onUnlocked : () => {};

          this.unlocked = false;
          // ‚úÖ mute ÁãÄÊÖã + Ë®ò‰ΩèÁõÆÂâçÊáâË©≤Êí≠Âì™‰∏ÄÁ®ÆBGM
          this.muted = false;
          this._wantBgm = 'lobby'; // 'lobby' | 'battle' | 'victory'

          this.bgm = null;
          this.bgmKind = null; // 'lobby' | 'battle' | 'victory'
          this.battleLoop = null;
          this.voice = null;

          // ‰Ω†ÊÉ≥Ë™øÊï¥Èü≥ÈáèÂèØ‰ª•ÊîπÈÄôË£°
          this.vol = {
            bgm: 0.35,
            sfx: 0.8,
            voice: 0.95,
          };

          this._lastVoiceAt = 0;
        }

        _makeAudio(src, { loop = false, volume = 1 } = {}) {
          const a = new Audio(src);
          a.preload = 'auto';
          a.loop = !!loop;
          a.volume = clamp(volume, 0, 1);
          a.muted = this.muted;
          return a;
        }

        setMuted(m) {
          this.muted = !!m;
          const apply = (a) => {
            if (!a) return;
            a.muted = this.muted;
            if (this.muted) {
              try {
                a.pause();
              } catch (e) {}
            }
          };
          apply(this.bgm);
          apply(this.battleLoop);
          apply(this.voice);
        }

        async unlock() {
          if (this.unlocked) return true;
          // Áî®„ÄåÊ•µÁü≠ÁÑ°ËÅ≤„ÄçÂòóË©¶Ëß£Èéñ autoplay
          const silent = new Audio(
            'data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCA'
          );
          silent.volume = 0;
          try {
            await silent.play();
            silent.pause();
            this.unlocked = true;
            this.onUnlocked();
            return true;
          } catch (e) {
            this.unlocked = false;
            this.onNeedGesture();
            return false;
          }
        }

        _isAutoplayBlocked(err) {
          const name = err?.name || '';
          const msg = String(err?.message || '').toLowerCase();
          return (
            name === 'NotAllowedError' ||
            msg.includes('not allowed') ||
            msg.includes('user gesture') ||
            msg.includes('interact')
          );
        }

        _maybeNeedGesture(err) {
          if (this.unlocked) return;
          if (this._isAutoplayBlocked(err)) this.onNeedGesture();
        }

        async _safePlay(a) {
          if (!a) return false;
          if (this.muted) return false;
          try {
            await a.play();
            // ‚úÖ Ëã•ÁÄèË¶ΩÂô®ÂÖÅË®± autoplayÔºåÈÄôË£°‰πüË¶ñÁÇ∫Â∑≤Ëß£Èéñ
            if (!this.unlocked) {
              this.unlocked = true;
              this.onUnlocked();
            }
            return true;
          } catch (err) {
            this._maybeNeedGesture(err);
            return false;
          }
        }

        stopAllBgm() {
          try {
            if (this.bgm) {
              this.bgm.pause();
              this.bgm.currentTime = 0;
            }
          } catch (e) {}
          try {
            if (this.battleLoop) {
              this.battleLoop.pause();
              this.battleLoop.currentTime = 0;
            }
          } catch (e) {}
          this.bgm = null;
          this.battleLoop = null;
          this.bgmKind = null;
        }
        setMuted(m) {
          this.muted = !!m;

          if (this.muted) {
            this.stopAllBgm();
            try {
              if (this.voice) {
                this.voice.pause();
                this.voice.currentTime = 0;
              }
            } catch (e) {}
            return;
          }

          // ‚úÖ Ëß£Èô§ÈùúÈü≥ÂæåÔºö‰æùÊúÄÂæåÊÉ≥Ë¶ÅÁöÑBGMÁãÄÊÖãÊÅ¢Âæ©
          this.resumeWantedBgm();
        }

        async resumeWantedBgm() {
          if (this.muted) return;

          // Â¶ÇÊûúÈÇÑÊ≤íËß£ÈéñÔºåÂÖàÂòóË©¶Ëß£ÈéñÔºà‰∏çÊàêÂäüÂ∞±Á≠â‰ΩøÁî®ËÄÖÈªû audioGateÔºâ
          if (!this.unlocked) {
            const ok = await this.unlock();
            if (!ok) return;
          }

          if (this._wantBgm === 'victory') return this.startVictory();
          if (this._wantBgm === 'battle') return this.startBattle();
          return this.startLobby();
        }

        async startLobby() {
          this._wantBgm = 'lobby';
          if (this.muted) return;
          if (this.bgmKind === 'lobby') return;
          this.stopAllBgm();
          this.bgmKind = 'lobby';
          this.bgm = this._makeAudio(AUDIO_ASSETS.bgm_lobby, {
            loop: true,
            volume: this.vol.bgm,
          });
          await this._safePlay(this.bgm);
        }

        async startBattle() {
          this._wantBgm = 'battle';
          if (this.muted) return;
          if (this.bgmKind === 'battle') return;
          this.stopAllBgm();
          this.bgmKind = 'battle';

          const introSrc = AUDIO_ASSETS.bgm_battle_intro;
          const loopSrc = AUDIO_ASSETS.bgm_battle_loop;

          // ‚úÖ Âè™Êúâ‰∏ÄÈ¶ñ loop
          if (!introSrc) {
            const loop = this._makeAudio(loopSrc, {
              loop: true,
              volume: this.vol.bgm,
            });
            this.bgm = loop;
            await this._safePlay(loop);
            return;
          }

          // ‚úÖ intro -> loop
          const intro = this._makeAudio(introSrc, {
            loop: false,
            volume: 0.6,
          });
          const loop = this._makeAudio(loopSrc, {
            loop: true,
            volume: this.vol.bgm,
          });

          this.bgm = intro;
          this.battleLoop = loop;

          intro.addEventListener('ended', async () => {
            if (this.bgmKind !== 'battle' || this.muted) return;
            this.bgm = loop;
            await this._safePlay(loop);
          });

          const ok = await this._safePlay(intro);
          if (!ok) return;
        }

        async startVictory() {
          this._wantBgm = 'victory';
          if (this.muted) return;
          if (this.bgmKind === 'victory') return;
          this.stopAllBgm();
          this.bgmKind = 'victory';
          this.bgm = this._makeAudio(AUDIO_ASSETS.sfx_victory, {
            loop: false,
            volume: 0.9,
          });
          await this._safePlay(this.bgm);
        }

        stopVictory() {
          if (this.bgmKind !== 'victory') return;
          this.stopAllBgm();
        }

        uiClick() {
          this.playOnce(AUDIO_ASSETS.sfx_ui_click, this.vol.sfx);
        }

        playOnce(src, volume = 0.8) {
          if (this.muted) return;
          if (!src) return;
          try {
            const a = this._makeAudio(src, { loop: false, volume });
            a.play().catch((err) => this._maybeNeedGesture(err));
          } catch (e) {}
        }

        playSfxKey(key) {
          const src = AUDIO_ASSETS.sfx_map?.[key];
          if (!src) return;
          this.playOnce(src, this.vol.sfx);
        }

        playRoleVoice(roleIndex) {
          if (this.muted) return;
          const src = AUDIO_ASSETS.voice_role?.[roleIndex];
          if (!src) return;

          const now = Date.now();
          if (now - this._lastVoiceAt < 550) return; // Èò≤Ê≠¢ÁãÇÂà∑
          this._lastVoiceAt = now;

          try {
            if (this.voice) {
              this.voice.pause();
              this.voice.currentTime = 0;
            }
          } catch (e) {}

          this.voice = this._makeAudio(src, {
            loop: false,
            volume: this.vol.voice,
          });
          this.voice.play().catch((err) => this._maybeNeedGesture(err));
        }
      }

      function App() {
        const [socket, setSocket] = React.useState(null);

        // ‚úÖ Êñ∞ÊµÅÁ®ãÔºöENTRYÔºàÊú™ÈÄ≤ÊàøÔºâÔΩúROOMÔºàÂ∑≤Âú®ÊàøÂÖß/Â§ßÂª≥ÔºâÔΩúROLEÔºàÂÖ®Ëû¢ÂπïÈÅ∏ËßíÔºâÔΩúGAMEÔºàÂ∞çÂ±ÄÔºâ
        const [view, setView] = React.useState('ENTRY');

        const [room, setRoom] = React.useState(null);
        const [board, setBoard] = React.useState([]);
        const [name, setName] = React.useState('');

        const [selectedColor, setSelectedColor] = React.useState(null);

        // ‚úÖ DUALÔºöËßíËâ≤1/ËßíËâ≤2
        const [selectedRole1, setSelectedRole1] = React.useState(null);
        const [selectedRole2, setSelectedRole2] = React.useState(null);
        const [pickingSlot, setPickingSlot] = React.useState(1);

        const [highlightSources, setHighlightSources] = React.useState([]);
        const [highlightTargets, setHighlightTargets] = React.useState([]);
        const [highlightGudo, setHighlightGudo] = React.useState([]);
        const [highlightGudoTargets, setHighlightGudoTargets] = React.useState(
          []
        );
        const [highlightGudoSelf, setHighlightGudoSelf] = React.useState([]);

        const [highlightJeiceTargets, setHighlightJeiceTargets] =
          React.useState([]);
        const [highlightJeiceSource, setHighlightJeiceSource] =
          React.useState(null);

        const [ginyuMode, setGinyuMode] = React.useState(false);
        const [gudoMode, setGudoMode] = React.useState(false);
        const [jeiceMode, setJeiceMode] = React.useState(false);
        const [jeiceStep, setJeiceStep] = React.useState('idle'); // idle | place | selectTarget

        // ‚úÖ ÂõûÂêà UI Ë≥áË®äÔºàÂê´È°èËâ≤/ÂΩ¢ÁãÄÔºâ
        const [turnMeta, setTurnMeta] = React.useState(null);

        const [copied, setCopied] = React.useState(false);

        // ‚úÖ Jeice FX
        const [fx, setFx] = React.useState(null);
        const fxTimerRef = React.useRef(null);

        // ‚úÖ Ë≥ΩÂæå‰øùÁïô 10 ÁßíÔºà‰øùÁïôÁµÇÂ±ÄÊ£ãÁõ§Ôºâ
        const [postGame, setPostGame] = React.useState(null); // { winnerName, secondsLeft, finalBoard }
        const postGameTimerRef = React.useRef(null);
        const postGameRef = React.useRef(null);

        const roomRef = React.useRef(null);

        // ‚úÖ Jeice auto-start guard
        const jeiceAutoKeyRef = React.useRef(null);

        // ‚úÖ viewport stateÔºöÁµ¶ÊâãÊ©üÊ£ãÁõ§Ë®àÁÆóÊ†ºÂ≠êÂ§ßÂ∞èÁî®
        const [vp, setVp] = React.useState(() => {
          const vv = window.visualViewport;
          return {
            w: Math.round(vv?.width || window.innerWidth || 360),
            h: Math.round(vv?.height || window.innerHeight || 640),
          };
        });

        // ‚úÖ Audio
        const audioRef = React.useRef(null);
        const [audioBlocked, setAudioBlocked] = React.useState(false);
        const [audioUnlocked, setAudioUnlocked] = React.useState(false);
        const [audioMuted, setAudioMuted] = React.useState(false);
        const [muted, setMuted] = React.useState(false);

        React.useEffect(() => {
          postGameRef.current = postGame;
        }, [postGame]);

        const isCoarse = React.useMemo(() => {
          try {
            return (
              !!window.matchMedia &&
              window.matchMedia('(pointer: coarse)').matches
            );
          } catch (e) {
            return false;
          }
        }, [vp.w, vp.h]);

        const isGameMobile = isCoarse && view === 'GAME' && vp.w < 920;

        async function handleAudioButton() {
          const am = audioRef.current;
          if (!am) return;

          // Â∞öÊú™Ëß£ÈéñÔºöÈªû‰∏ÄÊ¨°Ëß£Èéñ‰∏¶‰æùÁãÄÊÖãÊí≠Êîæ
          if (!am.unlocked) {
            const ok = await am.unlock();
            if (ok) {
              setAudioUnlocked(true);
              setAudioBlocked(false);

              am.setMuted(audioMuted);
              if (audioMuted) return;

              if (postGameRef.current) am.startVictory();
              else if (view === 'GAME' && room?.status === 'PLAYING')
                am.startBattle();
              else am.startLobby();
            } else {
              setAudioBlocked(true);
            }
            return;
          }

          // Â∑≤Ëß£ÈéñÔºöÂàáÊèõÈùúÈü≥
          const next = !audioMuted;
          setAudioMuted(next);
          am.setMuted(next);

          if (!next) {
            if (postGameRef.current) am.startVictory();
            else if (view === 'GAME' && room?.status === 'PLAYING')
              am.startBattle();
            else am.startLobby();
          }
        }

        function audioBtnLabel() {
          if (!audioUnlocked) return audioBlocked ? 'üîä ÂïüÁî®Èü≥Êïà' : 'üîä Èü≥Êïà';
          return audioMuted ? 'üîá Èü≥ÊïàÔºöÈóú' : 'üîä Èü≥ÊïàÔºöÈñã';
        }

        // ‚úÖ socket Âè™ÈÄ£‰∏ÄÊ¨°ÔºàÈÅøÂÖçÁé©ÂÆ∂‰∏çÂ≠òÂú®Ôºâ
        React.useEffect(() => {
          setupVisualViewportVars();

          // init audio mgr
          audioRef.current = new AudioMgr({
            onNeedGesture: () => setAudioBlocked(true),
            onUnlocked: () => {
              setAudioUnlocked(true);
              setAudioBlocked(false);
            },
          });

          // ÂòóË©¶‰∏ÄÈñãÂßãÂ∞±Êí≠ lobbyÔºàËã•Ë¢´ÊìãÔºå‰∏çÈ°ØÁ§∫ overlayÔºõÂè™ËÆìÊåâÈàïÈ°ØÁ§∫„ÄåÂïüÁî®Èü≥Êïà„ÄçÔºâ
          audioRef.current.startLobby();

          // ‰ªª‰Ωï‰∏ÄÊ¨°‰ΩøÁî®ËÄÖ‰∫íÂãïÔºåÈÉΩÂòóË©¶ unlockÔºàÂè™Ëß£ÈéñÔºå‰∏çÂº∑Ëø´Êí≠ÊîæÔºõÊí≠Êîæ‰∫§Áµ¶ÁãÄÊÖãÊ©üÔºâ
          const tryUnlock = async () => {
            const am = audioRef.current;
            if (!am || am.unlocked) return;
            const ok = await am.unlock();
            if (ok) {
              if (audioRef.current?.muted) return; // ‚úÖ ÈùúÈü≥Â∞±‰∏çË¶ÅËá™ÂãïÊí≠

              const r = roomRef.current;
              const v = view;
              const pg = postGameRef.current;
              if (pg) audioRef.current.startVictory();
              else if (v === 'GAME' && r?.status === 'PLAYING')
                audioRef.current.startBattle();
              else audioRef.current.startLobby();
            }
          };
          window.addEventListener('pointerdown', tryUnlock, { passive: true });

          const onResize = () => {
            setupVisualViewportVars();
            const vv = window.visualViewport;
            setVp({
              w: Math.round(vv?.width || window.innerWidth || 360),
              h: Math.round(vv?.height || window.innerHeight || 640),
            });
          };

          window.addEventListener('resize', onResize);
          if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', onResize);
            window.visualViewport.addEventListener('scroll', onResize);
          }

          const s = connectSocket();
          setSocket(s);

          // ‚úÖ Áî± server ÁôºÈÄÅÁöÑÈü≥Êïà key
          s.on('playSfx', (payload) => {
            try {
              const key = payload?.key;
              if (!key) return;
              audioRef.current?.playSfxKey(key);
            } catch (e) {}
          });

          s.on('roomUpdated', (r) => {
            roomRef.current = r;
            setRoom(r);

            // ÂêåÊ≠•Ëá™Â∑±ÈÅ∏Âà∞ÁöÑÈ°èËâ≤/ËßíËâ≤
            try {
              const me2 = r?.players?.find((p) => p.id === s.id);
              if (me2) {
                if (typeof me2.colorIndex === 'number')
                  setSelectedColor(me2.colorIndex);
                else setSelectedColor(null);

                if (r?.mode === 'DUAL') {
                  setSelectedRole1(
                    typeof me2.roleIndex1 === 'number' ? me2.roleIndex1 : null
                  );
                  setSelectedRole2(
                    typeof me2.roleIndex2 === 'number' ? me2.roleIndex2 : null
                  );
                } else {
                  setSelectedRole1(
                    typeof me2.roleIndex === 'number' ? me2.roleIndex : null
                  );
                  setSelectedRole2(null);
                }
              }
            } catch (e) {}

            // ‚úÖ postGame ÊúüÈñìÔºö‰∏çË¶ÜËìãÊ£ãÁõ§„ÄÅ‰∏çÂàá view
            if (!postGameRef.current) {
              setBoard(r.board || []);

              if (r?.status === 'PLAYING') setView('GAME');
              else if (r?.status === 'LOBBY') setView('ROOM');
              else if (r?.status === 'ENDED') setView('GAME');
            }

            updateTurnInfo(r);
          });

          s.on('placed', (payload) => {
            if (!postGameRef.current && payload.board) setBoard(payload.board);

            if (roomRef.current) {
              roomRef.current = {
                ...roomRef.current,
                board: payload.board || roomRef.current.board,
                turnIndex:
                  typeof payload.turnIndex === 'number'
                    ? payload.turnIndex
                    : roomRef.current.turnIndex,
                turnSlot:
                  typeof payload.turnSlot === 'number'
                    ? payload.turnSlot
                    : roomRef.current.turnSlot,
                roundCount:
                  typeof payload.roundCount === 'number'
                    ? payload.roundCount
                    : roomRef.current.roundCount,
                status: payload.status || roomRef.current.status,
              };
            }

            setRoom((prev) => {
              const base = prev || roomRef.current;
              if (!base) return base;
              return {
                ...base,
                board: payload.board || base.board,
                turnIndex:
                  typeof payload.turnIndex === 'number'
                    ? payload.turnIndex
                    : base.turnIndex,
                turnSlot:
                  typeof payload.turnSlot === 'number'
                    ? payload.turnSlot
                    : base.turnSlot,
                roundCount:
                  typeof payload.roundCount === 'number'
                    ? payload.roundCount
                    : base.roundCount,
                status: payload.status || base.status,
              };
            });

            // ‚úÖ Jeice FXÔºàÁî± server ÂÇ≥ effectÔºâ
            if (payload?.effect?.type === 'jeice') {
              if (fxTimerRef.current) clearTimeout(fxTimerRef.current);
              setFx(payload.effect);
              fxTimerRef.current = setTimeout(() => {
                setFx(null);
                fxTimerRef.current = null;
              }, 900);
            }

            if (payload.win) {
              const r = roomRef.current;
              const winner = r?.players?.[payload.win.winnerIndex];
              const winnerName = winner ? winner.name : payload.win.winnerId;

              const finalBoard = deepCopyBoard(payload.board || board);
              startPostGame(winnerName, finalBoard);
            }

            // Ê∏Ö UI ÁãÄÊÖã
            setHighlightSources([]);
            setHighlightTargets([]);
            setHighlightGudo([]);
            setHighlightGudoTargets([]);
            setHighlightGudoSelf([]);
            setGinyuMode(false);
            setGudoMode(false);
            if (roomRef.current) roomRef.current.gudoClientStep = 'idle';

            setHighlightJeiceTargets([]);
            setHighlightJeiceSource(null);
            setJeiceMode(false);
            setJeiceStep('idle');

            updateTurnInfo(roomRef.current);
          });

          s.on('gudoCancelled', () => {
            setHighlightGudo([]);
            setHighlightGudoTargets([]);
            setHighlightGudoSelf([]);
            setGudoMode(false);
            if (roomRef.current) roomRef.current.gudoClientStep = 'idle';
          });

          s.on('ginyuCancelled', (payload) => {
            setHighlightSources([]);
            setHighlightTargets([]);
            setGinyuMode(false);
            if (payload?.message) alert(payload.message);
          });

          s.on('jeiceCancelled', (payload) => {
            setHighlightJeiceTargets([]);
            setHighlightJeiceSource(null);
            setJeiceMode(false);
            setJeiceStep('idle');
            if (payload?.message) alert(payload.message);
          });

          return () => {
            try {
              s.disconnect();
            } catch (e) {}

            window.removeEventListener('resize', onResize);
            if (window.visualViewport) {
              window.visualViewport.removeEventListener('resize', onResize);
              window.visualViewport.removeEventListener('scroll', onResize);
            }
            window.removeEventListener('pointerdown', tryUnlock);
          };
        }, []);

        // ‚úÖ BGM Ëá™ÂãïÂàáÊèõÔºöLobby / Battle / Victory
        React.useEffect(() => {
          const am = audioRef.current;
          if (!am) return;

          // ‚úÖ Ê≤íËß£Èéñ or ÈùúÈü≥Ôºö‰∏çÂòóË©¶Êí≠ÊîæÔºàÈÅøÂÖçË¢´ÊìãÂæåÂèçË¶ÜËß∏ÁôºÔºâ
          if (!am.unlocked || audioMuted) return;

          if (postGame) {
            am.startVictory();
            return;
          }

          // Â∞çÂ±Ä‰∏≠ÊâçÊí≠ battle
          if (view === 'GAME' && room?.status === 'PLAYING') {
            am.startBattle();
            return;
          }

          // ÂÖ∂‰ªñÁãÄÊÖãÈÉΩÊí≠ lobby
          if (view === 'ENTRY' || view === 'ROOM' || view === 'ROLE') {
            am.startLobby();
            return;
          }
        }, [view, room?.status, postGame, audioMuted]);

        React.useEffect(() => {
          return () => {
            if (postGameTimerRef.current)
              clearInterval(postGameTimerRef.current);
            if (fxTimerRef.current) clearTimeout(fxTimerRef.current);
          };
        }, []);

        function updateTurnInfo(r) {
          if (!r || !r.players || r.status !== 'PLAYING') {
            setTurnMeta(null);
            return;
          }
          const turnPlayer = r.players[r.turnIndex];
          const slot = r.mode === 'DUAL' ? r.turnSlot || 1 : 1;
          const roleIdx = getPlayerRoleIndex(r, turnPlayer, slot);
          const roleName =
            typeof roleIdx === 'number' ? ROLES[roleIdx]?.name : 'Êú™ÈÅ∏Ëßí';
          const shape =
            typeof roleIdx === 'number' ? ROLES[roleIdx]?.shape : 'circle';

          const color =
            typeof turnPlayer?.colorIndex === 'number'
              ? COLORS[turnPlayer.colorIndex]
              : 'rgba(255,255,255,0.45)';

          setTurnMeta({
            round: r.roundCount || 1,
            playerName: turnPlayer?.name || 'N/A',
            slot,
            roleName,
            shape,
            color,
          });
        }

        function startPostGame(winnerName, finalBoard) {
          if (postGameTimerRef.current) clearInterval(postGameTimerRef.current);

          setPostGame({ winnerName, secondsLeft: 10, finalBoard });

          // ‚úÖ ÂãùÂà©Èü≥ÊïàÔºàÂõûÊàøÈñì/Èõ¢ÊàøÊúÉ‰∏≠Êñ∑Ôºâ
          if (!audioMuted && audioRef.current?.unlocked)
            audioRef.current?.startVictory();

          let left = 10;
          postGameTimerRef.current = setInterval(() => {
            left -= 1;
            setPostGame((pg) => (pg ? { ...pg, secondsLeft: left } : pg));
            if (left <= 0) {
              clearInterval(postGameTimerRef.current);
              postGameTimerRef.current = null;
              backToRoom();
            }
          }, 1000);
        }
        function toggleSound() {
          const next = !muted;
          setMuted(next);

          const am = audioRef.current;
          if (!am) return;

          am.setMuted(next);

          // ‚úÖ ÂæûÈóú -> ÈñãÔºöÁ´ãÂàªÊÅ¢Âæ©ÊáâË©≤Êí≠ÊîæÁöÑBGM
          if (!next) am.resumeWantedBgm();
        }

        // ‚úÖ ÂõûÂà∞ÂêåÊàø LobbyÔºà‰∏çÊúÉÂõûÂà∞ ENTRYÔºâ
        function backToRoom() {
          audioRef.current?.uiClick();
          audioRef.current?.stopVictory();
          if (!audioMuted && audioRef.current?.unlocked)
            audioRef.current?.startLobby();

          if (postGameTimerRef.current) {
            clearInterval(postGameTimerRef.current);
            postGameTimerRef.current = null;
          }
          setPostGame(null);
          if (roomRef.current) setView('ROOM');
        }

        function onCopyRoomId() {
          audioRef.current?.uiClick();
          if (!room?.id) return;
          copyText(String(room.id)).then((ok) => {
            if (!ok) return;
            setCopied(true);
            setTimeout(() => setCopied(false), 1200);
          });
        }

        function createRoom(mode) {
          audioRef.current?.uiClick();
          socket.emit(
            'createRoom',
            { maxPlayers: 4, name: name.trim(), mode },
            (res) => {
              if (res.ok) {
                setRoom(res.room);
                setView('ROOM');
              } else {
                alert(res.message || 'Âª∫Á´ãÂ§±Êïó');
              }
            }
          );
        }

        function joinRoom() {
          audioRef.current?.uiClick();
          const id = prompt('Ëº∏ÂÖ•ÊàøÈñìID');
          if (!id) return;
          socket.emit('joinRoom', { roomId: id, name: name.trim() }, (res) => {
            if (res.ok) {
              setRoom(res.room);
              setView('ROOM');
            } else alert(res.message || 'Âä†ÂÖ•Â§±Êïó');
          });
        }

        function leaveRoom() {
          audioRef.current?.uiClick();
          audioRef.current?.stopVictory();

          const rid = roomRef.current?.id || room?.id;
          if (!rid) {
            setRoom(null);
            setBoard([]);
            setView('ENTRY');
            if (!audioMuted && audioRef.current?.unlocked)
              audioRef.current?.startLobby();
            return;
          }
          socket.emit('leaveRoom', { roomId: rid }, (res) => {
            if (!res?.ok) {
              alert(res?.message || 'ÈÄÄÂá∫ÊàøÈñìÂ§±Êïó');
              return;
            }
            setRoom(null);
            setBoard([]);
            setSelectedColor(null);
            setSelectedRole1(null);
            setSelectedRole2(null);
            setView('ENTRY');
            if (!audioMuted && audioRef.current?.unlocked)
              audioRef.current?.startLobby();
          });
        }

        function pickColor(i) {
          audioRef.current?.uiClick();
          if (!room) return;
          setSelectedColor(i);
          socket.emit(
            'pickColor',
            { roomId: room.id, colorIndex: i },
            (res) => {
              if (res.ok) setRoom(res.room);
            }
          );
        }

        function openRoleSelect(slot) {
          audioRef.current?.uiClick();
          if (!room) return;

          // ‚úÖ ÈÄ≤ÂÖ•ÈÅ∏ËßíÂâçÂÖà blurÔºàÈÅøÂÖçËº∏ÂÖ•Ê°ÜÊîæÂ§ßÈÄ†ÊàêÂæåÁ∫åÁï´Èù¢ÊØî‰æãÊÄ™Ôºâ
          try {
            if (document.activeElement && document.activeElement.blur) {
              document.activeElement.blur();
            }
          } catch (e) {}
          setupVisualViewportVars();
          setTimeout(() => setupVisualViewportVars(), 0);

          const s = slot === 2 ? 2 : 1;
          setPickingSlot(s);
          setView('ROLE');
        }

        function confirmRole(roleIndex) {
          audioRef.current?.uiClick();
          if (!room) return;

          // ‚úÖ DUALÔºöÂêåÁé©ÂÆ∂ÂÖ©ËßíËâ≤‰∏çÂèØÈáçË§áÔºàÂâçÁ´ØÂÖàÊìãÔºâ
          if (room?.mode === 'DUAL') {
            const other = pickingSlot === 1 ? selectedRole2 : selectedRole1;
            if (other === roleIndex) {
              alert('Âêå‰∏ÄÁé©ÂÆ∂ÁöÑ ËßíËâ≤1 / ËßíËâ≤2 ‰∏çËÉΩÈáçË§á');
              return;
            }
          }

          if (room?.mode === 'DUAL') {
            if (pickingSlot === 1) setSelectedRole1(roleIndex);
            else setSelectedRole2(roleIndex);
          } else {
            setSelectedRole1(roleIndex);
            setSelectedRole2(null);
          }

          socket.emit(
            'pickRole',
            room?.mode === 'DUAL'
              ? { roomId: room.id, roleIndex, slot: pickingSlot }
              : { roomId: room.id, roleIndex },
            (res) => {
              if (res.ok) setRoom(res.room);
              else if (res?.message) alert(res.message);
            }
          );

          setView('ROOM');
        }

        function readyUp() {
          audioRef.current?.uiClick();
          if (selectedColor === null) return alert('Ë´ãÂÖàÈÅ∏ÊìáÈ°èËâ≤');

          if (room?.mode === 'DUAL') {
            if (selectedRole1 === null || selectedRole2 === null)
              return alert('DUAL Ê®°ÂºèË´ãÂÖàÈÅ∏Êìá ËßíËâ≤1 Ëàá ËßíËâ≤2');
          } else {
            if (selectedRole1 === null) return alert('Ë´ãÂÖàÈÅ∏ÊìáËßíËâ≤');
          }

          socket.emit('readyUp', { roomId: room.id }, (res) => {
            if (!res.ok && res.message) alert(res.message);
          });
        }

        function startGame() {
          audioRef.current?.uiClick();
          socket.emit('startGame', { roomId: room.id });
        }

        function cancelGinyu() {
          audioRef.current?.uiClick();
          try {
            socket?.emit('ginyuCancel', { roomId: room?.id }, () => {});
          } catch (e) {}
          setHighlightSources([]);
          setHighlightTargets([]);
          setGinyuMode(false);
        }

        function cancelJeice() {
          audioRef.current?.uiClick();
          try {
            socket?.emit('jeiceCancel', { roomId: room?.id }, () => {});
          } catch (e) {}
          setHighlightJeiceTargets([]);
          setHighlightJeiceSource(null);
          setJeiceMode(false);
          setJeiceStep('idle');
        }

        // ‚úÖ ÂêâÊñØÔºöÊØèÂõûÂêàÈ†êË®≠Ëá™ÂãïÂïüÂãï
        React.useEffect(() => {
          if (!socket || !room || room.status !== 'PLAYING') return;
          const me = room.players?.find((p) => p.id === socket.id);
          const isMyTurn = room.players?.[room.turnIndex]?.id === socket.id;
          if (!isMyTurn || !me) return;

          const slot = room.mode === 'DUAL' ? room.turnSlot || 1 : 1;
          const myRoleIndex = getPlayerRoleIndex(room, me, slot);
          if (myRoleIndex !== 5) return;

          if (me.usedJeiceThisTurn) {
            setHighlightJeiceTargets([]);
            setHighlightJeiceSource(null);
            setJeiceMode(false);
            setJeiceStep('idle');
            return;
          }

          const turnKey = `${room.id}:${room.roundCount || 1}:${
            room.turnIndex
          }:${room.turnSlot || 1}`;
          if (jeiceAutoKeyRef.current === turnKey) return;
          jeiceAutoKeyRef.current = turnKey;

          socket.emit('jeiceAbilityStart', { roomId: room.id }, (res) => {
            if (res?.ok) {
              setJeiceMode(true);
              setJeiceStep('place');
              setHighlightJeiceTargets([]);
              setHighlightJeiceSource(null);
            } else {
              jeiceAutoKeyRef.current = null;
            }
          });
        }, [
          socket,
          room?.id,
          room?.status,
          room?.turnIndex,
          room?.turnSlot,
          room?.roundCount,
        ]);

        function place(x, y) {
          if (!room || room.status !== 'PLAYING') return;

          // ===== Jeice =====
          if (jeiceMode) {
            if (jeiceStep === 'place') {
              socket.emit('jeicePlace', { roomId: room.id, x, y }, (res) => {
                if (res?.ok) {
                  setHighlightJeiceSource({ x, y });

                  // optimistic render
                  try {
                    const r0 = roomRef.current || room;
                    const myIdx = (r0?.players || []).findIndex(
                      (p) => p.id === socket.id
                    );
                    if (myIdx >= 0) {
                      const slot = r0?.mode === 'DUAL' ? r0.turnSlot || 1 : 1;
                      const token = myIdx * 2 + slot;
                      const b2 = deepCopyBoard(r0?.board || board);
                      if (b2?.[y]?.[x] === 0) b2[y][x] = token;
                      if (roomRef.current) roomRef.current.board = b2;
                      setBoard(b2);
                      setRoom((prev) => (prev ? { ...prev, board: b2 } : prev));
                    }
                  } catch (e) {}

                  const targets = Array.isArray(res.targets) ? res.targets : [];
                  if (targets.length) {
                    setHighlightJeiceTargets(targets);
                    setJeiceStep('selectTarget');
                  } else {
                    setHighlightJeiceTargets([]);
                    setHighlightJeiceSource(null);
                    setJeiceMode(false);
                    setJeiceStep('idle');
                  }
                } else {
                  if (res?.message) alert(res.message);
                  const msg = String(res?.message || '');
                  if (
                    msg.includes('ÊàøÈñì‰∏çÂ≠òÂú®') ||
                    msg.includes('ÈÅäÊà≤Êú™ÈñãÂßã') ||
                    msg.includes('Â∞öÊú™Ëº™Âà∞‰Ω†')
                  ) {
                    cancelJeice();
                  }
                }
              });
              return;
            }

            if (jeiceStep === 'selectTarget') {
              const inTargets = highlightJeiceTargets.some(
                (p) => p.x === x && p.y === y
              );

              if (!inTargets) {
                cancelJeice();
                return;
              }

              socket.emit(
                'jeiceSelectTarget',
                { roomId: room.id, x, y },
                (res) => {
                  if (!res?.ok && res?.message) alert(res.message);
                  setHighlightJeiceTargets([]);
                  setHighlightJeiceSource(null);
                  setJeiceMode(false);
                  setJeiceStep('idle');
                }
              );
              return;
            }
          }

          // ===== Âü∫Á¥ê =====
          if (ginyuMode) {
            const inSources = highlightSources.some(
              (p) => p.x === x && p.y === y
            );
            const inTargets = highlightTargets.some(
              (p) => p.x === x && p.y === y
            );

            if (highlightSources.length && !highlightTargets.length) {
              if (!inSources) {
                cancelGinyu();
                return;
              }
              socket.emit(
                'ginyuSelectSource',
                { roomId: room.id, x, y },
                (res) => {
                  if (res.ok) setHighlightTargets(res.targets);
                  else {
                    if (!String(res.message || '').includes('ÂèñÊ∂à'))
                      alert(res.message);
                    cancelGinyu();
                  }
                }
              );
              return;
            }

            if (highlightTargets.length) {
              if (!inTargets) {
                cancelGinyu();
                return;
              }
              socket.emit(
                'ginyuSelectTarget',
                { roomId: room.id, x, y },
                (res) => {
                  if (!res.ok) {
                    if (!String(res.message || '').includes('ÂèñÊ∂à'))
                      alert(res.message);
                    cancelGinyu();
                  }
                }
              );
              return;
            }

            cancelGinyu();
            return;
          }

          // ===== Âè§Êùú =====
          if (gudoMode) {
            const localRoom = roomRef.current || room;

            if (
              !localRoom.gudoClientStep ||
              localRoom.gudoClientStep === 'idle'
            ) {
              socket.emit(
                'gudoSelectSource',
                { roomId: localRoom.id, x, y },
                (res) => {
                  if (res.ok) {
                    setHighlightGudo(res.highlights || []);
                    localRoom.gudoClientStep = 'selectTarget';
                  } else {
                    alert(res.message);
                    setGudoMode(false);
                    setHighlightGudo([]);
                    setHighlightGudoTargets([]);
                    setHighlightGudoSelf([]);
                    localRoom.gudoClientStep = 'idle';
                  }
                }
              );
              return;
            }

            if (localRoom.gudoClientStep === 'selectTarget') {
              socket.emit(
                'gudoSelectTarget',
                { roomId: localRoom.id, x, y },
                (res) => {
                  if (res.ok) {
                    setHighlightGudo([]);
                    setHighlightGudoTargets(res.emptyAround || []);
                    localRoom.gudoClientStep = 'selectMove';
                  } else {
                    alert(res.message);
                    setGudoMode(false);
                    setHighlightGudo([]);
                    setHighlightGudoTargets([]);
                    setHighlightGudoSelf([]);
                    localRoom.gudoClientStep = 'idle';
                  }
                }
              );
              return;
            }

            if (localRoom.gudoClientStep === 'selectMove') {
              socket.emit(
                'gudoMovePiece',
                { roomId: localRoom.id, x, y },
                (res) => {
                  if (!res.ok) alert(res.message);
                }
              );
              return;
            }
          }

          // ===== ‰∏ÄËà¨ËêΩÂ≠ê =====
          socket.emit('place', { roomId: room.id, x, y }, (res) => {
            if (!res.ok && res.message) alert(res.message);
          });
        }

        function activateGinyu() {
          audioRef.current?.uiClick();
          socket.emit('ginyuAbilityStart', { roomId: room.id }, (res) => {
            if (res.ok) {
              setGinyuMode(true);
              setHighlightSources(res.sources);
            } else alert(res.message);
          });
        }

        function activateGudo() {
          audioRef.current?.uiClick();
          socket.emit('gudoAbilityStart', { roomId: room.id }, (res) => {
            if (res.ok) {
              setGudoMode(true);
              setHighlightGudo([]);
              setHighlightGudoTargets([]);
              setHighlightGudoSelf(res.sources || []);
              if (roomRef.current) roomRef.current.gudoClientStep = 'idle';
            } else alert(res.message);
          });
        }

        function activateJeice() {
          audioRef.current?.uiClick();
          socket.emit('jeiceAbilityStart', { roomId: room.id }, (res) => {
            if (res?.ok) {
              setJeiceMode(true);
              setJeiceStep('place');
              setHighlightJeiceTargets([]);
              setHighlightJeiceSource(null);
            } else {
              alert(res?.message || 'ÁÑ°Ê≥ïÁôºÂãïÂêâÊñØËÉΩÂäõ');
            }
          });
        }

        const me = room?.players?.find((p) => p.id === socket?.id);
        const isMyTurn =
          room &&
          me &&
          room.turnIndex !== undefined &&
          room.players[room.turnIndex]?.id === me.id;

        const activeSlot = room?.mode === 'DUAL' ? room.turnSlot || 1 : 1;
        const myActiveRoleIndex = isMyTurn
          ? getPlayerRoleIndex(room, me, activeSlot)
          : null;

        const canStart =
          room &&
          room.hostId === socket?.id &&
          room.players &&
          room.players.length > 0 &&
          room.players.every((p) => p.ready);

        const boardToRender = postGame?.finalBoard
          ? postGame.finalBoard
          : board;

        const size = boardToRender?.length || 15;

        // ‚úÖ ÊâãÊ©üÔºö‰æùÂèØÁî®È´òÂ∫¶Ë®àÁÆó cellSizeÔºåÊ£ãÁõ§Áõ°ÈáèÂêÉÊªø‰∏äÊñπÁ©∫Èñì
        const cellSize = React.useMemo(() => {
          if (!isGameMobile) return 28;
          const dockApprox = 230; // ‰º∞Ë®à‰∏ãÊñπ Dock È´òÂ∫¶
          const topAvailH = Math.max(220, vp.h - dockApprox);
          const maxCellW = Math.floor((vp.w - 28) / size);
          const maxCellH = Math.floor((topAvailH - 28) / size);
          const c = Math.min(maxCellW, maxCellH);
          return clamp(c, 22, 34);
        }, [isGameMobile, vp.w, vp.h, size]);

        const pieceSize = React.useMemo(() => {
          // Ëàá CSS ÂÖßÊØî‰æã‰∏ÄËá¥ÔºåÈÅøÂÖçÂ§™Â∞èÊàñÂ§™Â§ß
          return clamp(Math.round(cellSize * 0.78), 18, 28);
        }, [cellSize]);

        // ======= UI =======
        const inRoom = !!room?.id;

        // ‚úÖ ËÆì body ÁöÑ topBar Âú®ÊâãÊ©üÂ∞çÂ±ÄÊôÇÈö±Ëóè
        const rootClass = 'appRoot' + (isGameMobile ? ' isGameMobile' : '');

        return e(
          'div',
          { className: rootClass },

          // ===== TopBarÔºàÊâãÊ©üÂ∞çÂ±ÄÊúÉË¢´ CSS Èö±ËóèÔºâ=====
          e(
            'div',
            { className: 'topBar' },
            e(
              'div',
              { className: 'brand' },
              e(
                'div',
                { className: 'title' },
                inRoom
                  ? view === 'GAME'
                    ? `Âü∫Á¥êÊ£ãÔΩúÂ∞çÂ±Ä‰∏≠Ôºà${
                        room?.mode === 'DUAL' ? 'DUAL' : 'SINGLE'
                      }Ôºâ`
                    : `Âü∫Á¥êÊ£ãÔΩúÊàøÈñìÔºà${
                        room?.mode === 'DUAL' ? 'DUAL' : 'SINGLE'
                      }Ôºâ`
                  : 'Âü∫Á¥êÊ£ãÔΩúÂª∫Á´ãÊàñÂä†ÂÖ•ÊàøÈñì'
              ),
              e(
                'div',
                { className: 'sub' },
                inRoom
                  ? e(
                      React.Fragment,
                      null,
                      e('span', null, `ÊàøÈñìÔºö${room.id}`),
                      e(
                        'button',
                        {
                          className: 'tinyBtn ' + (copied ? 'copied' : ''),
                          onClick: onCopyRoomId,
                          title: '‰∏ÄÈçµË§áË£ΩÊàøÈñìÁ∑®Ëôü',
                        },
                        copied ? 'Â∑≤Ë§áË£Ω' : 'Ë§áË£Ω'
                      ),
                      e(
                        'button',
                        {
                          className: 'tinyBtn',
                          onClick: leaveRoom,
                          title: 'ÈÄÄÂá∫Ê≠§ÊàøÈñìÔºàÂõûÂà∞Âª∫Á´ã/Âä†ÂÖ•Áï´Èù¢Ôºâ',
                        },
                        'ÈÄÄÂá∫ÊàøÈñì'
                      )
                    )
                  : 'Âª∫Á´ãÊàñÂä†ÂÖ•ÊàøÈñìÈñãÂßãÈÅäÁé©'
              )
            ),
            e(
              'div',
              { className: 'row' },
              e('div', { className: 'pill' }, socket?.id ? `‰Ω†Â∑≤ÈÄ£Á∑ö` : 'ÈÄ£Á∑ö‰∏≠‚Ä¶'),
              e(
                'button',
                {
                  className: 'tinyBtn',
                  onClick: handleAudioButton,
                  title: 'Èü≥ÊïàÊéßÂà∂ÔºàÂïüÁî® / ÈùúÈü≥Ôºâ',
                },
                audioBtnLabel()
              )
            )
          ),

          // ===== ENTRYÔºöÂè™ÊúâÊú™ÈÄ≤ÊàøÊâçÈ°ØÁ§∫Âª∫Á´ã/Âä†ÂÖ• =====
          view === 'ENTRY' &&
            e(
              'div',
              { className: 'screen grid' },
              e(
                'div',
                { className: 'card panelPad grid' },
                e('div', { className: 'label' }, 'ÂêçÁ®±'),
                e('input', {
                  value: name,
                  onChange: (ev) => setName(ev.target.value),
                  placeholder: 'Ëº∏ÂÖ•ÂêçÁ®±ÔºàÂøÖÂ°´Ôºâ',
                }),
                e(
                  'div',
                  { className: 'row', style: { flexWrap: 'wrap' } },
                  e(
                    'button',
                    {
                      onClick: () => createRoom('SINGLE'),
                      disabled: !name.trim(),
                    },
                    'Âª∫Á´ãÊàøÈñìÔºöÂñÆ‰∫∫Ê®°Âºè'
                  ),
                  e(
                    'button',
                    {
                      onClick: () => createRoom('DUAL'),
                      disabled: !name.trim(),
                    },
                    'Âª∫Á´ãÊàøÈñìÔºöÈõô‰∫∫Ê®°Âºè'
                  ),
                  e(
                    'button',
                    { onClick: joinRoom, disabled: !name.trim() },
                    'Âä†ÂÖ•ÊàøÈñì'
                  )
                ),
                e(
                  'div',
                  { className: 'hint' },
                  'ÈÄ≤ÊàøÂæåÂ∞áÈö±ËóèÂª∫Á´ã/Âä†ÂÖ•ÊåâÈàïÔºàÈò≤ÂëÜÔºâÔºåÂè™‰øùÁïôÊàøËôüË§áË£ΩËàáÈÄÄÂá∫ÊàøÈñì„ÄÇ'
                )
              )
            ),

          // ===== ROOMÔºöÊàøÂÖß Lobby =====
          view === 'ROOM' &&
            inRoom &&
            e(
              'div',
              { className: 'screen twoCols' },

              e(
                'div',
                { className: 'card panelPad grid' },
                e(
                  'div',
                  { style: { fontWeight: 1000, marginBottom: 6 } },
                  room?.status === 'LOBBY'
                    ? 'ÊàøÈñìË®≠ÂÆöÔºàLobbyÔºâ'
                    : 'ÊàøÈñìÔºàÁ≠âÂæÖÂõûÂà∞ Lobby‚Ä¶Ôºâ'
                ),

                room?.status !== 'LOBBY'
                  ? e(
                      'div',
                      { className: 'hint' },
                      'ÁõÆÂâç‰∏çÂú® Lobby ÁãÄÊÖãÔºàÂèØËÉΩÊ≠£Âú®Â∞çÂ±ÄÊàñË≥ΩÂæåÂÄíÊï∏ÔºâÔºåÁ®çÂæåÊúÉËá™ÂãïÂõûÂà∞ Lobby ËÆìÂ§ßÂÆ∂ÈáçÈÅ∏„ÄÇ'
                    )
                  : null,

                room?.status === 'LOBBY' &&
                  e(
                    React.Fragment,
                    null,
                    e('div', { className: 'label' }, 'È°èËâ≤'),
                    e(
                      'div',
                      { className: 'rowWrap' },
                      COLORS.map((c, i) =>
                        e('div', {
                          key: i,
                          className: 'choice',
                          onClick: () => pickColor(i),
                          style: {
                            background: c,
                            outline:
                              selectedColor === i
                                ? '2px solid rgba(255,255,255,0.9)'
                                : 'none',
                          },
                        })
                      )
                    ),

                    e(
                      'div',
                      { className: 'label', style: { marginTop: 10 } },
                      room?.mode === 'DUAL'
                        ? 'ËßíËâ≤ÔºàDUALÔºöËßíËâ≤1 / ËßíËâ≤2Ôºâ'
                        : 'ËßíËâ≤'
                    ),

                    room?.mode === 'DUAL'
                      ? e(
                          'div',
                          { className: 'row', style: { flexWrap: 'wrap' } },
                          e(
                            'button',
                            { onClick: () => openRoleSelect(1) },
                            selectedRole1 === null
                              ? 'ÈÅ∏ÊìáËßíËâ≤1ÔºàÂÖ®Ëû¢ÂπïÔºâ'
                              : `ËßíËâ≤1Ôºö${ROLES[selectedRole1]?.name}ÔºàÈáçÈÅ∏Ôºâ`
                          ),
                          e(
                            'button',
                            { onClick: () => openRoleSelect(2) },
                            selectedRole2 === null
                              ? 'ÈÅ∏ÊìáËßíËâ≤2ÔºàÂÖ®Ëû¢ÂπïÔºâ'
                              : `ËßíËâ≤2Ôºö${ROLES[selectedRole2]?.name}ÔºàÈáçÈÅ∏Ôºâ`
                          )
                        )
                      : e(
                          'button',
                          { onClick: () => openRoleSelect(1) },
                          selectedRole1 === null
                            ? 'ÈÅ∏ÊìáËßíËâ≤ÔºàÂÖ®Ëû¢ÂπïÔºâ'
                            : `Â∑≤ÈÅ∏Ôºö${ROLES[selectedRole1]?.name}ÔºàÈªûÊàëÈáçÈÅ∏Ôºâ`
                        ),

                    room?.mode === 'DUAL'
                      ? e(
                          React.Fragment,
                          null,
                          e(
                            'div',
                            { className: 'hint' },
                            `ËßíËâ≤1ÊäÄËÉΩÔºö${
                              selectedRole1 !== null
                                ? ROLES[selectedRole1]?.desc
                                : '‚Äî'
                            }`
                          ),
                          e(
                            'div',
                            { className: 'hint' },
                            `ËßíËâ≤2ÊäÄËÉΩÔºö${
                              selectedRole2 !== null
                                ? ROLES[selectedRole2]?.desc
                                : '‚Äî'
                            }`
                          )
                        )
                      : selectedRole1 !== null &&
                          e(
                            'div',
                            { className: 'hint' },
                            `ÊäÄËÉΩÔºö${ROLES[selectedRole1]?.desc || ''}`
                          ),

                    e(
                      'div',
                      { className: 'row', style: { marginTop: 10 } },
                      e('button', { onClick: readyUp }, 'Ê∫ñÂÇôÂÆåÊàê'),
                      canStart &&
                        e(
                          'button',
                          {
                            onClick: startGame,
                            style: {
                              background:
                                'linear-gradient(135deg, rgba(76,175,80,0.38), rgba(76,175,80,0.18))',
                              border: '1px solid rgba(255,255,255,0.18)',
                            },
                          },
                          'Start Game'
                        )
                    )
                  )
              ),

              e(
                'div',
                { className: 'card panelPad grid' },
                e('div', { className: 'label' }, 'Áé©ÂÆ∂ÂàóË°®'),
                room.players &&
                  room.players.map((p) => {
                    let roleText = 'ÈÅ∏Ëßí‰∏≠';
                    if (room?.mode === 'DUAL') {
                      const r1 =
                        typeof p.roleIndex1 === 'number'
                          ? ROLES[p.roleIndex1]?.name
                          : null;
                      const r2 =
                        typeof p.roleIndex2 === 'number'
                          ? ROLES[p.roleIndex2]?.name
                          : null;
                      if (r1 || r2) {
                        roleText = `ËßíËâ≤1Ôºö${r1 || '‚Äî'}ÔΩúËßíËâ≤2Ôºö${r2 || '‚Äî'}`;
                      }
                    } else {
                      const rn =
                        typeof p.roleIndex === 'number'
                          ? ROLES[p.roleIndex]?.name
                          : null;
                      roleText = rn ? rn : 'ÈÅ∏Ëßí‰∏≠';
                    }

                    const color =
                      typeof p.colorIndex === 'number'
                        ? COLORS[p.colorIndex]
                        : 'rgba(255,255,255,0.25)';

                    return e(
                      'div',
                      { key: p.id, className: 'playerLine' },
                      e(
                        'div',
                        { className: 'playerLeft' },
                        e('div', {
                          className: 'dot',
                          style: { background: color },
                        }),
                        e(
                          'div',
                          { style: { minWidth: 0 } },
                          e(
                            'div',
                            { className: 'playerName' },
                            p.name || 'Player'
                          ),
                          e('div', { className: 'playerMeta' }, roleText)
                        )
                      ),
                      e(
                        'div',
                        { className: 'badge' },
                        p.ready ? '‚úÖ Ready' : '‚Ä¶'
                      )
                    );
                  })
              )
            ),

          // ===== GAMEÔºàÊâãÊ©üÔºöÂõ∫ÂÆö‰∏äÊ£ãÁõ§/‰∏ãDockÔºâ=====
          view === 'GAME' &&
            (isGameMobile
              ? e(
                  'div',
                  { className: 'gameShell' },
                  e(
                    'div',
                    { className: 'gameBoardArea' },
                    e(
                      'div',
                      { className: 'card gameBoardCard' },
                      boardToRender.length > 0
                        ? e(Board, {
                            board: boardToRender,
                            onPlace: place,
                            room,
                            highlightSources,
                            highlightTargets,
                            highlightGudo,
                            highlightGudoTargets,
                            highlightGudoSelf,
                            highlightJeiceTargets,
                            highlightJeiceSource,
                            fx,
                            cellSize,
                            pieceSize,
                          })
                        : e('div', null, 'Â∞öÊú™ÈñãÂßãÈÅäÊà≤')
                    )
                  ),
                  e(
                    'div',
                    { className: 'gameDock' },

                    // ÊàøÈñì/Ë§áË£Ω/Èü≥Êïà/ÈÄÄÂá∫
                    e(
                      'div',
                      { className: 'dockRow' },
                      e(
                        'div',
                        { className: 'dockLeft' },
                        e(
                          'div',
                          { className: 'pill' },
                          `ÊàøÈñìÔºö${room?.id || '--'}`
                        ),
                        e(
                          'button',
                          {
                            className: 'tinyBtn ' + (copied ? 'copied' : ''),
                            onClick: onCopyRoomId,
                          },
                          copied ? 'Â∑≤Ë§áË£Ω' : 'Ë§áË£Ω'
                        )
                      ),
                      e(
                        'div',
                        { className: 'dockRight' },
                        e(
                          'button',
                          {
                            className: 'tinyBtn',
                            onClick: handleAudioButton,
                            title: 'Èü≥ÊïàÊéßÂà∂ÔºàÂïüÁî® / ÈùúÈü≥Ôºâ',
                          },
                          audioBtnLabel()
                        ),
                        e(
                          'button',
                          { className: 'tinyBtn', onClick: leaveRoom },
                          'ÈÄÄÂá∫ÊàøÈñì'
                        )
                      )
                    ),

                    // ÂõûÂêàË≥áË®ä
                    turnMeta
                      ? e(
                          'div',
                          {
                            className: 'pill turnPill',
                            style: { marginTop: 10, width: '100%' },
                          },
                          e('div', {
                            className: 'turnDot',
                            style: { background: turnMeta.color },
                          }),
                          e(
                            'div',
                            { className: 'turnIcon' },
                            e('div', {
                              className: turnMeta.shape || 'circle',
                              style: { color: turnMeta.color },
                            })
                          ),
                          e(
                            'div',
                            null,
                            e(
                              'div',
                              { className: 'turnText' },
                              `Ëº™Âà∞Ôºö${turnMeta.playerName}`
                            ),
                            e(
                              'div',
                              { className: 'turnSub' },
                              `ÂõûÂêàÔºö${turnMeta.round}ÔΩúËßíËâ≤${
                                room?.mode === 'DUAL' ? turnMeta.slot : 1
                              }Ôºö${turnMeta.roleName}`
                            )
                          )
                        )
                      : null,

                    // ÊäÄËÉΩÊåâÈàï
                    e(
                      'div',
                      { className: 'dockBtns' },
                      isMyTurn && myActiveRoleIndex === 0
                        ? e(
                            'button',
                            {
                              onClick: activateGinyu,
                              style: {
                                background: 'rgba(156,39,176,0.35)',
                              },
                            },
                            'Âü∫Á¥êËÉΩÂäõ'
                          )
                        : null,
                      isMyTurn && myActiveRoleIndex === 4
                        ? e(
                            'button',
                            {
                              onClick: activateGudo,
                              style: { background: 'rgba(76,175,80,0.35)' },
                            },
                            'Âè§ÊùúËÉΩÂäõ'
                          )
                        : null,
                      isMyTurn && myActiveRoleIndex === 5
                        ? e(
                            'button',
                            {
                              onClick: activateJeice,
                              style: { background: 'rgba(255,40,40,0.30)' },
                            },
                            jeiceMode
                              ? jeiceStep === 'place'
                                ? 'ÂêâÊñØÔºöË´ãÂÖàËêΩÂ≠ê'
                                : 'ÂêâÊñØÔºöÈÅ∏ÊìäÈÄÄÁõÆÊ®ô'
                              : 'ÂêâÊñØËÉΩÂäõ'
                          )
                        : null,
                      isMyTurn && myActiveRoleIndex === 5 && jeiceMode
                        ? e(
                            'button',
                            {
                              onClick: cancelJeice,
                              className: 'ghost',
                            },
                            'ÂèñÊ∂àÂêâÊñØ'
                          )
                        : null
                    ),

                    // ÊèêÁ§∫
                    jeiceMode
                      ? e(
                          'div',
                          { className: 'dockHint' },
                          jeiceStep === 'place'
                            ? 'ÂêâÊñØÔºöÈªûÁ©∫Ê†ºËêΩÂ≠êÔºõËêΩÂ≠êÂæåËã•Áõ∏ÈÑ∞ÊúâÁõÆÊ®ôÔºåÂÜçÈªû 1 È°ÜÊìäÈÄÄ„ÄÇ'
                            : 'ÂêâÊñØÔºöÈªûÁ¥ÖËâ≤ËôõÁ∑öÁõÆÊ®ôÊìäÈÄÄÔºõÈªûÂÖ∂‰ªñÂú∞ÊñπÂèØÊîæÊ£ÑÊìäÈÄÄÔºàËêΩÂ≠ê‰ªçÊúâÊïàÔºâ„ÄÇ'
                        )
                      : e(
                          'div',
                          { className: 'dockHint' },
                          'ÊèêÁ§∫ÔºöÈªûÊ£ãÁõ§‰∏ãÂ≠ê„ÄÇÈúÄË¶ÅËÉΩÂäõÊôÇ‰ΩøÁî®‰∏äÊñπÊåâÈàï„ÄÇ'
                        )
                  )
                )
              : // Ê°åÊ©üÔºöÁ∂≠ÊåÅÂéüÊú¨ÁâàÈù¢
                e(
                  'div',
                  { className: 'screen grid' },
                  e(
                    'div',
                    { className: 'card panelPad' },
                    e(
                      'div',
                      { style: { fontWeight: 1000, marginBottom: 8 } },
                      'Â∞çÂ±Ä'
                    ),
                    turnMeta
                      ? e(
                          'div',
                          {
                            className: 'pill turnPill',
                            style: { display: 'inline-flex' },
                          },
                          e('div', {
                            className: 'turnDot',
                            style: { background: turnMeta.color },
                          }),
                          e(
                            'div',
                            { className: 'turnIcon' },
                            e('div', {
                              className: turnMeta.shape || 'circle',
                              style: { color: turnMeta.color },
                            })
                          ),
                          e(
                            'div',
                            null,
                            e(
                              'div',
                              { className: 'turnText' },
                              `Ëº™Âà∞Ôºö${turnMeta.playerName}`
                            ),
                            e(
                              'div',
                              { className: 'turnSub' },
                              `ÂõûÂêàÔºö${turnMeta.round}ÔΩúËßíËâ≤${
                                room?.mode === 'DUAL' ? turnMeta.slot : 1
                              }Ôºö${turnMeta.roleName}`
                            )
                          )
                        )
                      : null,
                    e(
                      'div',
                      {
                        style: {
                          marginTop: 10,
                          display: 'flex',
                          gap: 10,
                          flexWrap: 'wrap',
                        },
                      },
                      isMyTurn && myActiveRoleIndex === 0
                        ? e(
                            'button',
                            {
                              onClick: activateGinyu,
                              style: { background: 'rgba(156,39,176,0.35)' },
                            },
                            'ÁôºÂãïÂü∫Á¥êËÉΩÂäõ'
                          )
                        : null,
                      isMyTurn && myActiveRoleIndex === 4
                        ? e(
                            'button',
                            {
                              onClick: activateGudo,
                              style: { background: 'rgba(76,175,80,0.35)' },
                            },
                            'ÁôºÂãïÂè§ÊùúËÉΩÂäõ'
                          )
                        : null,
                      isMyTurn && myActiveRoleIndex === 5
                        ? e(
                            'button',
                            {
                              onClick: activateJeice,
                              style: { background: 'rgba(255,40,40,0.30)' },
                            },
                            jeiceMode
                              ? jeiceStep === 'place'
                                ? 'ÂêâÊñØÔºöË´ãÂÖàËêΩÂ≠ê'
                                : 'ÂêâÊñØÔºöÈÅ∏ÊìáÊìäÈÄÄÁõÆÊ®ô'
                              : 'ÁôºÂãïÂêâÊñØËÉΩÂäõ'
                          )
                        : null,
                      isMyTurn && myActiveRoleIndex === 5 && jeiceMode
                        ? e(
                            'button',
                            { onClick: cancelJeice, className: 'ghost' },
                            'ÂèñÊ∂àÂêâÊñØ'
                          )
                        : null,
                      e(
                        'button',
                        {
                          className: 'tinyBtn',
                          onClick: handleAudioButton,
                          title: 'Èü≥ÊïàÊéßÂà∂ÔºàÂïüÁî® / ÈùúÈü≥Ôºâ',
                        },
                        audioBtnLabel()
                      )
                    )
                  ),
                  e(
                    'div',
                    { className: 'card boardWrap' },
                    boardToRender.length > 0
                      ? e(Board, {
                          board: boardToRender,
                          onPlace: place,
                          room,
                          highlightSources,
                          highlightTargets,
                          highlightGudo,
                          highlightGudoTargets,
                          highlightGudoSelf,
                          highlightJeiceTargets,
                          highlightJeiceSource,
                          fx,
                          cellSize: 28,
                          pieceSize: 22,
                        })
                      : e('div', null, 'Â∞öÊú™ÈñãÂßãÈÅäÊà≤')
                  )
                )),

          // ===== ROLE SCREEN =====
          view === 'ROLE' &&
            e(RoleSelectScreen, {
              room,
              slot: pickingSlot,
              selectedRole:
                room?.mode === 'DUAL'
                  ? pickingSlot === 1
                    ? selectedRole1
                    : selectedRole2
                  : selectedRole1,
              selectedOtherRole:
                room?.mode === 'DUAL'
                  ? pickingSlot === 1
                    ? selectedRole2
                    : selectedRole1
                  : null,
              onClose: () => {
                audioRef.current?.uiClick();
                setView('ROOM');
              },
              onConfirm: confirmRole,
              audio: audioRef.current,
            }),

          // ===== PostGame Overlay =====
          postGame &&
            e(
              'div',
              { className: 'postGame' },
              e(
                'div',
                { className: 'box' },
                e(
                  'div',
                  { className: 'title' },
                  `üèÜ ÂãùÂà©ËÄÖÔºö${postGame.winnerName}`
                ),
                e(
                  'div',
                  { className: 'sub' },
                  `Ê£ãÂ±ÄÂ∞áÂú® ${postGame.secondsLeft} ÁßíÂæåÂõûÂà∞ÊàøÈñì‰∏¶ÈáçÊñ∞ÈÅ∏ËßíÔºàÂèØÂÖàÊåâ‰∏ãÊñπÊåâÈàïÔºâ`
                ),
                e(
                  'button',
                  { className: 'btn', onClick: backToRoom },
                  'ËøîÂõûÊàøÈñì'
                )
              )
            )
        );
      }

      function RoleSelectScreen({
        room,
        slot,
        selectedRole,
        selectedOtherRole,
        onClose,
        onConfirm,
        audio,
      }) {
        const n = ROLES.length;
        const [current, setCurrent] = React.useState(
          typeof selectedRole === 'number' ? selectedRole : 0
        );

        const [lockedIndex, setLockedIndex] = React.useState(null);

        const [dragPx, setDragPx] = React.useState(0);
        const dragPxRef = React.useRef(0);
        const rafRef = React.useRef(0);
        const dragRef = React.useRef({
          down: false,
          x0: 0,
          lastX: 0,
          lastT: 0,
          v: 0,
          pointerId: null,
        });

        const snapPxRef = React.useRef(260);

        React.useEffect(() => {
          const prevOverflow = document.body.style.overflow;
          document.body.style.overflow = 'hidden';
          setupVisualViewportVars();
          const t = setTimeout(() => setupVisualViewportVars(), 0);

          return () => {
            clearTimeout(t);
            document.body.style.overflow = prevOverflow;
            setupVisualViewportVars();
          };
        }, []);

        React.useEffect(() => {
          function recalc() {
            const vw = window.innerWidth || 360;
            const cardW = Math.min(vw * 0.92, 420);
            snapPxRef.current = Math.max(200, Math.min(cardW * 0.78, 320));
          }
          recalc();
          window.addEventListener('resize', recalc);
          return () => window.removeEventListener('resize', recalc);
        }, []);

        // ‚úÖ Ê°åÊ©ü hover / ÊâãÊ©üÊªëÂãïÂàáÊèõÂà∞Ë©≤ËßíËâ≤ ‚Üí Êí≠ÊîæË©≤ËßíËâ≤ÂñäÂêçÈü≥Êïà
        React.useEffect(() => {
          try {
            audio?.playRoleVoice(current);
          } catch (e) {}
        }, [current]);

        function scheduleDragUpdate(px) {
          dragPxRef.current = px;
          if (rafRef.current) return;
          rafRef.current = requestAnimationFrame(() => {
            rafRef.current = 0;
            setDragPx(dragPxRef.current);
          });
        }

        function onPointerDown(ev) {
          dragRef.current.down = true;
          dragRef.current.x0 = ev.clientX;
          dragRef.current.lastX = ev.clientX;
          dragRef.current.lastT = performance.now();
          dragRef.current.v = 0;
          dragRef.current.pointerId = ev.pointerId;
          scheduleDragUpdate(0);
          try {
            ev.currentTarget.setPointerCapture(ev.pointerId);
          } catch (e) {}
        }

        function onPointerMove(ev) {
          if (!dragRef.current.down) return;
          const now = performance.now();
          const dx = ev.clientX - dragRef.current.lastX;
          const dt = Math.max(8, now - dragRef.current.lastT);
          dragRef.current.v = dx / dt;
          dragRef.current.lastX = ev.clientX;
          dragRef.current.lastT = now;

          const total = ev.clientX - dragRef.current.x0;
          scheduleDragUpdate(total);
        }

        function onPointerUp(ev) {
          if (!dragRef.current.down) return;
          dragRef.current.down = false;

          const total = dragPxRef.current;
          const snapPx = snapPxRef.current;
          const progress = clamp(-total / snapPx, -1, 1);
          const v = dragRef.current.v;

          const flick = Math.abs(v) > 0.65;

          if (flick) {
            if (v < 0) setCurrent((c) => (c + 1) % n);
            else setCurrent((c) => (c - 1 + n) % n);
          } else {
            if (progress > 0.28) setCurrent((c) => (c + 1) % n);
            else if (progress < -0.28) setCurrent((c) => (c - 1 + n) % n);
          }

          scheduleDragUpdate(0);

          try {
            ev.currentTarget.releasePointerCapture(ev.pointerId);
          } catch (e) {}
        }

        function shortDelta(i, c) {
          let d = i - c;
          const half = Math.floor(n / 2);
          while (d > half) d -= n;
          while (d < -half) d += n;
          return d;
        }

        const others = (room?.players || []).map((p) => {
          if (room?.mode === 'DUAL') {
            const r1 =
              typeof p.roleIndex1 === 'number'
                ? ROLES[p.roleIndex1]?.name
                : null;
            const r2 =
              typeof p.roleIndex2 === 'number'
                ? ROLES[p.roleIndex2]?.name
                : null;
            return {
              name: p.name || 'Player',
              role: `1:${r1 || '‚Äî'} 2:${r2 || '‚Äî'}`,
            };
          }
          const rn =
            typeof p.roleIndex === 'number' ? ROLES[p.roleIndex]?.name : null;
          return { name: p.name || 'Player', role: rn || 'ÈÅ∏Ëßí‰∏≠' };
        });

        const role = ROLES[current];

        const snapPx = snapPxRef.current;
        const dragProgress = clamp(-dragPx / snapPx, -1, 1);

        const blocked =
          room?.mode === 'DUAL' && typeof selectedOtherRole === 'number'
            ? selectedOtherRole
            : null;

        return e(
          'div',
          { className: 'roleScreen' },

          e(
            'div',
            { className: 'roleTop' },
            e(
              'div',
              { className: 'roleTopLeft' },
              e(
                'div',
                { className: 'brand' },
                e(
                  'div',
                  { className: 'title' },
                  room?.mode === 'DUAL' ? `ÈÅ∏ÊìáËßíËâ≤ÔºàËßíËâ≤${slot}Ôºâ` : 'ÈÅ∏ÊìáËßíËâ≤'
                ),
                e(
                  'div',
                  { className: 'sub' },
                  'ÊâãÊ©üÔºöÊªëÂãïÈÅ∏Âç°ÔΩúÊ°åÊ©üÔºöÈªûÊìäÈéñÂÆöÔºàÈÅøÂÖçÊªëÈº†ÁßªÂãïË™§ÈÅ∏Ôºâ'
                )
              ),
              e(
                'div',
                { className: 'miniList' },
                others.map((o, idx) =>
                  e(
                    'div',
                    { key: idx, className: 'miniChip' },
                    `${o.name}Ôºö${o.role}`
                  )
                )
              )
            ),
            e(
              'button',
              {
                className: 'ghost',
                onClick: () => {
                  audio?.uiClick?.();
                  onClose();
                },
              },
              'ËøîÂõûÊàøÈñì'
            )
          ),

          e(
            'div',
            { className: 'roleMain' },

            e(
              'div',
              {
                className: 'carousel',
                onPointerDown,
                onPointerMove,
                onPointerUp,
              },
              e(
                'div',
                { className: 'carouselInner' },
                ROLES.map((r, i) => {
                  const d = shortDelta(i, current);
                  const de = d - dragProgress;
                  const ae = Math.abs(de);

                  const baseShift = 112;
                  const extra = ae > 1.35 ? 26 : 0;
                  const tx = de * (baseShift + extra);

                  const scale = ae < 0.01 ? 1.0 : ae < 1.0 ? 0.94 : 0.88;
                  const ry = clamp(de, -2, 2) * 12;
                  const rz = clamp(de, -2, 2) * -3.5;

                  const opacity =
                    ae < 0.35 ? 1.0 : ae < 1.2 ? 0.22 : ae < 2.1 ? 0.06 : 0;
                  const blur = ae < 0.35 ? 0 : ae < 1.2 ? 0.6 : 1.2;
                  const sat = ae < 0.35 ? 1.08 : 0.85;
                  const contrast = ae < 0.35 ? 1.06 : 0.95;

                  const isCenter = ae < 0.35;

                  const style = {
                    transform: `translate3d(${tx}%, 0, 0) rotateY(${ry}deg) rotateZ(${rz}deg) scale(${scale})`,
                    opacity,
                    filter: `blur(${blur}px) saturate(${sat}) contrast(${contrast})`,
                    zIndex: 1000 - Math.round(ae * 50),
                    transition: dragRef.current.down
                      ? 'none'
                      : 'transform 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease, filter 220ms ease',
                    pointerEvents: isCenter ? 'auto' : 'none',
                    boxShadow: isCenter
                      ? '0 34px 90px rgba(0,0,0,0.62)'
                      : '0 18px 55px rgba(0,0,0,0.45)',
                    borderColor: isCenter
                      ? 'rgba(255,255,255,0.28)'
                      : 'rgba(255,255,255,0.12)',
                  };

                  if (opacity === 0) {
                    style.transform = `translate3d(${tx}%,0,0) scale(0.72)`;
                  }

                  return e(
                    'div',
                    {
                      key: i,
                      className: 'roleCard',
                      style,
                      onClick: () => {
                        setCurrent(i);
                      },
                    },
                    e(
                      'div',
                      { className: 'roleCardHeader' },
                      e('div', { className: 'roleName' }, r.name),
                      e(
                        'div',
                        { className: 'roleIcon' },
                        e('div', {
                          className: r.shape,
                          style: { color: '#fff' },
                        })
                      )
                    ),
                    e(
                      'div',
                      { className: 'roleDesc' },
                      r.desc,
                      blocked !== null && blocked === i
                        ? 'Ôºà‚ö†Ô∏è ‰Ω†ÁöÑÂè¶‰∏ÄÂÄãËßíËâ≤Â∑≤ÈÅ∏ÈÄôÂÄãÔºå‰∏çËÉΩÈáçË§áÔºâ'
                        : ''
                    ),
                    e(
                      'div',
                      { className: 'roleStats' },
                      e(
                        'div',
                        { className: 'stat' },
                        e('div', null, 'ÂÆö‰Ωç'),
                        e(
                          'b',
                          null,
                          i === 1 || i === 5
                            ? 'ÈÄ≤Êîª'
                            : i === 0 || i === 4
                            ? 'Êìç‰Ωú'
                            : 'ÊéßÂà∂'
                        )
                      ),
                      e(
                        'div',
                        { className: 'stat' },
                        e('div', null, 'ÂõûÂêà'),
                        e('b', null, i === 1 || i === 3 ? 'Â§öÊ≠•' : 'ÂñÆÊ≠•')
                      )
                    )
                  );
                })
              )
            ),

            e(
              'div',
              { className: 'desktopDeck' },
              ROLES.map((r, i) => {
                const active = i === current;
                const cls = 'desktopCard ' + (active ? 'active' : 'dim');
                return e(
                  'div',
                  {
                    key: i,
                    className: cls,
                    onMouseEnter: () => {
                      if (lockedIndex === null) setCurrent(i);
                    },
                    onClick: () => {
                      setCurrent(i);
                      setLockedIndex(i);
                    },
                  },
                  e(
                    'div',
                    { className: 'roleCardHeader' },
                    e('div', { className: 'roleName' }, r.name),
                    e(
                      'div',
                      { className: 'roleIcon' },
                      e('div', { className: r.shape, style: { color: '#fff' } })
                    )
                  ),
                  e(
                    'div',
                    { className: 'roleDesc' },
                    r.desc,
                    blocked !== null && blocked === i
                      ? 'Ôºà‚ö†Ô∏è ‰Ω†ÁöÑÂè¶‰∏ÄÂÄãËßíËâ≤Â∑≤ÈÅ∏ÈÄôÂÄãÔºå‰∏çËÉΩÈáçË§áÔºâ'
                      : ''
                  )
                );
              })
            )
          ),

          e(
            'div',
            { className: 'roleBottom' },
            e(
              'div',
              { className: 'hint', style: { maxWidth: '48%' } },
              lockedIndex === null
                ? `ÁõÆÂâçÈÅ∏ÊìáÔºö${role?.name || '‚Äî'}ÔºàÊ°åÊ©üÔºöÈªû‰∏Ä‰∏ãÂèØÈéñÂÆöÔºâ`
                : `Â∑≤ÈéñÂÆöÔºö${role?.name || '‚Äî'}ÔºàÂèØÈªûÂÖ∂‰ªñÂç°ÊîπÈÅ∏Ôºâ`
            ),
            e(
              'button',
              {
                className: 'confirm',
                disabled: blocked !== null && current === blocked,
                onClick: () => {
                  audio?.uiClick?.();
                  if (blocked !== null && current === blocked) {
                    alert('Âêå‰∏ÄÁé©ÂÆ∂ÁöÑ ËßíËâ≤1 / ËßíËâ≤2 ‰∏çËÉΩÈáçË§á');
                    return;
                  }
                  onConfirm(current);
                },
              },
              room?.mode === 'DUAL' ? `Á¢∫ÂÆöÁÇ∫ ËßíËâ≤${slot}` : 'Á¢∫ÂÆöËßíËâ≤'
            )
          )
        );
      }

      function Board({
        board,
        onPlace,
        room,
        highlightSources,
        highlightTargets,
        highlightGudo,
        highlightGudoTargets,
        highlightGudoSelf,
        highlightJeiceTargets,
        highlightJeiceSource,
        fx,
        cellSize,
        pieceSize,
      }) {
        const size = board.length;
        const cells = [];

        function isFxCell(pos, x, y) {
          return pos && pos.x === x && pos.y === y;
        }

        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const v = board[y][x];

            let className = 'cell';
            if (highlightSources.some((p) => p.x === x && p.y === y))
              className += ' highlight-source';
            if (highlightTargets.some((p) => p.x === x && p.y === y))
              className += ' highlight-target';
            if (highlightGudo.some((p) => p.x === x && p.y === y))
              className += ' highlight-gudo';
            if (highlightGudoTargets.some((p) => p.x === x && p.y === y))
              className += ' highlight-gudo-target';
            if (highlightGudoSelf.some((p) => p.x === x && p.y === y))
              className += ' highlight-gudo-self';

            if (highlightJeiceTargets.some((p) => p.x === x && p.y === y))
              className += ' highlight-jeice-target';
            if (
              highlightJeiceSource &&
              highlightJeiceSource.x === x &&
              highlightJeiceSource.y === y
            )
              className += ' highlight-jeice-source';

            if (isFxCell(fx?.target, x, y)) className += ' fx-shake';
            if (isFxCell(fx?.to, x, y)) className += ' fx-pop';

            let inner = null;

            if (v > 0) {
              const { ownerIndex, slot } = decodeToken(v);
              const player = room.players?.[ownerIndex] || null;
              const color = player ? COLORS[player.colorIndex || 0] : '#fff';
              const roleIdx = getPlayerRoleIndex(room, player, slot);
              const role = ROLES[typeof roleIdx === 'number' ? roleIdx : 0];
              inner = e('div', { className: role.shape, style: { color } });
            } else if (v < 0) {
              const ownerIndex = Math.abs(v) - 1;
              const owner = room.players?.[ownerIndex];
              const baseColor = owner ? COLORS[owner.colorIndex || 0] : '#888';
              const r = Math.round(parseInt(baseColor.slice(1, 3), 16) * 0.6);
              const g = Math.round(parseInt(baseColor.slice(3, 5), 16) * 0.6);
              const b = Math.round(parseInt(baseColor.slice(5, 7), 16) * 0.6);
              const darker = `rgb(${r}, ${g}, ${b})`;
              inner = e('div', {
                className: 'grayX',
                style: { color: darker },
              });
            }

            cells.push(
              e(
                'div',
                { key: `${x},${y}`, className, onClick: () => onPlace(x, y) },
                inner
              )
            );
          }
        }

        function orbStyle(from, to) {
          if (!from || !to) return null;
          const cell = cellSize || 28;
          const piece = pieceSize || 22;
          const pad = (cell - piece) / 2;
          const sx = from.x * cell + pad;
          const sy = from.y * cell + pad;
          const dx = (to.x - from.x) * cell;
          const dy = (to.y - from.y) * cell;
          return {
            left: sx + 'px',
            top: sy + 'px',
            '--dx': dx,
            '--dy': dy,
          };
        }

        const fx1 = fx?.type === 'jeice' ? orbStyle(fx.from, fx.target) : null;
        const fx2 =
          fx?.type === 'jeice' && fx?.to ? orbStyle(fx.target, fx.to) : null;

        const cell = cellSize || 28;
        const piece = pieceSize || 22;

        return e(
          'div',
          {
            className: 'board',
            style: { '--cell': cell + 'px', '--piece': piece + 'px' },
          },
          e(
            'div',
            {
              className: 'boardGrid',
              style: { gridTemplateColumns: `repeat(${size}, ${cell}px)` },
            },
            cells
          ),
          fx?.type === 'jeice'
            ? e(
                'div',
                { className: 'fxLayer' },
                fx1 ? e('div', { className: 'jeiceOrb', style: fx1 }) : null,
                fx2
                  ? e('div', { className: 'jeiceOrb secondary', style: fx2 })
                  : null
              )
            : null
        );
      }

      ReactDOM.createRoot(document.getElementById('app')).render(e(App));
    </script>
  </body>
</html>
