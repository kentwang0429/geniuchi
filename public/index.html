<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>åŸºç´æ£‹ (Geniuchi)</title>
    <style>
      :root {
        --bg: #0b0f19;
        --panel: rgba(255, 255, 255, 0.08);
        --panel2: rgba(255, 255, 255, 0.12);
        --stroke: rgba(255, 255, 255, 0.18);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --shadow: 0 16px 50px rgba(0, 0, 0, 0.45);
        --r: 18px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          Arial, Helvetica, sans-serif;
        margin: 0;
        padding: 0;
        background: radial-gradient(
            1200px 600px at 20% 0%,
            #19223b 0%,
            rgba(11, 15, 25, 0) 55%
          ),
          radial-gradient(
            900px 700px at 100% 0%,
            #173c32 0%,
            rgba(11, 15, 25, 0) 55%
          ),
          var(--bg);
        color: var(--text);
        overscroll-behavior: none;
      }

      button {
        border: 0;
        border-radius: 14px;
        padding: 10px 12px;
        font-weight: 800;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.14);
        color: var(--text);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.25);
      }
      button:active {
        transform: translateY(1px);
      }
      button[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      input {
        width: 100%;
        border-radius: 14px;
        padding: 12px 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
        outline: none;
      }

      .appRoot {
        min-height: 100vh;
        min-height: 100dvh;
        display: flex;
        flex-direction: column;
      }

      .topBar {
        padding: 14px 14px 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .brand {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .brand .title {
        font-size: 16px;
        font-weight: 1000;
        letter-spacing: 0.4px;
      }
      .brand .sub {
        font-size: 12px;
        color: var(--muted);
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      .pill {
        padding: 8px 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.14);
        font-size: 12px;
        color: var(--muted);
      }

      .tinyBtn {
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.16);
        box-shadow: none;
      }
      .tinyBtn.copied {
        background: rgba(76, 175, 80, 0.22);
        border: 1px solid rgba(76, 175, 80, 0.35);
        color: rgba(255, 255, 255, 0.92);
      }

      .screen {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 14px;
        gap: 12px;
      }

      .card {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.13),
          rgba(255, 255, 255, 0.06)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: var(--r);
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      .grid {
        display: grid;
        gap: 12px;
      }

      .twoCols {
        display: grid;
        gap: 12px;
        grid-template-columns: 1fr;
      }
      @media (min-width: 920px) {
        .twoCols {
          grid-template-columns: 360px 1fr;
          align-items: start;
        }
      }

      .panelPad {
        padding: 12px;
      }

      .row {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .rowWrap {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .label {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .choice {
        width: 34px;
        height: 34px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(255, 255, 255, 0.08);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      /* ===== æ£‹å­å½¢ç‹€ ===== */
      .circle {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: currentColor;
      }
      .star::before {
        content: 'â˜…';
        font-size: 26px;
        line-height: 1;
        color: currentColor;
      }
      .square {
        width: 22px;
        height: 22px;
        background: currentColor;
      }
      .triangle {
        width: 0;
        height: 0;
        border-left: 11px solid transparent;
        border-right: 11px solid transparent;
        border-bottom: 20px solid currentColor;
      }
      .logan {
        position: relative;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        border: 2px solid currentColor;
      }
      .logan::before,
      .logan::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 30px;
        height: 3px;
        background: currentColor;
        transform-origin: center;
      }
      .logan::before {
        transform: translate(-50%, -50%) rotate(45deg);
      }
      .logan::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }

      /* ===== æˆ¿é–“ç©å®¶åˆ— ===== */
      .playerLine {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 10px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
      }
      .playerLeft {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
      }
      .dot {
        width: 14px;
        height: 14px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.25);
      }
      .playerName {
        font-weight: 1000;
        max-width: 180px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .playerMeta {
        font-size: 12px;
        color: var(--muted);
      }
      .badge {
        font-size: 12px;
        padding: 6px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
      }

      /* ===== Board ===== */
      .boardWrap {
        padding: 12px;
      }
      .board {
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        display: inline-block;
        border-radius: 14px;
        overflow: hidden;
      }
      .boardGrid {
        display: grid;
      }
      .cell {
        width: 28px;
        height: 28px;
        border: 1px solid rgba(255, 255, 255, 0.06);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        position: relative;
      }
      .highlight-source {
        outline: 2px solid #b84bff;
      }
      .highlight-target {
        outline: 2px dashed #b84bff;
      }
      .highlight-gudo {
        outline: 2px solid #55ffb0;
      }
      .highlight-gudo-target {
        outline: 2px dashed #55ffb0;
      }
      .highlight-gudo-self {
        outline: 2px solid #35c66a;
      }

      .grayX {
        position: relative;
        width: 22px;
        height: 22px;
      }
      .grayX::before,
      .grayX::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 22px;
        height: 4px;
        background: currentColor;
        transform-origin: center;
      }
      .grayX::before {
        transform: translate(-50%, -50%) rotate(45deg);
      }
      .grayX::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }

      /* ===== é¸è§’ï¼šå…¨è¢å¹• ===== */
      .roleScreen {
        position: fixed;
        inset: 0;
        z-index: 50;
        background: radial-gradient(
            900px 700px at 30% 0%,
            rgba(76, 175, 80, 0.18) 0%,
            rgba(0, 0, 0, 0) 55%
          ),
          radial-gradient(
            800px 800px at 90% 10%,
            rgba(156, 39, 176, 0.18) 0%,
            rgba(0, 0, 0, 0) 55%
          ),
          var(--bg);
        display: flex;
        flex-direction: column;
      }

      .roleTop {
        padding: 14px;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
      }

      .roleTopLeft {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-width: 70vw;
      }

      .miniList {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .miniChip {
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.08);
        color: var(--muted);
        white-space: nowrap;
      }

      .roleMain {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 12px;
        padding: 0 12px;
      }

      .roleBottom {
        padding: 14px;
        display: flex;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      .confirm {
        flex: 1;
        padding: 14px 14px;
        border-radius: 16px;
        background: linear-gradient(
          135deg,
          rgba(79, 172, 254, 0.35),
          rgba(0, 242, 254, 0.18)
        );
        border: 1px solid rgba(255, 255, 255, 0.18);
      }

      .ghost {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }

      /* ===== æ‰‹æ©Ÿï¼šæ»‘å‹•é¸å¡ï¼ˆä¸­å¿ƒå¤§ã€å·¦å³åªéœ²é‚Šæ¡†ã€ä¸æ“‹ä¸­é–“ã€æ›´é †ï¼‰ ===== */
      .carousel {
        position: relative;
        height: min(520px, 66vh);
        overflow: hidden;
        /* é‡è¦ï¼šå®Œå…¨äº¤çµ¦æˆ‘å€‘è™•ç†æ‰‹å‹¢ï¼Œé¿å…é é¢è·Ÿè‘—æ»‘ */
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
      }
      /* å·¦å³é®ç½©ï¼šè®“æ—é‚Šå¡æ·¡å‡ºï¼Œåªéœ²é‚Šé‚Š */
      .carousel::before,
      .carousel::after {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        width: 64px;
        z-index: 6;
        pointer-events: none;
      }
      .carousel::before {
        left: 0;
        background: linear-gradient(
          90deg,
          rgba(11, 15, 25, 0.92),
          rgba(11, 15, 25, 0)
        );
      }
      .carousel::after {
        right: 0;
        background: linear-gradient(
          270deg,
          rgba(11, 15, 25, 0.92),
          rgba(11, 15, 25, 0)
        );
      }

      .carouselInner {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        perspective: 900px;
      }

      .roleCard {
        position: absolute;
        width: min(92vw, 420px);
        height: min(56vh, 460px);
        border-radius: 22px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.16),
          rgba(255, 255, 255, 0.06)
        );
        border: 1px solid rgba(255, 255, 255, 0.14);
        box-shadow: 0 28px 80px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        transform-origin: center;
        /* é‡è¦ï¼šéä¸­å¿ƒå¡ä¸åƒäº‹ä»¶ï¼Œé¿å…æ“‹ä½ä¸­é–“ / å½±éŸ¿æ»‘å‹• */
        pointer-events: none;
        will-change: transform, opacity, filter;
        backface-visibility: hidden;
        transform-style: preserve-3d;
      }

      .roleCardHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .roleName {
        font-size: 22px;
        font-weight: 1000;
        letter-spacing: 0.6px;
      }
      .roleIcon {
        width: 46px;
        height: 46px;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(0, 0, 0, 0.15);
      }
      .roleDesc {
        color: var(--muted);
        font-size: 14px;
        line-height: 1.45;
      }
      .roleStats {
        margin-top: auto;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .stat {
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
        padding: 10px;
        font-size: 12px;
        color: var(--muted);
      }
      .stat b {
        color: var(--text);
      }

      /* æ¡Œæ©Ÿï¼šæ»¿ç‰ˆä¸¦æ’å¤§å¡ï¼ˆhover æ”¾å¤§ï¼Œå…¶ä»–æ·¡åŒ–ï¼›é»æ“Šå¾Œé–å®šï¼‰ */
      .desktopDeck {
        display: none;
        height: min(520px, 70vh);
        gap: 14px;
        padding: 6px;
      }
      .desktopCard {
        flex: 1;
        border-radius: 22px;
        padding: 18px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.15),
          rgba(255, 255, 255, 0.06)
        );
        box-shadow: 0 28px 80px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        gap: 10px;
        transition: transform 220ms ease, filter 220ms ease, opacity 220ms ease;
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      .desktopCard::after {
        content: '';
        position: absolute;
        inset: -2px;
        border-radius: 24px;
        border: 2px solid rgba(255, 255, 255, 0);
        transition: border-color 220ms ease;
        pointer-events: none;
      }
      .desktopCard.active {
        transform: scale(1.06);
        filter: saturate(1.15) contrast(1.05);
      }
      .desktopCard.active::after {
        border-color: rgba(255, 255, 255, 0.4);
      }
      .desktopCard.dim {
        opacity: 0.55;
        filter: grayscale(0.2) saturate(0.8);
      }

      @media (hover: hover) and (pointer: fine) {
        .carousel {
          display: none;
        }
        .desktopDeck {
          display: flex;
        }
      }

      @media (max-width: 420px) {
        .roleName {
          font-size: 20px;
        }
        .roleCard {
          padding: 16px;
        }
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
      }

      /* ===== è³½å¾Œä¿ç•™æ£‹ç›¤ 10 ç§’ Overlay ===== */
      .postGame {
        position: fixed;
        inset: 0;
        z-index: 60;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding: 14px;
        pointer-events: none;
      }
      .postGame .box {
        width: min(720px, 100%);
        background: rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 18px;
        padding: 14px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        pointer-events: auto;
      }
      .postGame .box .title {
        font-weight: 1000;
        font-size: 14px;
        margin-bottom: 6px;
      }
      .postGame .box .sub {
        color: rgba(255, 255, 255, 0.78);
        font-size: 12px;
        line-height: 1.4;
        margin-bottom: 12px;
      }
      .postGame .box .btn {
        width: 100%;
        padding: 14px 12px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.16);
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/socket.io/client-dist/socket.io.min.js"></script>

    <script>
      const e = React.createElement;

      const COLORS = [
        '#e53935',
        '#8e24aa',
        '#3949ab',
        '#1e88e5',
        '#00897b',
        '#fdd835',
      ];

      const ROLES = [
        {
          name: 'åŸºç´',
          shape: 'circle',
          desc: 'å›åˆé–‹å§‹å¯äº¤æ›ï¼šé¸è‡ªå·±çš„åŸºç´æ£‹ï¼Œèˆ‡åŒè¡Œ/åŒåˆ—çš„ä»»ä¸€æ•µæ–¹æ£‹äº¤æ›ã€‚',
        },
        {
          name: 'å·´ç‰¹',
          shape: 'star',
          desc: 'æ¯å›åˆå¯ä¸‹å…©å­ï¼›ä½†å‹åˆ©éœ€è¦ 6 é€£ç·šã€‚',
        },
        {
          name: 'åŠ›åº«å§†',
          shape: 'square',
          desc: 'å¯è¦†è“‹ä¸€èˆ¬æ£‹ï¼ˆä¸èƒ½è¦†è“‹å‰å‰ï¼‰ã€‚',
        },
        {
          name: 'ç¾…æ ¹',
          shape: 'logan',
          desc: 'æ¯å›åˆå…©æ­¥ï¼šç¬¬ 1 æ­¥ä¸‹æ­£å¸¸æ£‹ï¼Œç¬¬ 2 æ­¥ä¸‹ç°å‰ã€‚',
        },
        {
          name: 'å¤æœ',
          shape: 'triangle',
          desc: 'å›åˆé–‹å§‹å¯ç§»å‹•ï¼šé¸è‡ªå·±çš„å¤æœæ£‹ï¼Œé¸å‘¨åœä¸€æ ¼çš„æ•µæ–¹æ£‹ï¼Œå°‡å…¶ç§»åˆ°è©²æ£‹å‘¨åœç©ºæ ¼ã€‚',
        },
      ];

      function connectSocket() {
        const params = new URLSearchParams(location.search);
        const serverUrl = params.get('server');
        if (serverUrl)
          return io(serverUrl, { transports: ['websocket', 'polling'] });
        return io();
      }

      function deepCopyBoard(b) {
        return Array.isArray(b) ? b.map((row) => row.slice()) : [];
      }

      function copyText(text) {
        if (!text) return Promise.resolve(false);
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard
            .writeText(String(text))
            .then(() => true)
            .catch(() => false);
        }
        return new Promise((resolve) => {
          try {
            const ta = document.createElement('textarea');
            ta.value = String(text);
            ta.style.position = 'fixed';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            const ok = document.execCommand('copy');
            document.body.removeChild(ta);
            resolve(!!ok);
          } catch (e) {
            resolve(false);
          }
        });
      }

      function App() {
        const [socket, setSocket] = React.useState(null);
        const [view, setView] = React.useState('HOME'); // HOME | ROLE | GAME

        const [room, setRoom] = React.useState(null);
        const [board, setBoard] = React.useState([]);
        const [name, setName] = React.useState('');

        const [selectedColor, setSelectedColor] = React.useState(null);
        const [selectedRole, setSelectedRole] = React.useState(null);

        const [highlightSources, setHighlightSources] = React.useState([]);
        const [highlightTargets, setHighlightTargets] = React.useState([]);
        const [highlightGudo, setHighlightGudo] = React.useState([]);
        const [highlightGudoTargets, setHighlightGudoTargets] = React.useState(
          []
        );
        const [highlightGudoSelf, setHighlightGudoSelf] = React.useState([]);

        const [ginyuMode, setGinyuMode] = React.useState(false);
        const [gudoMode, setGudoMode] = React.useState(false);
        const [turnInfo, setTurnInfo] = React.useState('');

        const [copied, setCopied] = React.useState(false);

        // âœ… è³½å¾Œä¿ç•™ 10 ç§’ï¼ˆä¿ç•™çµ‚å±€æ£‹ç›¤ï¼‰
        const [postGame, setPostGame] = React.useState(null); // { winnerName, secondsLeft, finalBoard }
        const postGameTimerRef = React.useRef(null);

        const roomRef = React.useRef(null);

        React.useEffect(() => {
          const s = connectSocket();
          setSocket(s);

          s.on('roomUpdated', (r) => {
            roomRef.current = r;
            setRoom(r);

            // è³½å¾Œ 10 ç§’æœŸé–“ï¼šä¸è¦è¢« roomUpdated æ‹‰å›å¤§å»³ï¼Œä¹Ÿä¸è¦è¦†è“‹æ£‹ç›¤
            if (!postGame) {
              setBoard(r.board || []);
              if (r?.status === 'PLAYING') setView('GAME');
              else if (r?.status === 'LOBBY') setView('HOME');
            }

            updateTurnInfo(r);
          });

          s.on('placed', (payload) => {
            // è³½å¾Œ 10 ç§’æœŸé–“ï¼šä¿æŒçµ‚å±€æ£‹ç›¤
            if (!postGame && payload.board) setBoard(payload.board);

            if (roomRef.current) {
              roomRef.current = {
                ...roomRef.current,
                board: payload.board || roomRef.current.board,
                turnIndex:
                  typeof payload.turnIndex === 'number'
                    ? payload.turnIndex
                    : roomRef.current.turnIndex,
                roundCount:
                  typeof payload.roundCount === 'number'
                    ? payload.roundCount
                    : roomRef.current.roundCount,
                status: payload.status || roomRef.current.status,
              };
            }

            setRoom((prev) => {
              const base = prev || roomRef.current;
              if (!base) return base;
              return {
                ...base,
                board: payload.board || base.board,
                turnIndex:
                  typeof payload.turnIndex === 'number'
                    ? payload.turnIndex
                    : base.turnIndex,
                roundCount:
                  typeof payload.roundCount === 'number'
                    ? payload.roundCount
                    : base.roundCount,
                status: payload.status || base.status,
              };
            });

            if (payload.win) {
              const r = roomRef.current;
              const winner = r?.players?.[payload.win.winnerIndex];
              const winnerName = winner ? winner.name : payload.win.winnerId;

              const finalBoard = deepCopyBoard(payload.board || board);
              startPostGame(winnerName, finalBoard);
            }

            setHighlightSources([]);
            setHighlightTargets([]);
            setHighlightGudo([]);
            setHighlightGudoTargets([]);
            setHighlightGudoSelf([]);
            setGinyuMode(false);
            setGudoMode(false);
            if (roomRef.current) roomRef.current.gudoClientStep = 'idle';

            updateTurnInfo(roomRef.current);
          });

          s.on('gudoCancelled', () => {
            setHighlightGudo([]);
            setHighlightGudoTargets([]);
            setHighlightGudoSelf([]);
            setGudoMode(false);
            if (roomRef.current) roomRef.current.gudoClientStep = 'idle';
          });

          s.on('ginyuCancelled', (payload) => {
            setHighlightSources([]);
            setHighlightTargets([]);
            setGinyuMode(false);
            if (payload?.message) alert(payload.message);
          });

          return () => {
            try {
              s.disconnect();
            } catch (e) {}
          };
        }, [postGame]);

        React.useEffect(() => {
          return () => {
            if (postGameTimerRef.current)
              clearInterval(postGameTimerRef.current);
          };
        }, []);

        function updateTurnInfo(r) {
          if (!r || !r.players || r.status !== 'PLAYING') {
            setTurnInfo('');
            return;
          }
          const turnPlayer = r.players[r.turnIndex];
          setTurnInfo(
            `å›åˆï¼š${r.roundCount || 1}ï½œè¼ªåˆ°ï¼š${turnPlayer?.name || 'N/A'}`
          );
        }

        function startPostGame(winnerName, finalBoard) {
          if (postGameTimerRef.current) clearInterval(postGameTimerRef.current);

          setPostGame({ winnerName, secondsLeft: 10, finalBoard });

          let left = 10;
          postGameTimerRef.current = setInterval(() => {
            left -= 1;
            setPostGame((pg) => (pg ? { ...pg, secondsLeft: left } : pg));
            if (left <= 0) {
              clearInterval(postGameTimerRef.current);
              postGameTimerRef.current = null;
              backToRoom();
            }
          }, 1000);
        }

        function backToRoom() {
          if (postGameTimerRef.current) {
            clearInterval(postGameTimerRef.current);
            postGameTimerRef.current = null;
          }
          setPostGame(null);
          setView('HOME');
        }

        function onCopyRoomId() {
          if (!room?.id) return;
          copyText(String(room.id)).then((ok) => {
            if (!ok) return;
            setCopied(true);
            setTimeout(() => setCopied(false), 1200);
          });
        }

        function createRoom() {
          socket.emit(
            'createRoom',
            { maxPlayers: 4, name: name.trim() },
            (res) => {
              if (res.ok) {
                setRoom(res.room);
                setView('HOME');
              } else {
                alert(res.message || 'å»ºç«‹å¤±æ•—');
              }
            }
          );
        }

        function joinRoom() {
          const id = prompt('è¼¸å…¥æˆ¿é–“ID');
          if (!id) return;
          socket.emit('joinRoom', { roomId: id, name: name.trim() }, (res) => {
            if (res.ok) {
              setRoom(res.room);
              setView('HOME');
            } else alert(res.message || 'åŠ å…¥å¤±æ•—');
          });
        }

        function pickColor(i) {
          if (!room) return;
          setSelectedColor(i);
          socket.emit(
            'pickColor',
            { roomId: room.id, colorIndex: i },
            (res) => {
              if (res.ok) setRoom(res.room);
            }
          );
        }

        function openRoleSelect() {
          if (!room) return;
          setView('ROLE');
        }

        function confirmRole(roleIndex) {
          if (!room) return;
          setSelectedRole(roleIndex);
          socket.emit('pickRole', { roomId: room.id, roleIndex }, (res) => {
            if (res.ok) setRoom(res.room);
          });
          setView('HOME');
        }

        function readyUp() {
          if (selectedColor === null || selectedRole === null)
            return alert('è«‹å…ˆé¸æ“‡é¡è‰²èˆ‡è§’è‰²');
          socket.emit('readyUp', { roomId: room.id }, (res) => {
            if (!res.ok && res.message) alert(res.message);
          });
        }

        function startGame() {
          socket.emit('startGame', { roomId: room.id });
        }

        function cancelGinyu() {
          try {
            socket?.emit('ginyuCancel', { roomId: room?.id }, () => {});
          } catch (e) {}
          setHighlightSources([]);
          setHighlightTargets([]);
          setGinyuMode(false);
        }

        function place(x, y) {
          if (!room || room.status !== 'PLAYING') return;

          if (ginyuMode) {
            const inSources = highlightSources.some(
              (p) => p.x === x && p.y === y
            );
            const inTargets = highlightTargets.some(
              (p) => p.x === x && p.y === y
            );

            if (highlightSources.length && !highlightTargets.length) {
              if (!inSources) {
                cancelGinyu();
                return;
              }
              socket.emit(
                'ginyuSelectSource',
                { roomId: room.id, x, y },
                (res) => {
                  if (res.ok) setHighlightTargets(res.targets);
                  else {
                    if (!String(res.message || '').includes('å–æ¶ˆ'))
                      alert(res.message);
                    cancelGinyu();
                  }
                }
              );
              return;
            }

            if (highlightTargets.length) {
              if (!inTargets) {
                cancelGinyu();
                return;
              }
              socket.emit(
                'ginyuSelectTarget',
                { roomId: room.id, x, y },
                (res) => {
                  if (!res.ok) {
                    if (!String(res.message || '').includes('å–æ¶ˆ'))
                      alert(res.message);
                    cancelGinyu();
                  }
                }
              );
              return;
            }

            cancelGinyu();
            return;
          }

          if (gudoMode) {
            const localRoom = roomRef.current || room;

            if (
              !localRoom.gudoClientStep ||
              localRoom.gudoClientStep === 'idle'
            ) {
              socket.emit(
                'gudoSelectSource',
                { roomId: localRoom.id, x, y },
                (res) => {
                  if (res.ok) {
                    setHighlightGudo(res.highlights || []);
                    localRoom.gudoClientStep = 'selectTarget';
                  } else {
                    alert(res.message);
                    setGudoMode(false);
                    setHighlightGudo([]);
                    setHighlightGudoTargets([]);
                    setHighlightGudoSelf([]);
                    localRoom.gudoClientStep = 'idle';
                  }
                }
              );
              return;
            }

            if (localRoom.gudoClientStep === 'selectTarget') {
              socket.emit(
                'gudoSelectTarget',
                { roomId: localRoom.id, x, y },
                (res) => {
                  if (res.ok) {
                    setHighlightGudoTargets(res.emptyAround || []);
                    localRoom.gudoClientStep = 'selectMove';
                  } else {
                    alert(res.message);
                    setGudoMode(false);
                    setHighlightGudo([]);
                    setHighlightGudoTargets([]);
                    setHighlightGudoSelf([]);
                    localRoom.gudoClientStep = 'idle';
                  }
                }
              );
              return;
            }

            if (localRoom.gudoClientStep === 'selectMove') {
              socket.emit(
                'gudoMovePiece',
                { roomId: localRoom.id, x, y },
                (res) => {
                  if (!res.ok) alert(res.message);
                }
              );
              return;
            }
          }

          socket.emit('place', { roomId: room.id, x, y }, (res) => {
            if (!res.ok && res.message) alert(res.message);
          });
        }

        function activateGinyu() {
          socket.emit('ginyuAbilityStart', { roomId: room.id }, (res) => {
            if (res.ok) {
              setGinyuMode(true);
              setHighlightSources(res.sources);
            } else alert(res.message);
          });
        }

        function activateGudo() {
          socket.emit('gudoAbilityStart', { roomId: room.id }, (res) => {
            if (res.ok) {
              setGudoMode(true);
              setHighlightGudo([]);
              setHighlightGudoTargets([]);
              setHighlightGudoSelf(res.sources || []);
              if (roomRef.current) roomRef.current.gudoClientStep = 'idle';
            } else alert(res.message);
          });
        }

        const me = room?.players?.find((p) => p.id === socket?.id);
        const isMyTurn =
          room &&
          me &&
          room.turnIndex !== undefined &&
          room.players[room.turnIndex]?.id === me.id;

        const canStart =
          room &&
          room.hostId === socket?.id &&
          room.players &&
          room.players.length > 0 &&
          room.players.every((p) => p.ready);

        const boardToRender = postGame?.finalBoard
          ? postGame.finalBoard
          : board;

        return e(
          'div',
          { className: 'appRoot' },

          e(
            'div',
            { className: 'topBar' },
            e(
              'div',
              { className: 'brand' },
              e(
                'div',
                { className: 'title' },
                view === 'GAME' ? 'åŸºç´æ£‹ï½œå°å±€ä¸­' : 'åŸºç´æ£‹ï½œLobby'
              ),
              e(
                'div',
                { className: 'sub' },
                room
                  ? e(
                      React.Fragment,
                      null,
                      e('span', null, `æˆ¿é–“ï¼š${room.id}`),
                      e(
                        'button',
                        {
                          className: 'tinyBtn ' + (copied ? 'copied' : ''),
                          onClick: onCopyRoomId,
                          title: 'ä¸€éµè¤‡è£½æˆ¿é–“ç·¨è™Ÿ',
                        },
                        copied ? 'å·²è¤‡è£½' : 'è¤‡è£½'
                      )
                    )
                  : 'å»ºç«‹æˆ–åŠ å…¥æˆ¿é–“é–‹å§‹éŠç©'
              )
            ),
            e('div', { className: 'pill' }, socket?.id ? `ä½ å·²é€£ç·š` : 'é€£ç·šä¸­â€¦')
          ),

          view === 'HOME' &&
            e(
              'div',
              { className: 'screen twoCols' },

              e(
                'div',
                { className: 'card panelPad grid' },
                e('div', { className: 'label' }, 'åç¨±'),
                e('input', {
                  value: name,
                  onChange: (ev) => setName(ev.target.value),
                  placeholder: 'è¼¸å…¥åç¨±ï¼ˆå¿…å¡«ï¼‰',
                }),
                e(
                  'div',
                  { className: 'row' },
                  e(
                    'button',
                    { onClick: createRoom, disabled: !name.trim() },
                    'å»ºç«‹æˆ¿é–“'
                  ),
                  e(
                    'button',
                    { onClick: joinRoom, disabled: !name.trim() },
                    'åŠ å…¥æˆ¿é–“'
                  )
                ),

                room &&
                  room.status === 'LOBBY' &&
                  e(
                    React.Fragment,
                    null,
                    e(
                      'div',
                      { className: 'label', style: { marginTop: 8 } },
                      'é¡è‰²'
                    ),
                    e(
                      'div',
                      { className: 'rowWrap' },
                      COLORS.map((c, i) =>
                        e('div', {
                          key: i,
                          className: 'choice',
                          onClick: () => pickColor(i),
                          style: {
                            background: c,
                            outline:
                              selectedColor === i
                                ? '2px solid rgba(255,255,255,0.9)'
                                : 'none',
                          },
                        })
                      )
                    ),

                    e(
                      'div',
                      { className: 'label', style: { marginTop: 10 } },
                      'è§’è‰²'
                    ),
                    e(
                      'button',
                      { onClick: openRoleSelect },
                      selectedRole === null
                        ? 'é¸æ“‡è§’è‰²ï¼ˆå…¨è¢å¹•ï¼‰'
                        : `å·²é¸ï¼š${ROLES[selectedRole]?.name}ï¼ˆé»æˆ‘é‡é¸ï¼‰`
                    ),

                    selectedRole !== null &&
                      e(
                        'div',
                        { className: 'hint' },
                        `æŠ€èƒ½ï¼š${ROLES[selectedRole]?.desc || ''}`
                      ),

                    e(
                      'div',
                      { className: 'row', style: { marginTop: 10 } },
                      e('button', { onClick: readyUp }, 'æº–å‚™å®Œæˆ'),
                      canStart &&
                        e(
                          'button',
                          {
                            onClick: startGame,
                            style: {
                              background:
                                'linear-gradient(135deg, rgba(76,175,80,0.38), rgba(76,175,80,0.18))',
                              border: '1px solid rgba(255,255,255,0.18)',
                            },
                          },
                          'Start Game'
                        )
                    )
                  )
              ),

              e(
                'div',
                { className: 'card panelPad grid' },
                e(
                  'div',
                  { className: 'label' },
                  room ? 'ç©å®¶åˆ—è¡¨' : 'å°šæœªåŠ å…¥æˆ¿é–“'
                ),
                room &&
                  room.players &&
                  room.players.map((p) => {
                    const roleName =
                      typeof p.roleIndex === 'number'
                        ? ROLES[p.roleIndex]?.name
                        : null;
                    const roleText = roleName ? roleName : 'é¸è§’ä¸­';
                    const color =
                      typeof p.colorIndex === 'number'
                        ? COLORS[p.colorIndex]
                        : 'rgba(255,255,255,0.25)';
                    return e(
                      'div',
                      { key: p.id, className: 'playerLine' },
                      e(
                        'div',
                        { className: 'playerLeft' },
                        e('div', {
                          className: 'dot',
                          style: { background: color },
                        }),
                        e(
                          'div',
                          { style: { minWidth: 0 } },
                          e(
                            'div',
                            { className: 'playerName' },
                            p.name || 'Player'
                          ),
                          e('div', { className: 'playerMeta' }, roleText)
                        )
                      ),
                      e(
                        'div',
                        { className: 'badge' },
                        p.ready ? 'âœ… Ready' : 'â€¦'
                      )
                    );
                  })
              )
            ),

          view === 'GAME' &&
            e(
              'div',
              { className: 'screen grid' },
              e(
                'div',
                { className: 'card panelPad' },
                e(
                  'div',
                  { style: { fontWeight: 1000, marginBottom: 8 } },
                  'å°å±€'
                ),
                turnInfo
                  ? e(
                      'div',
                      { className: 'pill', style: { display: 'inline-block' } },
                      turnInfo
                    )
                  : null,
                e(
                  'div',
                  {
                    style: {
                      marginTop: 10,
                      display: 'flex',
                      gap: 10,
                      flexWrap: 'wrap',
                    },
                  },
                  isMyTurn && me?.roleIndex === 0
                    ? e(
                        'button',
                        {
                          onClick: activateGinyu,
                          style: { background: 'rgba(156,39,176,0.35)' },
                        },
                        'ç™¼å‹•åŸºç´èƒ½åŠ›'
                      )
                    : null,
                  isMyTurn && me?.roleIndex === 4
                    ? e(
                        'button',
                        {
                          onClick: activateGudo,
                          style: { background: 'rgba(76,175,80,0.35)' },
                        },
                        'ç™¼å‹•å¤æœèƒ½åŠ›'
                      )
                    : null
                )
              ),
              e(
                'div',
                { className: 'card boardWrap' },
                boardToRender.length > 0
                  ? e(Board, {
                      board: boardToRender,
                      onPlace: place,
                      room,
                      highlightSources,
                      highlightTargets,
                      highlightGudo,
                      highlightGudoTargets,
                      highlightGudoSelf,
                    })
                  : e('div', null, 'å°šæœªé–‹å§‹éŠæˆ²')
              )
            ),

          view === 'ROLE' &&
            e(RoleSelectScreen, {
              room,
              selectedRole,
              onClose: () => setView('HOME'),
              onConfirm: confirmRole,
            }),

          // âœ… è³½å¾Œ 10 ç§’ï¼šé¡¯ç¤ºå‹åˆ©è€… + å€’æ•¸ + è¿”å›æˆ¿é–“
          postGame &&
            e(
              'div',
              { className: 'postGame' },
              e(
                'div',
                { className: 'box' },
                e(
                  'div',
                  { className: 'title' },
                  `ğŸ† å‹åˆ©è€…ï¼š${postGame.winnerName}`
                ),
                e(
                  'div',
                  { className: 'sub' },
                  `æ£‹å±€å°‡åœ¨ ${postGame.secondsLeft} ç§’å¾Œè¿”å›æˆ¿é–“ï¼ˆå¯å…ˆæŒ‰ä¸‹æ–¹æŒ‰éˆ•ï¼‰`
                ),
                e(
                  'button',
                  { className: 'btn', onClick: backToRoom },
                  'è¿”å›æˆ¿é–“'
                )
              )
            )
        );
      }

      function RoleSelectScreen({ room, selectedRole, onClose, onConfirm }) {
        const n = ROLES.length;
        const [current, setCurrent] = React.useState(
          typeof selectedRole === 'number' ? selectedRole : 0
        );

        // âœ… æ¡Œæ©Ÿï¼šé»æ“Šå¾Œé–å®šï¼Œhover ä¸å†äº‚è·³ï¼ˆä»å¯é»åˆ¥å¼µæ”¹é¸ï¼‰
        const [lockedIndex, setLockedIndex] = React.useState(null);

        // ===== æ‰‹æ©Ÿï¼šæ›´é †çš„æ‹–æ›³ï¼ˆå¡ç‰‡è·Ÿæ‰‹æŒ‡èµ°ï¼‰ =====
        const carouselRef = React.useRef(null);
        const [dragPx, setDragPx] = React.useState(0);
        const dragPxRef = React.useRef(0);
        const rafRef = React.useRef(0);
        const dragRef = React.useRef({
          down: false,
          x0: 0,
          lastX: 0,
          lastT: 0,
          v: 0,
          pointerId: null,
        });

        const snapPxRef = React.useRef(260);

        React.useEffect(() => {
          function recalc() {
            const vw = window.innerWidth || 360;
            const cardW = Math.min(vw * 0.92, 420);
            snapPxRef.current = Math.max(200, Math.min(cardW * 0.78, 320));
          }
          recalc();
          window.addEventListener('resize', recalc);
          return () => window.removeEventListener('resize', recalc);
        }, []);

        function scheduleDragUpdate(px) {
          dragPxRef.current = px;
          if (rafRef.current) return;
          rafRef.current = requestAnimationFrame(() => {
            rafRef.current = 0;
            setDragPx(dragPxRef.current);
          });
        }

        function onPointerDown(ev) {
          dragRef.current.down = true;
          dragRef.current.x0 = ev.clientX;
          dragRef.current.lastX = ev.clientX;
          dragRef.current.lastT = performance.now();
          dragRef.current.v = 0;
          dragRef.current.pointerId = ev.pointerId;
          scheduleDragUpdate(0);
          try {
            ev.currentTarget.setPointerCapture(ev.pointerId);
          } catch (e) {}
        }

        function onPointerMove(ev) {
          if (!dragRef.current.down) return;
          const now = performance.now();
          const dx = ev.clientX - dragRef.current.lastX;
          const dt = Math.max(8, now - dragRef.current.lastT);
          // px/ms
          dragRef.current.v = dx / dt;
          dragRef.current.lastX = ev.clientX;
          dragRef.current.lastT = now;

          const total = ev.clientX - dragRef.current.x0;
          scheduleDragUpdate(total);
        }

        function onPointerUp(ev) {
          if (!dragRef.current.down) return;
          dragRef.current.down = false;

          const total = dragPxRef.current;
          const snapPx = snapPxRef.current;
          const progress = clamp(-total / snapPx, -1, 1);
          const v = dragRef.current.v;

          // flickï¼šé€Ÿåº¦å¤ å°±ç›´æ¥ç¿»é 
          const flick = Math.abs(v) > 0.65;

          if (flick) {
            if (v < 0) setCurrent((c) => (c + 1) % n);
            else setCurrent((c) => (c - 1 + n) % n);
          } else {
            if (progress > 0.28) setCurrent((c) => (c + 1) % n);
            else if (progress < -0.28) setCurrent((c) => (c - 1 + n) % n);
          }

          scheduleDragUpdate(0);

          try {
            ev.currentTarget.releasePointerCapture(ev.pointerId);
          } catch (e) {}
        }

        function clamp(v, a, b) {
          return Math.max(a, Math.min(b, v));
        }

        function shortDelta(i, c) {
          let d = i - c;
          const half = Math.floor(n / 2);
          while (d > half) d -= n;
          while (d < -half) d += n;
          return d;
        }

        const others = (room?.players || []).map((p) => {
          const rn =
            typeof p.roleIndex === 'number' ? ROLES[p.roleIndex]?.name : null;
          return { name: p.name || 'Player', role: rn || 'é¸è§’ä¸­' };
        });

        const role = ROLES[current];

        // æ‹–æ›³é€²åº¦ï¼šå·¦æ»‘ç‚ºæ­£ï¼ˆå¾€ä¸‹ä¸€å¼µï¼‰
        const snapPx = snapPxRef.current;
        const dragProgress = clamp(-dragPx / snapPx, -1, 1);

        return e(
          'div',
          { className: 'roleScreen' },

          e(
            'div',
            { className: 'roleTop' },
            e(
              'div',
              { className: 'roleTopLeft' },
              e(
                'div',
                { className: 'brand' },
                e('div', { className: 'title' }, 'é¸æ“‡è§’è‰²'),
                e(
                  'div',
                  { className: 'sub' },
                  'æ‰‹æ©Ÿï¼šæ»‘å‹•é¸å¡ï½œæ¡Œæ©Ÿï¼šé»æ“Šé–å®šï¼ˆé¿å…æ»‘é¼ ç§»å‹•èª¤é¸ï¼‰'
                )
              ),
              e(
                'div',
                { className: 'miniList' },
                others.map((o, idx) =>
                  e(
                    'div',
                    { key: idx, className: 'miniChip' },
                    `${o.name}ï¼š${o.role}`
                  )
                )
              )
            ),
            e('button', { className: 'ghost', onClick: onClose }, 'è¿”å›æˆ¿é–“')
          ),

          e(
            'div',
            { className: 'roleMain' },

            // æ‰‹æ©Ÿæ»‘å‹• deckï¼ˆæ›´é †ï¼šè·Ÿæ‰‹èµ° + å·¦å³åªéœ²é‚Šæ¡†ï¼‰
            e(
              'div',
              {
                ref: carouselRef,
                className: 'carousel',
                onPointerDown,
                onPointerMove,
                onPointerUp,
              },
              e(
                'div',
                { className: 'carouselInner' },
                ROLES.map((r, i) => {
                  const d = shortDelta(i, current);
                  // æ‹–æ›³æ™‚ï¼Œç­‰æ•ˆä¸­å¿ƒæœƒåç§»
                  const de = d - dragProgress;
                  const ae = Math.abs(de);

                  // ä½ç½®ï¼šç›¸é„°æ¨æ›´é ï¼ˆåªéœ²é‚Šï¼‰ï¼Œæ›´é çš„å¹¾ä¹ä¸é¡¯ç¤º
                  const baseShift = 112; // è®“å·¦å³åªéœ²å‡ºä¸€å°æ®µ
                  const extra = ae > 1.35 ? 26 : 0;
                  const tx = de * (baseShift + extra);

                  // 3D/ç¸®æ”¾ï¼šä¸­å¿ƒæ›´çªå‡º
                  const scale = ae < 0.01 ? 1.0 : ae < 1.0 ? 0.94 : 0.88;
                  const ry = clamp(de, -2, 2) * 12;
                  const rz = clamp(de, -2, 2) * -3.5;

                  // é€æ˜/æ¨¡ç³Šï¼šç›¸é„°æ›´æ·¡ï¼Œé çš„ç›´æ¥æ¶ˆå¤±
                  const opacity =
                    ae < 0.35 ? 1.0 : ae < 1.2 ? 0.22 : ae < 2.1 ? 0.06 : 0;
                  const blur = ae < 0.35 ? 0 : ae < 1.2 ? 0.6 : 1.2;
                  const sat = ae < 0.35 ? 1.08 : 0.85;
                  const contrast = ae < 0.35 ? 1.06 : 0.95;

                  const isCenter = ae < 0.35;

                  const style = {
                    transform: `translate3d(${tx}%, 0, 0) rotateY(${ry}deg) rotateZ(${rz}deg) scale(${scale})`,
                    opacity,
                    filter: `blur(${blur}px) saturate(${sat}) contrast(${contrast})`,
                    zIndex: 1000 - Math.round(ae * 50),
                    transition: dragRef.current.down
                      ? 'none'
                      : 'transform 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms ease, filter 220ms ease',
                    pointerEvents: isCenter ? 'auto' : 'none',
                    boxShadow: isCenter
                      ? '0 34px 90px rgba(0,0,0,0.62)'
                      : '0 18px 55px rgba(0,0,0,0.45)',
                    borderColor: isCenter
                      ? 'rgba(255,255,255,0.28)'
                      : 'rgba(255,255,255,0.12)',
                  };

                  // é å¡å®Œå…¨ä¸æ¸²æŸ“é»æ“Šæ„Ÿï¼ˆä½†ä¿ç•™å¸ƒå±€ï¼‰
                  if (opacity === 0) {
                    style.transform = `translate3d(${tx}%,0,0) scale(0.72)`;
                  }

                  return e(
                    'div',
                    {
                      key: i,
                      className: 'roleCard',
                      style,
                      onClick: () => setCurrent(i),
                    },
                    e(
                      'div',
                      { className: 'roleCardHeader' },
                      e('div', { className: 'roleName' }, r.name),
                      e(
                        'div',
                        { className: 'roleIcon' },
                        e('div', {
                          className: r.shape,
                          style: { color: '#fff' },
                        })
                      )
                    ),
                    e('div', { className: 'roleDesc' }, r.desc),
                    e(
                      'div',
                      { className: 'roleStats' },
                      e(
                        'div',
                        { className: 'stat' },
                        e('div', null, 'å®šä½'),
                        e(
                          'b',
                          null,
                          i === 1
                            ? 'é€²æ”»'
                            : i === 0 || i === 4
                            ? 'æ“ä½œ'
                            : 'æ§åˆ¶'
                        )
                      ),
                      e(
                        'div',
                        { className: 'stat' },
                        e('div', null, 'å›åˆ'),
                        e('b', null, i === 1 || i === 3 ? 'å¤šæ­¥' : 'å–®æ­¥')
                      )
                    )
                  );
                })
              )
            ),

            // æ¡Œæ©Ÿä¸¦æ’ deckï¼ˆæ»¿ç‰ˆï¼‰ï¼šhover åªåœ¨ã€Œå°šæœªé–å®šã€æ™‚ç”Ÿæ•ˆ
            e(
              'div',
              { className: 'desktopDeck' },
              ROLES.map((r, i) => {
                const active = i === current;
                const cls = 'desktopCard ' + (active ? 'active' : 'dim');
                return e(
                  'div',
                  {
                    key: i,
                    className: cls,
                    onMouseEnter: () => {
                      if (lockedIndex === null) setCurrent(i);
                    },
                    onClick: () => {
                      setCurrent(i);
                      setLockedIndex(i); // âœ… é»æ“Šå¾Œé–å®š
                    },
                  },
                  e(
                    'div',
                    { className: 'roleCardHeader' },
                    e('div', { className: 'roleName' }, r.name),
                    e(
                      'div',
                      { className: 'roleIcon' },
                      e('div', { className: r.shape, style: { color: '#fff' } })
                    )
                  ),
                  e('div', { className: 'roleDesc' }, r.desc),
                  e(
                    'div',
                    { className: 'roleStats' },
                    e(
                      'div',
                      { className: 'stat' },
                      e('div', null, 'å®šä½'),
                      e(
                        'b',
                        null,
                        i === 1 ? 'é€²æ”»' : i === 0 || i === 4 ? 'æ“ä½œ' : 'æ§åˆ¶'
                      )
                    ),
                    e(
                      'div',
                      { className: 'stat' },
                      e('div', null, 'å›åˆ'),
                      e('b', null, i === 1 || i === 3 ? 'å¤šæ­¥' : 'å–®æ­¥')
                    )
                  )
                );
              })
            )
          ),

          e(
            'div',
            { className: 'roleBottom' },
            e(
              'div',
              { className: 'hint' },
              lockedIndex === null
                ? `ç›®å‰é¸æ“‡ï¼š${role?.name || 'â€”'}ï¼ˆæ¡Œæ©Ÿï¼šé»ä¸€ä¸‹å¯é–å®šï¼‰`
                : `å·²é–å®šï¼š${role?.name || 'â€”'}ï¼ˆå¯é»å…¶ä»–å¡æ”¹é¸ï¼‰`
            ),
            e(
              'button',
              { className: 'confirm', onClick: () => onConfirm(current) },
              'ç¢ºå®šè§’è‰²'
            )
          )
        );
      }

      function Board({
        board,
        onPlace,
        room,
        highlightSources,
        highlightTargets,
        highlightGudo,
        highlightGudoTargets,
        highlightGudoSelf,
      }) {
        const size = board.length;
        const cells = [];
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const v = board[y][x];
            const player =
              v > 0 ? room.players[(v - 1) % room.players.length] : null;
            const color = player ? COLORS[player.colorIndex || 0] : '#fff';

            let className = 'cell';
            if (highlightSources.some((p) => p.x === x && p.y === y))
              className += ' highlight-source';
            if (highlightTargets.some((p) => p.x === x && p.y === y))
              className += ' highlight-target';
            if (highlightGudo.some((p) => p.x === x && p.y === y))
              className += ' highlight-gudo';
            if (highlightGudoTargets.some((p) => p.x === x && p.y === y))
              className += ' highlight-gudo-target';
            if (highlightGudoSelf.some((p) => p.x === x && p.y === y))
              className += ' highlight-gudo-self';

            let inner = null;
            if (v > 0) {
              const role = ROLES[player.roleIndex] || ROLES[0];
              inner = e('div', { className: role.shape, style: { color } });
            } else if (v < 0) {
              const ownerIndex = Math.abs(v) - 1;
              const owner = room.players[ownerIndex];
              const baseColor = COLORS[owner.colorIndex || 0];
              const darker = `rgb(${
                parseInt(baseColor.slice(1, 3), 16) * 0.6
              }, ${parseInt(baseColor.slice(3, 5), 16) * 0.6}, ${
                parseInt(baseColor.slice(5, 7), 16) * 0.6
              })`;
              inner = e('div', {
                className: 'grayX',
                style: { color: darker },
              });
            }

            cells.push(
              e(
                'div',
                { key: `${x},${y}`, className, onClick: () => onPlace(x, y) },
                inner
              )
            );
          }
        }

        return e(
          'div',
          { className: 'board' },
          e(
            'div',
            {
              className: 'boardGrid',
              style: { gridTemplateColumns: `repeat(${size}, 28px)` },
            },
            cells
          )
        );
      }

      ReactDOM.createRoot(document.getElementById('app')).render(e(App));
    </script>
  </body>
</html>
